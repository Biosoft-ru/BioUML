/* $Id$ */

package biouml.plugins.gtrd.analysis;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.lang.ArrayUtils;

import biouml.plugins.gtrd.utils.FunSite;
import biouml.plugins.gtrd.utils.FunSiteUtils.CombinedSites;
import biouml.plugins.gtrd.utils.FunSiteUtils.QualityControlSites;
import biouml.plugins.gtrd.utils.TrackInfo;
import biouml.plugins.machinelearning.utils.DataMatrix;
import biouml.plugins.machinelearning.utils.TableAndFileUtils;
import biouml.standard.type.Species;

import com.developmentontheedge.beans.PropertyDescriptorEx;
import com.developmentontheedge.beans.annot.PropertyDescription;
import com.developmentontheedge.beans.annot.PropertyName;
import com.developmentontheedge.beans.editors.StringTagEditor;

import ru.biosoft.access.core.DataCollection;
import ru.biosoft.access.DataCollectionUtils;
import ru.biosoft.access.core.DataElement;
import ru.biosoft.access.core.DataElementPath;
import ru.biosoft.access.core.FolderCollection;
import ru.biosoft.access.core.RepositoryException;
import ru.biosoft.access.repository.DataElementPathEditor;
import ru.biosoft.analysiscore.AbstractAnalysisParameters;
import ru.biosoft.analysiscore.AnalysisMethodSupport;
import ru.biosoft.util.ConstantResourceBundle;
import ru.biosoft.util.bean.BeanInfoEx2;
import ru.biosoft.workbench.editors.DataElementComboBoxSelector;
import ru.biosoft.workbench.editors.GenericMultiSelectEditor;

/**
 * @author yura
 *
 */

public class QualityControlMetrics extends AnalysisMethodSupport<QualityControlMetrics.QualityControlMetricsParameters>
{
    public static final String OUTPUT_TABLE_NAME = "quality_control_metrics";
    
    public QualityControlMetrics(DataCollection<?> origin, String name)
    {
         super(origin, name, new QualityControlMetricsParameters());
    }
    
    @Override
    public DataCollection<?> justAnalyzeAndPut() throws Exception
    {
        log.info("**********************************************************");
        log.info("*            QualityControlMetrics                       *");
        log.info("* Calculation of quality control metrics for GTRD-tracks *");
        log.info("* generated by several peak callers.                     *");
        log.info("**********************************************************");

        Species givenSpecie = parameters.getSpecies();
        DataElementPath pathToFolderWithFolders = parameters.getPathToFolderWithFolders();
        String[] foldersNames = parameters.getFoldersNames();
        String combinedPeakType = parameters.getCombinedPeakType();
        int minimalLengthOfPeaks = parameters.getMinimalLengthOfPeaks();
        int maximalLengthOfPeaks = parameters.getMaximalLengthOfPeaks();
        double fpcmThreshold = parameters.getFpcmThreshold();
        boolean doAddAuxiliaryInformation = parameters.getDoAddAuxiliaryInformation();
        DataElementPath pathToOutputFolder = parameters.getPathToOutputFolder();
        
        DataCollectionUtils.createFoldersForPath(pathToOutputFolder.getChildPath(""));
        
        // 1. Create array of track names (distinctTracksNames) for further analysis. Remove analyzed track names.
        String[] distinctTracksNames = TrackInfo.getDistinctTracksNamesInSeveralFolders(pathToFolderWithFolders, givenSpecie, foldersNames);
        DataElementPath path = pathToOutputFolder.getChildPath(OUTPUT_TABLE_NAME);
        String[] rowNames = ! path.exists() ? null : TableAndFileUtils.getRowNamesInTable(path);
        if( rowNames != null )
        {
            List<String> list = new ArrayList<>();
            for( String s : distinctTracksNames )
                if( ! ArrayUtils.contains(rowNames, s) )
                    list.add(s);
            distinctTracksNames = list.toArray(new String[0]);
        }

        // 2. Create combined sets and calculate FNCMs and FPCM for them. 
        for( int i = 0; i < distinctTracksNames.length; i++ )
        {
            jobControl.setPreparedness(100 * i / distinctTracksNames.length);
            CombinedSites css = new CombinedSites(combinedPeakType, pathToFolderWithFolders, foldersNames, distinctTracksNames[i], minimalLengthOfPeaks, maximalLengthOfPeaks, true);
            FunSite[] funSites = css.getCombinedSites();
            if( funSites.length < 300 ) continue;
            DataMatrix dm = QualityControlSites.calculateQualityMetrics(funSites, foldersNames, fpcmThreshold);
            if( doAddAuxiliaryInformation )
                dm.addAnotherDataMatrixColumnWise(getAuxiliaryInformation(funSites, foldersNames));
            TableAndFileUtils.addRowToTable(dm.getRow("values"), null, distinctTracksNames[i], dm.getColumnNames(), pathToOutputFolder, OUTPUT_TABLE_NAME);
        }

        return pathToOutputFolder.getDataCollection();
    }
    
    private DataMatrix getAuxiliaryInformation(FunSite[] funSites, String[] foldersNames)
    {
        // 1. Identify columnNames for DataMatrix.
        String [] columnNames = new String[2 * foldersNames.length];
        for( int i = 0; i < foldersNames.length; i++ )
        {
            columnNames[2 * i] = "observed_size_" + foldersNames[i];
            columnNames[2 * i + 1] = "observed_size_without_orphans_" + foldersNames[i];
        }
        columnNames = (String[])ArrayUtils.addAll(columnNames, new String[]{"observed_size_total", "observed_size_total_without_orphans"});

        // 2. Identify columnNames for DataMatrix.
        double[] vector = new double[2 * foldersNames.length];
        for( FunSite fs : funSites )
            for( int i = 0; i < foldersNames.length; i++ )
                if( fs.doContainGivenRowName(foldersNames[i]) )
                {
                    vector[2 * i] += 1.0;
                    if( ! fs.isOrphan() )
                        vector[2 * i + 1] += 1.0;
                }
        int nonOrphans = 0;
        for( FunSite fs : funSites )
            if( ! fs.isOrphan() )
                nonOrphans++;
        vector = ArrayUtils.addAll(vector, new double[]{(double)funSites.length, (double)nonOrphans});
        return new DataMatrix("values", columnNames, vector);
    }

    /************************************************************************/
    /************************** Utils for AnalysisMethodSupport *************/
    /************************************************************************/
    
    public class MessageBundle extends ConstantResourceBundle
    {
      public static final String PN_SPECIES = "Species";
      public static final String PD_SPECIES = "Select a taxonomical species";
      
      public static final String PN_PATH_TO_FOLDER_WITH_FOLDERS = "Path to folder with folders";
      public static final String PD_PATH_TO_FOLDER_WITH_FOLDERS = "Path to folder with folders (Each internal folder contains ChIP-seq tracks with peaks)";
      
      public static final String PN_FOLDERS_NAMES = "Folders names";
      public static final String PD_FOLDERS_NAMES = "Select folders names";
      
      public static final String PN_COMBINED_PEAK_TYPE = "Type of combined peaks";
      public static final String PD_COMBINED_PEAK_TYPE = "Type of combined peaks";

      public static final String PN_MINIMAL_LENGTH_OF_PEAKS = "Minimal length of peaks";
      public static final String PD_MINIMAL_LENGTH_OF_PEAKS = "All peaks that are shorter than this threshold will be prolongated";

      
      public static final String PN_MAXIMAL_LENGTH_OF_PEAKS = "Maximal length of peaks";
      public static final String PD_MAXIMAL_LENGTH_OF_PEAKS = "All peaks that are longer than this threshold will be truncated";
      
      public static final String PN_FPCM_THRESHOLD = "FPCM threshold";
      public static final String PD_FPCM_THRESHOLD = "FPCM threshold";
      
      public static final String PN_DO_ADD_AUXILIARY_INFORMATION = "Do add auxiliary information";
      public static final String PD_DO_ADD_AUXILIARY_INFORMATION = "Do add auxiliary information (such as number of observed peaks without orphans)?";
      
      public static final String PN_PATH_TO_OUTPUT_FOLDER = "Path to output folder";
      public static final String PD_PATH_TO_OUTPUT_FOLDER = "Path to output folder";
    }
    
    public static class QualityControlMetricsParameters extends AbstractAnalysisParameters
    {
        private Species species = Species.getDefaultSpecies(null);
        private DataElementPath pathToFolderWithFolders;
        private String[] foldersNames;
        private String combinedPeakType = CombinedSites.SITE_TYPE_MERGED;
        private int minimalLengthOfPeaks = 20;
        private int maximalLengthOfPeaks = 300;
        private double fpcmThreshold = 2.0;
        private boolean doAddAuxiliaryInformation = false;
        private DataElementPath pathToOutputFolder;

        public QualityControlMetricsParameters()
        {}
        
        @PropertyName(MessageBundle.PN_SPECIES)
        @PropertyDescription(MessageBundle.PD_SPECIES)
        public Species getSpecies()
        {
            return species;
        }
        public void setSpecies(Species species)
        {
            Object oldValue = this.species;
            this.species = species;
            firePropertyChange("species", oldValue, species);
        }
        
        @PropertyName(MessageBundle.PN_PATH_TO_FOLDER_WITH_FOLDERS)
        @PropertyDescription(MessageBundle.PD_PATH_TO_FOLDER_WITH_FOLDERS)
        public DataElementPath getPathToFolderWithFolders()
        {
            return pathToFolderWithFolders;
        }
        public void setPathToFolderWithFolders(DataElementPath pathToFolderWithFolders)
        {
            Object oldValue = this.pathToFolderWithFolders;
            this.pathToFolderWithFolders = pathToFolderWithFolders;
            firePropertyChange("*", oldValue, pathToFolderWithFolders);
        }

        @PropertyName(MessageBundle.PN_FOLDERS_NAMES)
        @PropertyDescription(MessageBundle.PD_FOLDERS_NAMES)
        public String[] getFoldersNames()
        {
            return foldersNames;
        }
        public void setFoldersNames(String[] foldersNames)
        {
            Object oldValue = this.foldersNames;
            this.foldersNames = foldersNames;
            firePropertyChange("foldersNames", oldValue, foldersNames);
        }
        
        @PropertyName(MessageBundle.PN_COMBINED_PEAK_TYPE)
        @PropertyDescription(MessageBundle.PD_COMBINED_PEAK_TYPE)
        public String getCombinedPeakType()
        {
            return combinedPeakType;
        }
        public void setCombinedPeakType(String combinedPeakType)
        {
            Object oldValue = this.combinedPeakType;
            this.combinedPeakType = combinedPeakType;
            firePropertyChange("combinedPeakType", oldValue, combinedPeakType);
        }

        @PropertyName(MessageBundle.PN_MINIMAL_LENGTH_OF_PEAKS)
        @PropertyDescription(MessageBundle.PD_MINIMAL_LENGTH_OF_PEAKS)
        public int getMinimalLengthOfPeaks()
        {
            return minimalLengthOfPeaks;
        }
        public void setMinimalLengthOfPeaks(int minimalLengthOfPeaks)
        {
            Object oldValue = this.minimalLengthOfPeaks;
            this.minimalLengthOfPeaks = minimalLengthOfPeaks;
            firePropertyChange("minimalLengthOfPeaks", oldValue, minimalLengthOfPeaks);
        }

        @PropertyName(MessageBundle.PN_MAXIMAL_LENGTH_OF_PEAKS)
        @PropertyDescription(MessageBundle.PD_MAXIMAL_LENGTH_OF_PEAKS)
        public int getMaximalLengthOfPeaks()
        {
            return maximalLengthOfPeaks;
        }
        public void setMaximalLengthOfPeaks(int maximalLengthOfPeaks)
        {
            Object oldValue = this.maximalLengthOfPeaks;
            this.maximalLengthOfPeaks = maximalLengthOfPeaks;
            firePropertyChange("maximalLengthOfPeaks", oldValue, maximalLengthOfPeaks);
        }
        
        @PropertyName(MessageBundle.PN_FPCM_THRESHOLD)
        @PropertyDescription(MessageBundle.PD_FPCM_THRESHOLD)
        public double getFpcmThreshold()
        {
            return fpcmThreshold;
        }
        public void setFpcmThreshold(double fpcmThreshold)
        {
            Object oldValue = this.fpcmThreshold;
            this.fpcmThreshold = fpcmThreshold;
            firePropertyChange("fpcmThreshold", oldValue, fpcmThreshold);
        }
        
        @PropertyName(MessageBundle.PN_DO_ADD_AUXILIARY_INFORMATION)
        @PropertyDescription(MessageBundle.PD_DO_ADD_AUXILIARY_INFORMATION)
        public boolean getDoAddAuxiliaryInformation()
        {
            return doAddAuxiliaryInformation;
        }
        public void setDoAddAuxiliaryInformation(boolean doAddAuxiliaryInformation)
        {
            Object oldValue = this.doAddAuxiliaryInformation;
            this.doAddAuxiliaryInformation = doAddAuxiliaryInformation;
            firePropertyChange("doAddAuxiliaryInformation", oldValue, doAddAuxiliaryInformation);
        }

        @PropertyName(MessageBundle.PN_PATH_TO_OUTPUT_FOLDER)
        @PropertyDescription(MessageBundle.PD_PATH_TO_OUTPUT_FOLDER)
        public DataElementPath getPathToOutputFolder()
        {
            return pathToOutputFolder;
        }
        public void setPathToOutputFolder(DataElementPath pathToOutputFolder)
        {
            Object oldValue = this.pathToOutputFolder;
            this.pathToOutputFolder = pathToOutputFolder;
            firePropertyChange("pathToOutputFolder", oldValue, pathToOutputFolder);
        }
    }
    
    public static class FoldersNamesSelector extends GenericMultiSelectEditor
    {
        @Override
        protected String[] getAvailableValues()
        {
            try
            {
                DataCollection<DataElement> folders = ((QualityControlMetricsParameters)getBean()).getPathToFolderWithFolders().getDataCollection(DataElement.class);
                String[] foldersNames = folders.getNameList().toArray(new String[0]);
                Arrays.sort(foldersNames, String.CASE_INSENSITIVE_ORDER);
                return foldersNames;
            }
            catch( RepositoryException e )
            {
                return new String[]{"(please select folder with folders)"};
            }
            catch( Exception e )
            {
                return new String[]{"(folder doesn't contain the folders)"};
            }
        }
    }
    
    public static class CombinedPeakTypeSelector extends StringTagEditor
    {
        @Override
        public String[] getTags()
        {
            return CombinedSites.getAvailableSiteTypes();
        }
    }

    public static class QualityControlMetricsParametersBeanInfo extends BeanInfoEx2<QualityControlMetricsParameters>
    {
        public QualityControlMetricsParametersBeanInfo()
        {
            super(QualityControlMetricsParameters.class);
        }
        
        @Override
        protected void initProperties() throws Exception
        {
            add(DataElementComboBoxSelector.registerSelector("species", beanClass, Species.SPECIES_PATH));
            add(DataElementPathEditor.registerInput("pathToFolderWithFolders", beanClass, FolderCollection.class));
            add("foldersNames", FoldersNamesSelector.class);
            add(new PropertyDescriptorEx("combinedPeakType", beanClass), CombinedPeakTypeSelector.class);
            add("minimalLengthOfPeaks");
            add("maximalLengthOfPeaks");
            add("fpcmThreshold");
            add("doAddAuxiliaryInformation");
            add(DataElementPathEditor.registerOutput("pathToOutputFolder", beanClass, FolderCollection.class, true));
        }
    }
}

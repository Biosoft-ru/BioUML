package biouml.plugins.simulation;

import biouml.model.Diagram;
import biouml.model.dynamics.Assignment;
import biouml.model.dynamics.EModel;
import biouml.model.dynamics.Event;
import biouml.model.dynamics.Variable;
import biouml.model.dynamics.VariableRole;
import biouml.standard.type.Stub;
import biouml.standard.type.Type;

import java.util.List;
import java.util.ArrayList;
import one.util.streamex.StreamEx;
import com.developmentontheedge.beans.DynamicProperty;

public class EventPreprocessor extends Preprocessor
{
    public static final String DELAY_TRIGGER_TYPE = "trigger";
    public static final String DELAY_ASSIGNMENT_TYPE = "assignment";
    public static final String EVENT_TYPE = "eventType";
    
    private EModel emodel;
    private Diagram diagram;
    private String assignmentVar;

    private void init(Diagram diagram)
    {
        this.emodel = (EModel)diagram.getRole();
        this.diagram = diagram;
    }

    @Override
    public Diagram preprocess(Diagram diagram) throws Exception
    {
        init(diagram);
        assignmentVar = generateUniqueVariable("assignment", emodel); //this temp variable is never used and actually replaced in future maybe get rid of it
        emodel.declareVariable(assignmentVar, 0.0);
        emodel.getVariable( assignmentVar ).getAttributes().add( new DynamicProperty( AUTOGENERATED_VAR, boolean.class, true ) );
        for( Event event : emodel.getEvents() )
            processDelayedEvent(event);
        return diagram;
    }
    
    /**
     * If event has a delay, we decompose it into two events: Trigger Event and Execution Event.<br>
     * Trigger event has the same trigger as initial event and has no delay, its assignment defines execution time of <i>execution event:</i><br>
     * executionTime = this.time + delay
     * Execution event has the same assignments as initial event and has no delay, its <i>trigger:</i>
     * this.time >= executionTime
     * @param event - initial event with delay
     */
    protected void processDelayedEvent(Event event) throws Exception
    {
        if (Boolean.TRUE.equals(event.getDiagramElement().getAttributes().getValue("Terminal")))
                return;
        List<Assignment> calculateAssignments = new ArrayList<>();
        List<Assignment> executeAssignments = new ArrayList<>();
        generateAssignments( event, calculateAssignments, executeAssignments );
        createTriggerEvent( event, calculateAssignments);
        createExecutionEvent(event, executeAssignments);
        diagram.getType().getSemanticController().remove( event.getDiagramElement() );
    }

    /**
     * transform assignments into two groups:
     * @param event
     * @param calculateAssignments
     * @param executeAssignments
     *
     * A = F(A,B)       assignmentA = F(A,B)
     * B = G(A,B)  =>   assignmentB = G(A,B)
     *                 --------------
     *                     A = assignmentA
     *                     B = assignmentA
     * Note: those two groups of assignments can be calculated at different time moments according to useValuesFromTriggerTime event attribute
     */
    private void generateAssignments(Event event, List<Assignment> calculateAssignments,
            List<Assignment> executeAssignments) throws Exception
    {
        calculateAssignments.clear();
        executeAssignments.clear();

        List<Assignment> newAssignments = StreamEx.of( event.getEventAssignment() )
                .filter( sa -> !emodel.getVariable( sa.getVariable() ).isConstant() ).map( sa -> sa.clone( null ) ).toList();
        
        newAssignments = reorderAssignments(newAssignments);
        if( !event.isUseValuesFromTriggerTime() )
        {
            executeAssignments.addAll(newAssignments);
            return;
        }

        StreamEx.of(newAssignments).map(sa -> new Assignment(assignmentVar, sa.getMath())).forEach(calculateAssignments::add); //assignmentA = F(A,B)
        StreamEx.of(newAssignments).map(sa -> new Assignment(sa.getVariable(), "1.0")).forEach(executeAssignments::add); // A = assignmentA
    }

    public String generateUniqueVariable(String base, EModel emodel) throws Exception
    {
        int index = 1;
        String result = base;
        while( emodel.getVariable(result) != null )
            result = base + index++;
        Variable var = new Variable(result, emodel, null);
        var.getAttributes().add( new DynamicProperty("temp", Boolean.class, true) );
        emodel.getVariables().put(var);
        return result;
    }

    /**
     * If event has a delay, we decompose it into two events: Trigger Event and Execution Event.<br>
     * Trigger event has the same trigger as initial event and has no delay, its assignment defines execution time of <i>execution event:</i><br>
     * executionTime = this.time + delay
     * @see createExecutionEvent
     * @param event - initial event with delay
     * @param newAssignments
     * @return Trigger Event
     */
    private void createTriggerEvent(Event baseEvent, List<Assignment> assignments) throws Exception
    {
        assignments.add(0, new Assignment("time", "time + " + baseEvent.getDelay()));

        Event event = createEvent(baseEvent.getDiagramElement().getName() + " part1", baseEvent.getDiagramElement().getTitle() + " part1",
                baseEvent.getTrigger(), null, "Infinity", assignments, baseEvent);
        event.setTriggerMessage(baseEvent.getTriggerMessage());
        event.getDiagramElement().getAttributes().add(new DynamicProperty(EVENT_TYPE, String.class, DELAY_TRIGGER_TYPE));
    }

    /**
     * If event has a delay, we decompose it into two events: Trigger Event and Execution Event.<br>
     * Execution event has the same assignments as initial event and has no delay, its trigger:</i>
     * this.time >= executionTime
     * where executionTime is defined by Trigger Event
     * @param event - initial event with delay
     * @param newAssignments
     * @return Execution Event
     */
    private void createExecutionEvent(Event baseEvent, List<Assignment> assignments) throws Exception
    {
        String trigger = null;
        if( !baseEvent.isTriggerPersistent() || "0".equals(baseEvent.getDelay()) )
            trigger = baseEvent.getTrigger();

        Event event = createEvent(baseEvent.getDiagramElement().getName() + " part2", baseEvent.getDiagramElement().getTitle() + " part2",
                trigger, baseEvent.getDelay(), baseEvent.getPriority(), assignments, baseEvent);

        event.getDiagramElement().getAttributes().add(new DynamicProperty(EVENT_TYPE, String.class, DELAY_ASSIGNMENT_TYPE));
    }

    private Event createEvent(String name, String title, String trigger, String delay, String priority, List<Assignment> assignments, Event baseEvent)
    {
        biouml.model.Node node = new biouml.model.Node( diagram, new Stub( null, name, Type.MATH_EVENT ) );
        node.setTitle( title );
        Event event = new Event( node, trigger, delay, assignments.toArray( new Assignment[assignments.size()] ) );
        event.setPriority( priority );
        event.setTriggerInitialValue( baseEvent.isTriggerInitialValue() );
        event.setTriggerPersistent( baseEvent.isTriggerPersistent() );
        event.setUseValuesFromTriggerTime( baseEvent.isUseValuesFromTriggerTime() );
        event.setDelay(delay);
        node.setRole( event );
        diagram.put( node );
        return event;
    }
    
    /**Assignments changing compartments ar moved to the end of list
     * Lets consider simple event<br>
     * C = 2<br>
     * S1 = 1<br>
     * let S1 be inside compartment C and have "quantityType = concentration" which means that 1 is in concentration units (e.g. mol/l)
     * Thus it would be reprocessed to amount (since we operate in amounts inside JavaBaseModel:<br>
     * C = 2<br>
     * S1 = 1*C<br>
     * Thus assignment for C will affect assignment for S1 and should be performed after it.
     */
    private List<Assignment> reorderAssignments(List<Assignment> assignments)
    {
        List<Assignment> reordered = new ArrayList<>();
        for (Assignment assignment: assignments)
        {
            Variable var = emodel.getVariable(assignment.getVariable());
            if (var instanceof VariableRole && ( (VariableRole)var ).getDiagramElement().getKernel() instanceof biouml.standard.type.Compartment)
                reordered.add(assignment);
            else
                reordered.add(0, assignment);
        }
        return reordered;
    }
}

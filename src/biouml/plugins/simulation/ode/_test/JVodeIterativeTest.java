package biouml.plugins.simulation.ode._test;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;

import biouml.plugins.simulation.java.JavaBaseModel;
import biouml.plugins.simulation.ode.jvode.IterativeSolver;
import biouml.plugins.simulation.ode.jvode.JVodeSpgmr;
import biouml.plugins.simulation.ode.jvode.IterativeSolver.BandPrecondition;
import biouml.plugins.simulation.ode.jvode.JVodeSupport.Method;

/*
 * -----------------------------------------------------------------
 * $Revision: 1.11 $
 * $Date: 2013/11/28 11:02:46 $
 * -----------------------------------------------------------------
 * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh and
 *                Radu Serban @LLNL
 * -----------------------------------------------------------------
 * Example problem:
 *
 * An ODE system is generated from the following 2-species diurnal
 * kinetics advection-diffusion PDE system in 2 space dimensions:
 *
 * dc(i)/dt = Kh*(d/dx)^2 c(i) + V*dc(i)/dx + (d/dy)(Kv(y)*dc(i)/dy)
 *                 + Ri(c1,c2,t)      for i = 1,2,   where
 *   R1(c1,c2,t) = -q1*c1*c3 - q2*c1*c2 + 2*q3(t)*c3 + q4(t)*c2 ,
 *   R2(c1,c2,t) =  q1*c1*c3 - q2*c1*c2 - q4(t)*c2 ,
 *   Kv(y) = Kv0*exp(y/5) ,
 * Kh, V, Kv0, q1, q2, and c3 are constants, and q3(t) and q4(t)
 * vary diurnally. The problem is posed on the square
 *   0 <= x <= 20,    30 <= y <= 50   (all in km),
 * with homogeneous Neumann boundary conditions, and for time t in
 *   0 <= t <= 86400 sec (1 day).
 * The PDE system is treated by central differences on a uniform
 * 10 x 10 mesh, with simple polynomial initial profiles.
 * The problem is solved with CVODE, with the BDF/GMRES
 * method (i.e. using the CVSPGMR linear solver) and a banded
 * preconditioner, generated by difference quotients, using the
 * module CVBANDPRE. The problem is solved with left and right
 * preconditioning.
 * -----------------------------------------------------------------
 */

public class JVodeIterativeTest
{
    /* Problem Constants */
    public static final int NUM_SPECIES = 2; /* number of species         */
    public static final double KH = 4.0e-6; /* horizontal diffusivity Kh */
    public static final double VEL = 0.001; /* advection velocity V      */
    public static final double KV0 = 1.0e-8; /* coefficient in Kv(y)      */
    public static final double Q1 = 1.63e-16; /* coefficients q1, q2, c3   */
    public static final double Q2 = 4.66e-16;
    public static final double C3 = 3.7e16;
    public static final double A3 = 22.62; /* coefficient in expression for q3(t) */
    public static final double A4 = 7.601; /* coefficient in expression for q4(t) */
    public static final double C1_SCALE = 1.0e6; /* coefficients in initial profiles    */
    public static final double C2_SCALE = 1.0e12;

    public static final double T0 = 0; /* initial time */
    public static final int NOUT = 12; /* number of output times */
    public static final double TWOHR = 7200.0; /* number of seconds in two hours  */
    public static final double HALFDAY = 4.32e4; /* number of seconds in a half day */
    public static final double PI = 3.1415926535898; /* pi */

    public static final double XMIN = 0; /* grid boundaries in x  */
    public static final double XMAX = 20.0;
    public static final double YMIN = 30.0; /* grid boundaries in y  */
    public static final double YMAX = 50.0;
    public static final double XMID = 10.0; /* grid midpoints in x,y */
    public static final double YMID = 40.0;

    public static final int MX = 10; /* MX = number of x mesh points */
    public static final int MY = 10; /* MY = number of y mesh points */
    public static final int NSMX = 20; /* NSMX = NUM_SPECIES*MX */
    public static final int MM = ( MX * MY ); /* MM = MX*MY */

    /* CVodeInit Constants */

    public static final double RTOL = 1.0e-5; /* scalar relative tolerance */
    public static final double FLOOR = 100.0; /* value of C1 or C2 at which tolerances */
    /* change from relative to absolute      */
    public static final double ATOL = RTOL * FLOOR; /* scalar absolute tolerance */
    public static final int NEQ = NUM_SPECIES * MM; /* NEQ = number of equations */

    /* User-defined vector and matrix accessor macros: IJKth, IJth */

    /* IJKth is defined in order to isolate the translation from the
       mathematical 3-dimensional structure of the dependent variable vector
       to the underlying 1-dimensional storage. IJth is defined in order to
       write code which indexes into small dense matrices with a (row,column)
       pair, where 1 <= row, column <= NUM_SPECIES.
       
       IJKth(vdata,i,j,k) references the element in the vdata array for
       species i at mesh point (j,k), where 1 <= i <= NUM_SPECIES,
       0 <= j <= MX-1, 0 <= k <= MY-1. The vdata array is obtained via
       the macro call vdata = NV_DATA_S(v), where v is an N_Vector.
       For each mesh point (j,k), the elements for species i and i+1 are
       contiguous within vdata.
    */
    public static double getIJKth(double[] vdata, int i, int j, int k)
    {
        return vdata[i - 1 + ( j ) * NUM_SPECIES + ( k ) * NSMX];
    }
    public static void setIJKth(double[] vdata, int i, int j, int k, double val)
    {
        vdata[i - 1 + ( j ) * NUM_SPECIES + ( k ) * NSMX] = val;
    }

    private static String path = "C://iterat2.txt";

    private static BufferedWriter bw;

    public static void main(String[] args) throws Exception
    {
        File file = new File(path);
        FileWriter fw = new FileWriter(file);
        bw = new BufferedWriter(fw);
        test();
        bw.close();
    }

    public static void test() throws Exception
    {
        Function f = new Function();
        printIntro(2, 2);

        bw.write("\n\nPreconditioner type is:  jpre = left\n\n");

        JVodeSpgmr solver = new JVodeSpgmr(Method.BDF, f, f.getInitialValues(), 0, JVodeSpgmr.PREC_LEFT, 0);
        solver.setTolerances(RTOL, ATOL);
        solver.setBandPreconditioner(NEQ, 2, 2);

        double tout = TWOHR;
        for( int iout = 1; iout <= NOUT; iout++, tout += TWOHR )
        {
            solver.start(tout);
            double[] u = solver.getY();
            printOutput(solver, u);
        }

        printFinalStats(solver);

        bw.write("\n\n-------------------------------------------------------------------\n");
        bw.write("\n\nPreconditioner type is:  jpre = right\n\n");

        solver = new JVodeSpgmr(Method.BDF, f, f.getInitialValues(), 0, JVodeSpgmr.PREC_RIGHT, 0);
        solver.setTolerances(RTOL, ATOL);
        solver.setBandPreconditioner(NEQ, 2, 2);

        /* In loop over output points, call CVode, print results, test for error */
        tout = TWOHR;
        for( int iout = 1; iout <= NOUT; iout++, tout += TWOHR )
        {
            solver.start(tout);
            double[] u = solver.getY();
            printOutput(solver, u);
        }

        /* Print final statistics */
        printFinalStats(solver);
    }

    static void printIntro(int mu, int ml) throws Exception
    {
        bw.write("2-species diurnal advection-diffusion problem, " + MX + " by " + MY + " mesh\n");
        bw.write("SPGMR solver; band preconditioner; mu = " + mu + ", ml = " + ml + "\n\n");
        return;
    }

    /* Print current t, step count, order, stepsize, and sampled c1,c2 values */

    static void printOutput(IterativeSolver solver, double[] u) throws Exception
    {
        int mxh = MX / 2 - 1, myh = MY / 2 - 1, mx1 = MX - 1, my1 = MY - 1;
        bw.write("t = " + solver.getTime() + "   no. steps = " + solver.nSteps + "   order = " + solver.qu + "   stepsize = " + solver.hu
                + "\n");
        bw.write("c1 (bot.left/middle/top rt.) = " + getIJKth(u, 1, 0, 0) + "  " + getIJKth(u, 1, mxh, myh) + "  "
                + getIJKth(u, 1, mx1, my1) + "\n");
        bw.write("c2 (bot.left/middle/top rt.) = " + getIJKth(u, 2, 0, 0) + "  " + getIJKth(u, 2, mxh, myh) + "  "
                + getIJKth(u, 2, mx1, my1) + "\n");
    }

    /* Get and print final statistics */
    static void printFinalStats(IterativeSolver solver) throws Exception
    {
        int nfeBP = ( (BandPrecondition)solver.getPrecondition() ).getNumRhsEvals();
        int nfetot = solver.nFCalls + solver.s_nfes + nfeBP;
        bw.write("\nFinal Statistics.. \n\n");
        bw.write("nst     = " + solver.nSteps + "\n");
        bw.write("nfe     = " + solver.nFCalls + "     nfetot  = " + nfetot + "\n");
        bw.write("nfeLS   = " + solver.s_nfes + "     nfeBP   = " + nfeBP + "\n");
        bw.write("nni     = " + solver.nNewtonIter + "     nli     = " + solver.s_nli + "\n");
        bw.write("nsetups = " + solver.nSetupCalls + "     netf    = " + solver.nTestFails + "\n");
        bw.write("npe     = " + solver.s_npe + "     nps     = " + solver.s_nps + "\n");
        bw.write("ncfn    = " + solver.nCorrFails + "     ncfl    = " + solver.s_ncfl + "\n\n");
    }

    /*
     *-------------------------------
     * Function called by the solver
     *-------------------------------
     */

    /* f routine. Compute f(t,u). */
    public static class Function extends JavaBaseModel
    {

        double om = PI / HALFDAY;
        double dx = ( XMAX - XMIN ) / ( MX - 1 );
        double dy = ( YMAX - YMIN ) / ( MY - 1 );
        double hdco = KH / ( dx * dx );
        double haco = VEL / ( 2 * dx );
        double vdco = ( 1.0 / ( dy * dy ) ) * KV0;
        double q4;

        @Override
        public double[] dy_dt(double t, double[] u)
        {
            double q3, c1, c2, c1dn, c2dn, c1up, c2up, c1lt, c2lt;
            double c1rt, c2rt, cydn, cyup, hord1, hord2, horad1, horad2;
            double qq1, qq2, qq3, qq4, rkin1, rkin2, s, vertd1, vertd2, ydn, yup;

            int idn, iup, ileft, iright, jx, jy;

            double[] du = new double[u.length];

            /* Set diurnal rate coefficients. */
            s = Math.sin(om * t);
            if( s > 0 )
            {
                q3 = Math.exp( -A3 / s);
                q4 = Math.exp( -A4 / s);
            }
            else
            {
                q3 = 0;
                q4 = 0;
            }

            /* Make local copies of problem variables, for efficiency. */

            for( jy = 0; jy < MY; jy++ )
            {

                /* Set vertical diffusion coefficients at jy +- 1/2 */
                ydn = YMIN + ( jy - 0.5 ) * dy;
                yup = ydn + dy;
                cydn = vdco * Math.exp(0.2 * ydn);
                cyup = vdco * Math.exp(0.2 * yup);
                idn = ( jy == 0 ) ? 1 : -1;
                iup = ( jy == MY - 1 ) ? -1 : 1;
                for( jx = 0; jx < MX; jx++ )
                {

                    /* Extract c1 and c2, and set kinetic rate terms. */
                    c1 = getIJKth(u, 1, jx, jy);
                    c2 = getIJKth(u, 2, jx, jy);
                    qq1 = Q1 * c1 * C3;
                    qq2 = Q2 * c1 * c2;
                    qq3 = q3 * C3;
                    qq4 = q4 * c2;
                    rkin1 = -qq1 - qq2 + 2 * qq3 + qq4;
                    rkin2 = qq1 - qq2 - qq4;

                    /* Set vertical diffusion terms. */
                    c1dn = getIJKth(u, 1, jx, jy + idn);
                    c2dn = getIJKth(u, 2, jx, jy + idn);
                    c1up = getIJKth(u, 1, jx, jy + iup);
                    c2up = getIJKth(u, 2, jx, jy + iup);
                    vertd1 = cyup * ( c1up - c1 ) - cydn * ( c1 - c1dn );
                    vertd2 = cyup * ( c2up - c2 ) - cydn * ( c2 - c2dn );

                    /* Set horizontal diffusion and advection terms. */
                    ileft = ( jx == 0 ) ? 1 : -1;
                    iright = ( jx == MX - 1 ) ? -1 : 1;
                    c1lt = getIJKth(u, 1, jx + ileft, jy);
                    c2lt = getIJKth(u, 2, jx + ileft, jy);
                    c1rt = getIJKth(u, 1, jx + iright, jy);
                    c2rt = getIJKth(u, 2, jx + iright, jy);
                    hord1 = hdco * ( c1rt - 2 * c1 + c1lt );
                    hord2 = hdco * ( c2rt - 2 * c2 + c2lt );
                    horad1 = haco * ( c1rt - c1lt );
                    horad2 = haco * ( c2rt - c2lt );

                    /* Load all terms into udot. */
                    setIJKth(du, 1, jx, jy, vertd1 + hord1 + horad1 + rkin1);
                    setIJKth(du, 2, jx, jy, vertd2 + hord2 + horad2 + rkin2);
                }
            }

            return du;
        }

        @Override
        public void init()
        {
            // TODO Auto-generated method stub
        }

        @Override
        public double[] getInitialValues()
        {
            int jx, jy;
            double x, y, cx, cy;

            double[] u = new double[NEQ];
            /* Load initial profiles of c1 and c2 into u vector */

            for( jy = 0; jy < MY; jy++ )
            {
                y = YMIN + jy * dy;
                cy = ( 0.1 ) * ( y - YMID );
                cy *= cy;
                cy = 1 - cy + 0.5 * cy * cy;
                for( jx = 0; jx < MX; jx++ )
                {
                    x = XMIN + jx * dx;
                    cx = 0.1 * ( x - XMID );
                    cx *= cx;
                    cx = 1 - cx + 0.5 * cx * cx;
                    setIJKth(u, 1, jx, jy, C1_SCALE * cx * cy);
                    setIJKth(u, 2, jx, jy, C2_SCALE * cx * cy);
                }
            }
            return u;
        }
    }
}
##Initializing
#if (!$engine) ##when using template from info tab we do not have engine yet
	#set ($engine = $sew.prepareEngine($de))
#end
#set ($diagram = $engine.getDiagram())
#set ($model = $diagram.getRole())
#set ($dimension = $engine.getRateEquationNumber())
#set ($variables = $model.getVariables())
#set ($maxCodeSize = 60000)
#set ($br = "
")
#set ($spaces = "    ")
#set ($spaces2 = "${spaces}${spaces}")
#set ($newLine = "${br}${spaces}")
#set ($quote= '"')

#set ($zVariables = $engine.generateUniqueLocalVariable("z"))

/*
 * This code is generated by BioUML FrameWork
 * for $model.getDiagramElement().getName() diagram  at $creationTime
 */
import biouml.plugins.simulation.ae.AeSolver;
import biouml.plugins.simulation.java.JavaLargeModel;
import ru.biosoft.math.MathRoutines;
import java.util.Map;

#set ($className = "$engine.normalize($model.getDiagramElement().getName())")
public class $className extends JavaLargeModel
{

#set( $staticInits = $sew.createStringBuilder() )

#set( $counter = 0)
#foreach( $v in $variables )
#if (!$engine.isArrayModeVariable($v) && !$v.getName().equals("time"))
    #set($counter = $counter + 1)
#end
#end

    public $className()
    {
        var = new double[$counter];
    }

    public double[] getY()
    {
        return x_values;
    }
##
###########################################Create Scalar Methods########################################################################
##
#set ($calculateParametersMethod = $sew.createStringBuilder())## Declaration of calculateScalar method
#set ($calculateReactionRatesMethod = $sew.createStringBuilder())## Declaration of calculateInternalScalar method
#set ($scalarEq = $model.getOrderedScalarEquations())
#set($nbytes = 0)
#set ($rrIndicator = 0)
#set($nbytes1 = 0)
#set ($cpIndicator = 0)
##$calculateReactionRatesMethod.append($spaces)
#foreach ($seq in $scalarEq)
##
#if ($sew.isEQUATION_TYPE_SCALAR_INTERNAL($seq.getType()))
##########################################Scalar internal Equations#########################################
#set ($statementWithDeclaration = $engine.formatMath($seq.getFormula(), $seq))
#if ($calculateReactionRatesMethod.length() > 0)
#set ($calculateReactionRatesMethod = $calculateReactionRatesMethod.append("${newLine}${spaces}"))
#end
#set($math = $seq.getMath())
#set($varName = $seq.getVariable())
#set ($eqBytes = $sew.estimateByteCodeLength($math, 3) + $sew.estimateVariableByteCodeLength($varName) + 3)
#set($nbytes = $nbytes + $eqBytes)
#if ($nbytes + 4 > $maxCodeSize)
#set($nbytes = $eqBytes)
#set ($rrIndicator = $rrIndicator + 1)
#set ($calculateReactionRatesMethod = $calculateReactionRatesMethod.append("}${newLine}}"))
#set ($calculateReactionRatesMethod = $calculateReactionRatesMethod.append("${br}${newLine}static class CalculateReactionRates_$rrIndicator${newLine}{"))
#set ($calculateReactionRatesMethod = $calculateReactionRatesMethod.append("${newLine}${spaces}public static void run(double[] x_values, double[] var, double time)${newLine}${spaces}{${newLine}${spaces}"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateReactionRates_$rrIndicator" ).append( ".class.getName();" ) )
#end
#if ($statementWithDeclaration.get(0) != "")
#set ($calculateReactionRatesMethod = $calculateReactionRatesMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}"))
#end
#set ($calculateReactionRatesMethod = $calculateReactionRatesMethod.append("${spaces}$engine.getVariableCodeName($varName) = $statementWithDeclaration.get(1); // $nbytes"))
##
#elseif ($sew.isEQUATION_TYPE_SCALAR($seq.getType()) || $sew.isEQUATION_TYPE_SCALAR_DELAYED($seq.getType()))
##########################################Scalar Equations#########################################
#set ($statementWithDeclaration = $engine.formatMath($seq.getFormula(), $seq))
#if ($calculateParametersMethod.length() > 0)
#set ($calculateParametersMethod = $calculateParametersMethod.append("${newLine}${spaces}"))
#end
#set($math = $seq.getMath())
#set($varName = $seq.getVariable())
#set ($eqBytes1 = $sew.estimateByteCodeLength($math, 3) + $sew.estimateVariableByteCodeLength($varName) + 3)
#set($nbytes1 = $nbytes1 + $eqBytes1)
#if ($nbytes1 + 4 > $maxCodeSize)
#set($nbytes1 = $eqBytes1)
#set ($cpIndicator = $cpIndicator + 1)
#set ($calculateParametersMethod = $calculateParametersMethod.append("}${newLine}}"))
#set ($calculateParametersMethod = $calculateParametersMethod.append("${br}${newLine}static class CalculateParameters_$cpIndicator${newLine}{"))
#set ($calculateParametersMethod = $calculateParametersMethod.append("${newLine}${spaces}public static void run(double[] x_values, double[] var, double time)${newLine}${spaces}{${newLine}${spaces}"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateParameters_$cpIndicator" ).append( ".class.getName();" ) )
#end
#if ($statementWithDeclaration.get(0) != "")
#set ($calculateParametersMethod = $calculateParametersMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}"))
#end
#set ($calculateParametersMethod = $calculateParametersMethod.append("${spaces}$engine.getVariableCodeName($varName) = $statementWithDeclaration.get(1); // $nbytes1"))
#end
##end of: if ($sew.isEQUATION_TYPE_SCALAR_INTERNAL($seq.getType()))
#end
##########################################Initial Values#########################################
#set ($calculateInitialParametersMethod = $sew.createStringBuilder())
#set ($ipIndicator = 0)
#set ($nbytes2 = 0)
#set ($eqBytes = 0)
#foreach ($eq in $model.getOrderedInitialEquations())
#if ($calculateInitialParametersMethod.length() > 0)
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${newLine}${spaces}"))
#end
#set($math = $eq.getMath())
#set($varName = $eq.getVariable())
#set ($eqBytes = $sew.estimateByteCodeLength($math, 3) + $sew.estimateVariableByteCodeLength($varName) + 3)
#set($nbytes2 = $nbytes2 + $eqBytes)
#if ($nbytes2 + 4 > $maxCodeSize)
#set($nbytes2 = $eqBytes)
#set ($ipIndicator = $ipIndicator + 1)
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("}${newLine}}"))
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${br}${newLine}class CalculateInitialParameters_$ipIndicator${newLine}{"))
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${newLine}${spaces}public void run(double[] x_values, double[] var, double time)${newLine}${spaces}{${newLine}${spaces}"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateInitialParameters_$ipIndicator" ).append( ".class.getName();" ) )
#end
#set ($statementWithDeclaration = $engine.formatMath($eq.getFormula(), $eq))
#if ($statementWithDeclaration.get(0) != "")
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}"))
#end
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${spaces}$engine.getVariableCodeName($varName) = $statementWithDeclaration.get(1); // $nbytes2"))
#end
############################################Create Calculate Algebraic Methods########################################################################
##
#set ($algebraicMethodCall = "")## Calling of caluclateAlgebraic method
#if ($sew.isOfType($engine.getModelType(), $sew.getEMODEL_ALGEBRAIC_TYPE()))
#set ($algebraicBeginMethods = $sew.createStringBuilder())
#set ($algebraicEndMethods = $sew.createStringBuilder())
#set ($solveAlgebraicMethods = $sew.createStringBuilder())
#set ($fillAlgebraicResult = $sew.createStringBuilder())
#set ($algebraicBeginMethodsCall = "")
#set ($algebraicEndMethodsCall = "")
#set ($solveAlgebraicMethodsCall = "")
#set ($fillAlgebraicResultCall = "")
#set ($size = 0)
#set ($indicator = 0)
#set ($nbytes = 0)
#foreach ($v in $variables)
#if ($engine.isAlgebraic($v.getName()))
#set ($varName = $v.getName())
#set ($nbytes = $nbytes+8+$sew.estimateVariableByteCodeLength($varName)+3)
#if ($nbytes > $maxCodeSize)
#set ($nbytes = 8+$sew.estimateVariableByteCodeLength($varName)+3)
#set ($indicator = $indicator + 1)
#set ($algebraicBeginMethods = $algebraicBeginMethods.append("${newLine}${spaces}}${newLine}}"))
#set ($algebraicBeginMethods = $algebraicBeginMethods.append("${br}${newLine}class AlgebraicBegin_$indicator${newLine}{"))
#set ($algebraicBeginMethods = $algebraicBeginMethods.append("${newLine}${spaces}public void run(double[] algebraicResult)${newLine}${spaces}{"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}AlgebraicBegin_$indicator" ).append( ".class.getName();" ) )
#set ($algebraicEndMethods = $algebraicEndMethods.append("${newLine}${spaces}}${newLine}}"))
#set ($algebraicEndMethods = $algebraicEndMethods.append("${br}${newLine}class AlgebraicEnd_$indicator${newLine}{"))
#set ($algebraicEndMethods = $algebraicEndMethods.append("${newLine}${spaces}public void run(double[] algebraicResult)${newLine}${spaces}{"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}AlgebraicEnd_$indicator" ).append( ".class.getName();" ) )
#set ($solveAlgebraicMethods = $solveAlgebraicMethods.append("${newLine}${spaces}}${newLine}}"))
#set ($solveAlgebraicMethods = $solveAlgebraicMethods.append("${br}${newLine}class SolveAlgebraic_$indicator${newLine}{"))
#set ($solveAlgebraicMethods = $solveAlgebraicMethods.append("${newLine}${spaces}public void run(double[] $zVariables)${newLine}${spaces}{"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}SolveAlgebraic_$indicator" ).append( ".class.getName();" ) )
#end
#set ($algebraicBeginMethods = $algebraicBeginMethods.append("${newLine}${spaces2}algebraicResult[$size] = $engine.getVariableCodeName($varName); // $nbytes"))
#set ($algebraicEndMethods = $algebraicEndMethods.append("${newLine}${spaces2}$engine.getVariableCodeName($varName) = algebraicResult[$size]; // $nbytes"))
#set ($solveAlgebraicMethods = $solveAlgebraicMethods.append("${newLine}${spaces2}$engine.getVariableCodeName($varName) = $zVariables[$size]; // $nbytes"))
#set ($size = $size + 1)
#end
#end
#set ($counter = 0)
#set ($nbytes = 0)
#set ($anotherIndicator = 0)
#set ($algebraic = $model.getAlgebraic().toList())
#foreach ($eq in $algebraic)
#set ($formula = $engine.formatMath($eq.getFormula(), $eq))
#set ($statement = $formula.get(1))
#set ($math = $eq.getMath())
#set ($nbytes = $nbytes + $sew.estimateByteCodeLength($math, 3)+7)
#if ($nbytes + 4 > $maxCodeSize)
#set ($nbytes = $sew.estimateByteCodeLength($math, 3)+7)
#set ($anotherIndicator = $anotherIndicator + 1)
#set ($fillAlgebraicResult = $fillAlgebraicResult.append("${newLine}${spaces}}${newLine}}"))
#set ($fillAlgebraicResult = $fillAlgebraicResult.append("${br}${newLine}class FillAlgebraicResult_$anotherIndicator${newLine}{"))
#set ($fillAlgebraicResult = $fillAlgebraicResult.append("${newLine}${spaces}public void run(double[] result)${newLine}${spaces}{"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}FillAlgebraicResult_$anotherIndicator" ).append( ".class.getName();" ) )
#end
#if ($formula.get(0) != "")
#set ($fillAlgebraicResult = $fillAlgebraicResult.append("${newLine}${spaces2}$formula.get(0); // $nbytes"))
#end   
#set ($fillAlgebraicResult = $fillAlgebraicResult.append("${newLine}${spaces2}result[$counter] = $statement; // $nbytes"))
#set ($counter = $counter + 1)
#end
#if ( $size != 0)
#set ($algebraicBeginMethodsCall = "calculateAlgebraicBegin(initialGuess);")
#set ($algebraicEndMethodsCall = "calculateAlgebraicEnd(result);")
#set ($solveAlgebraicMethodsCall = "preprocessSolveAlgebraic($zVariables);")
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}AlgebraicBegin.class.getName();" ) )
    class AlgebraicBegin
    {
        public void run(double[] algebraicResult)
        {   $algebraicBeginMethods
        }
    }
$br
    private void calculateAlgebraicBegin(double[] algebraicResult)
    {
        (new AlgebraicBegin()).run(algebraicResult);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        (new AlgebraicBegin_${n}()).run(algebraicResult);
#end
#end
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}AlgebraicEnd.class.getName();" ) )
    class AlgebraicEnd
    {
        public void run(double[] algebraicResult)
        {   $algebraicEndMethods
        }
    }
$br
    private void calculateAlgebraicEnd(double[] algebraicResult)
    {
        (new AlgebraicEnd()).run(algebraicResult);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        (new AlgebraicEnd_${n}()).run(algebraicResult);
#end
#end
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}SolveAlgebraic.class.getName();" ) )
    class SolveAlgebraic
    {
        public void run(double[] $zVariables)
        {   $solveAlgebraicMethods
        }
    }
$br
    private void preprocessSolveAlgebraic(double[] z)
    {
        (new SolveAlgebraic()).run(z);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        (new SolveAlgebraic_${n}()).run(z);
#end
#end
    }
#if ($counter > 0)
#set ($fillAlgebraicResultCall = "fillResult(result);")
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}FillAlgebraicResult.class.getName();" ) )
    class FillAlgebraicResult
    {
        public void run(double[] result)
        {   $fillAlgebraicResult
        }
    }
$br
    private void fillResult(double[] result)
    {
        (new FillAlgebraicResult()).run(result);
#if($anotherIndicator > 0)
#foreach( $n in [1..$anotherIndicator] )
        (new FillAlgebraicResult_${n}()).run(result);
#end
#end
    }
#end
#set ( $algebraicMethodCall = "calculateAlgebraic();")
$br
    private void calculateAlgebraic()  throws Exception
    {
        double [] initialGuess = new double [$size];
        $algebraicBeginMethodsCall
        double[] result = aeSolver.solve(initialGuess, this);
        $algebraicEndMethodsCall
    }
$br
    public double[] solveAlgebraic(double[] $zVariables)
    {
        $solveAlgebraicMethodsCall
        final double [] result = new double [$algebraic.size()];
        $fillAlgebraicResultCall
        return result;
    }
#end
#end
## end of: if ($sew.isOfType($engine.getModelType(), $sew.getEMODEL_ALGEBRAIC_TYPE()))
##
##############################################Create parameters calculation body###############################################################
##
#if ($calculateParametersMethod.length() > 0)
#set ($calculateParametersCall = "calculateParameters();")
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateParameters.class.getName();" ) )
    static class CalculateParameters
    {
        public static void run(double[] x_values, double[] var, double time)
        {
        $calculateParametersMethod
        }
    }
$br
    private void calculateParameters() throws Exception
    {
#if($algebraicMethodCall!="")
        $algebraicMethodCall
#end
        CalculateParameters.run(x_values, var, time);
#if($cpIndicator > 0)
#foreach($n in [1..$cpIndicator] )
        CalculateParameters_${n}.run(x_values, var, time);
#end
#end
    }
#elseif ($size != 0)
#set ($calculateParametersCall = "calculateAlgebraic();")

#end
#if ($calculateReactionRatesMethod.length() > 0)
#set ($calculateReactionRatesCall = "calculateReactionRates();")
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateReactionRates.class.getName();" ) )
    static class CalculateReactionRates
    {
        public static void run(double[] x_values, double[] var, double time)
        {
        $calculateReactionRatesMethod
        }
    }
$br
    private void calculateReactionRates()
    {
        CalculateReactionRates.run(x_values, var, time);
#if($rrIndicator > 0)
#foreach( $n in [1..$rrIndicator] )
        CalculateReactionRates_${n}.run(x_values, var, time);
#end
#end
    }
#end
#if ($calculateInitialParametersMethod.length() > 0)
#set ($calculateInitialParametersCall = "calculateInitialParameters();")
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateInitialParameters.class.getName();" ) )
    class CalculateInitialParameters
    {
        public void run(double[] x_values, double[] var, double time)
        {
        $calculateInitialParametersMethod
        }
    }
$br
    private void calculateInitialParameters()
    {
        (new CalculateInitialParameters()).run(x_values, var, time);
#if($ipIndicator > 0)
#foreach( $n in [1..$ipIndicator] )
        (new CalculateInitialParameters_${n}()).run(x_values, var, time);
#end
#end
    }
$br
#end
##
##############################################Create Functions###############################################################
##
#set ($functions = $model.getFunctions())
#foreach ($f in $functions)
#set ($math = $engine.formatMath($f.getFormula(), $f, $engine.getFunctionDeclarationASTVisitors()))
#set ($functionBody = $engine.createFunctionBody($math.get(0) , $math.get(1)))
$functionBody
#end

#if (!$sew.isOfType($engine.getModelType(),$sew.getEMODEL_ODE_TYPE()))
##
###########################################Model is static######################################
##
$br
    public double[] getTimes()
    {
        return new double[] { $engine.getInitialTime() };
    }

    public double[] getResults(double time) throws Exception
    {
        this.time = time;
        return extendResult($engine.getInitialTime(), getInitialValues());
    }

    public boolean isStatic()
    {
        return true;
    }

#else ## if model not static then dy_dt method should present
##
###########################################Create dy_dt Method######################################
##
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}Dy_dt.class.getName();" ) )
    static class Dy_dt
    {
        public static void run(double[] dydt, double[] var, double[] x_values, double time)
        {
#set ($nbytes = 0)
#set ($indicator = 0)
#foreach( $v in $variables )
#set($prevnbytes = $nbytes)
#if ( $engine.isArrayModeVariable($v) )
#set($rightSide = "")
#set($equations = $engine.getDefiningEquations($v.getName()))
#foreach( $eq in  $equations )
#if ($sew.isRate($eq))
#set ($statementWithDeclaration = $engine.formatMath($eq.getFormula(), $eq))
#if ($statementWithDeclaration.get(0)!="")
      $statementWithDeclaration.get(0)
#end
#if( $statementWithDeclaration.get(1).charAt(0) != "-")
#set($rightSide = "${rightSide}+")
#set($nbytes = $nbytes + 1)
#end
#set($rightSide = "${rightSide}$statementWithDeclaration.get(1)")
#end
#set($math = $eq.getMath())
#set($nbytes = $nbytes + $sew.estimateByteCodeLength($math, 3))
#end
#set($nbytes = $nbytes + 3 + $sew.estimateConstantByteCodeLength($engine.getVariableRateIndex($v.getName())))
#if ($nbytes + 8 > $maxCodeSize)
#set($nbytes = $nbytes - $prevnbytes)
#set($indicator = $indicator + 1)
        }
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}Dy_dt_$indicator" ).append( ".class.getName();" ) )
    static class Dy_dt_$indicator
    {
        public static void run(double[] dydt, double[] var, double[] x_values, double time)
        {
#end
            dydt[$engine.getVariableRateIndex($v.getName())] = $rightSide; //$nbytes
#end
#end
        }
    }
$br
    public double[] dy_dt_slow(double time, double[] x_values) throws Exception
    {
        this.time = time;
        this.x_values = x_values;
        final double[] dydt = new double[$dimension];
#if ($calculateParametersMethod.length() > 0 || $algebraicMethodCall!="")
        $calculateParametersCall
#end
#if ($calculateReactionRatesMethod.length() > 0)
        $calculateReactionRatesCall
#end

        Dy_dt.run(dydt, var, x_values, time);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        Dy_dt_${n}.run(dydt, var, x_values, time);
#end
#end
        return dydt;
    }

##
###########################################Create dy_dt Method for FAST reactions only!######################################
##
#if ( $sew.hasFastReactions() )
    public boolean hasFastOde()
    {
        return true;
    }
#set( $staticInits = $staticInits.append( "${newLine}${spaces}Dy_dt_fast.class.getName();" ) )
    class Dy_dt_fast
    {
        public void run(double[] dydt)
        {
#set ($nbytes = 0)
#set ($indicator = 0)
#foreach( $v in $variables )
 #set($prevnbytes = $nbytes)
 #if ( $engine.isArrayModeVariable($v) )
  #set($rightSide = "")
  #set($equations = $engine.getDefiningEquations($v.getName()))
  #foreach( $eq in  $equations )
   #if ($sew.isRate($eq) && $sew.isFast($eq))
    #set ($statementWithDeclaration = $engine.formatMath($eq.getFormula(), $eq))
    #if ($statementWithDeclaration.get(0)!="")
      $statementWithDeclaration.get(0)
    #end
    #if ($statementWithDeclaration.get(1)!="")
     #if( $statementWithDeclaration.get(1).charAt(0) != "-")
      #set($rightSide = "${rightSide}+")
     #end
     #set($nbytes = $nbytes + 1)
     #set($rightSide = "${rightSide}$statementWithDeclaration.get(1)")
    #end
   #end
   #set($math = $eq.getMath())
   //"RS: "$rightSide.isEmpty()
   #if (!($rightSide.isEmpty()))
    #set($nbytes = $nbytes + $sew.estimateByteCodeLength($math, 3))
    #set($nbytes = $nbytes + 3 + $sew.estimateConstantByteCodeLength($engine.getVariableRateIndex($v.getName())))
    #if ($nbytes + 8 > $maxCodeSize)
     #set($nbytes = $nbytes - $prevnbytes)
     #set($indicator = $indicator + 1)
        }
    }
$br
     #set( $staticInits = $staticInits.append( "${newLine}${spaces}Dy_dt_$indicator" ).append( ".class.getName();" ) )
    class Dy_dt_fast$indicator
    {
        public void run(double[] dydt)
        {
    #end
            dydt[$engine.getVariableRateIndex($v.getName())] = $rightSide; //$nbytes
   #end
  #end
 #end
#end
        }
    }
$br
    public double[] dy_dt_fast(double time, double[] x_values) throws Exception
    {
        this.time = time;
        this.x_values = x_values;
        final double[] dydt = new double[$dimension];
#if ($calculateParametersMethod.length() > 0 || $algebraicMethodCall!="")
        $calculateParametersCall
#end
#if ($calculateReactionRatesMethod.length() > 0)
        $calculateReactionRatesCall
#end

        new Dy_dt_fast().run(dydt);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        new Dy_dt_fast_${n}().run(dydt);
#end
#end
        return dydt;
    }
#end
#end
##
#############################################Model initialization###########################################################
##
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}Init.class.getName();" ) )
    private static class Init
    {
        public static void run(double[] var)
        {
#set ($nbytes = 0)
#set($indicator = 0)
#foreach( $v in $variables )
#if ( !$engine.isArrayModeVariable($v) && !$engine.isTemp($v))
#set($varName = $v.getName())
#set($varBytes = $sew.estimateVariableByteCodeLength($varName) + 7)
#set ($nbytes = $nbytes + $varBytes)
#if ($nbytes + 25 > $maxCodeSize)
#set ($nbytes = $varBytes)
#set($indicator = $indicator + 1)
        }
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}Init_$indicator" ).append( ".class.getName();" ) )
    private static class Init_$indicator
    {
        public static void run(double[] var)
        {
#end
#set($varName = $engine.getVariableCodeName($varName))
#if($varName != "time")
            $varName = $sew.getCode($v.getInitialValue()); // initial value of $v.getName(); bytes = $nbytes
#end
#end
#end
        }
    }
$br
    public void init() throws Exception
    {
        CONSTRAINTS__VIOLATED = 0;
        Init.run(var);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        Init_${n}.run(var);
#end
#end
        calculateInitialValues();
        this.time = 0;
        this.isInit = true;
    }
$br
    @Override
    public void init(double[] initialValues, Map<String, Double> parameters) throws Exception
    {
        super.init(initialValues, parameters);
###########################Consider initial assignments###############################
#if ($calculateInitialParametersMethod.length() > 0)
        $calculateInitialParametersCall
#end
############################Algebraic rules calculation######################
#if ($algebraicMethodCall != "")
        $algebraicMethodCall
#end
        this.initialValues = x_values.clone();
    }
##
##
###########################Create calculateInitialValues method#################################
##
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}GetInitialValues.class.getName();" ) )
    private static class GetInitialValues
    {
        public static void run(double[] x_values)
        {
###########################Array variables initial values###########################
#set ($nbytes = 0)
#set($indicator = 0)
#set( $ind = 0 )
#foreach( $v in $variables )
#if( $engine.isArrayModeVariable($v) )
#set ($initialValue = $v.getInitialValue())
#if ($initialValue != "0.0")
#set ($nbytes = $nbytes+8+$sew.estimateConstantByteCodeLength($ind))
#if ($nbytes > $maxCodeSize)
#set ($nbytes = 8+$sew.estimateConstantByteCodeLength($ind))
#set($indicator = $indicator + 1)
        }
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}GetInitialValues_$indicator" ).append( ".class.getName();" ) )
    private static class GetInitialValues_$indicator
    {
        public static void run(double[] x_values)
        {
#end
            x_values[$ind] = $initialValue;   //$nbytes
#end
#set( $ind = $ind + 1 )
#end
#end
        }
    }
$br
    private final void calculateInitialValues() throws Exception
    {
        this.x_values = new double[$dimension];
        this.time = $engine.getInitialTime();
        GetInitialValues.run(this.x_values);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        GetInitialValues_${n}.run(this.x_values);
#end
#end
###########################Consider initial assignments###############################
#if ($calculateInitialParametersMethod.length() > 0)
        $calculateInitialParametersCall
#end
############################Algebraic rules calculation######################
#if ($algebraicMethodCall != "")
        $algebraicMethodCall
#end
        this.initialValues = x_values;
    }

##
###########################################Create Extend Result Methods#############################################################
##
$br
    public double[] extendResult(double time, double[] x_values) throws Exception
    {
        this.time = time;
        this.x_values = x_values;
#if ( $calculateParametersMethod.length() > 0 || $algebraicMethodCall!="" )
        $calculateParametersCall
#end
        return getCurrentState();
    }
##
###########################################Create get Current State Methods#############################################################
##
$br
    public double[] getCurrentState()
    {
#set ($nbytes = 17)
#set($indicator=1)
#set ($y = $engine.generateUniqueLocalVariable("y"))
        double[] $y = new double[$engine.getVarIndexMapping().size()];
#foreach ($v in $variables)
#if ($engine.isSignificant($v))
#set ($rightSide = $engine.getVariableCodeName($v.getName()))
#if ($rightSide)
#set ($nbytes = $nbytes + $sew.estimateVariableByteCodeLength($v.getName()) + 8)
####################Transform to concentration units if needed##################
#if( $sew.isOutputConcentration($v) )
#set ( $compartmentRole = $sew.getCompartmentVariable($v) )
#if($compartmentRole)
#set ( $rightSide= "${rightSide}/$engine.getVariableCodeName($compartmentRole.getName())" )
## Use is made of specific digit (10) to estimate right side byte code length, because math parser fails during parsing expressions which
## contains array variables. As soon as only aditional part of right side should be estimated ($v byte code length was estimated just above):
## estimateByteCodeLength("/variableCodeName(compartmentRoleName)") <= BYTE_CODE_PER_EMBEDDED_OPERATION + BYTE_CODE_PER_ARRAY_VARIABLE + BYTE_CODE_PER_INTEGER(<= 3) < 10
#set ($nbytes = $nbytes + 10)
#end
#end
#set ($index = $engine.getVarIndexMapping().get($v.getName()))
#if ($nbytes + 9 > $maxCodeSize)
#set ($nbytes = $sew.estimateVariableByteCodeLength($v.getName()) + 18)
        return getCurrentState_$indicator(time, x_values, y);
    }
$br
    public double[] getCurrentState_$indicator(double time, double[] x_values, double[] y)
    {
#set ($indicator=$indicator+1)
#end
        $y[$index] = ${rightSide};    // $nbytes
#end
#end
#end
        return $y;
    }
##
##########################################Create Set Current Values Methods#############################################################
##
##TODO: rework with StringBuilder
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}SetCurrentValues_0.class.getName();" ) )
    private static class SetCurrentValues_0
    {
        public static void set(double[] x_values, double[] var, double[] values, double time)
        {
#set ( $nbytes = 17 )
#set ( $indicator=0 )
#foreach ($v in $variables)
#if ($engine.isSignificant($v))
#set ($index = $engine.getVarIndexMapping().get($v.getName()))
#set ($varCodeName = $engine.getVariableCodeName($v.getName()))
#set ($bytes = $sew.estimateVariableByteCodeLength($v.getName()) + $sew.estimateConstantByteCodeLength($index) + 8)
#set ($nbytes = $nbytes + $bytes)
#if ($nbytes > $maxCodeSize)
#set($nbytes = 17)
#set($indicator = $indicator+1)
        }
    }$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}SetCurrentValues_$indicator" ).append( ".class.getName();" ) )
    private static class SetCurrentValues_$indicator
    {
        public static void set(double[] x_values, double[] var, double[] values, double time)
        {
#end

#set ($rightSide = "values[${index}]")
####################Transform to amount units if needed##################
#if( $sew.isOutputConcentration($v))
#set ( $compartmentRole = $sew.getCompartmentVariable($v ))
#if($compartmentRole)
#set ( $rightSide= "${rightSide}*$engine.getVariableCodeName($compartmentRole.getName())")
#end
#end
            $varCodeName = $rightSide;//$nbytes
#end
#end
        }
    }$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}SetCurrentInitialValues_0.class.getName();" ) )
    private static class SetCurrentInitialValues_0
    {
        public static void set(double[] initialValues, double[] values, double time)
        {
#set ( $nbytes = 17 )
#set ( $indicatorInit=0 )
#foreach ($v in $variables)
#if ( $engine.isArrayModeVariable($v) )
#set ( $rateIndex = $engine.getVariableRateIndex( $v.getName() ) )
#set ( $globalIndex = $engine.getVarIndexMapping().get( $v.getName() ) )
#set ( $bytes = $sew.estimateConstantByteCodeLength($rateIndex) + $sew.estimateConstantByteCodeLength($globalIndex) + 13 )
#set ($nbytes = $nbytes + $bytes)
#if ($nbytes > $maxCodeSize)
#set($nbytes = 17)
#set($indicatorInit = $indicatorInit+1)
        }
    }$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}SetCurrentInitialValues_$indicatorInit" ).append( "class.getName();" ) )
    private static class SetCurrentInitialValues_$indicatorInit
    {
        public static void set(double[] initialValues, double[] values, double time)
        {
#end
            initialValues[$rateIndex] = values[$globalIndex]; //$nbytes
#end
#end
        }
    }$br
    @Override
    public final void setCurrentValues(double[] values) throws Exception
    {
        CONSTRAINTS__VIOLATED = 0;
        SetCurrentValues_0.set(x_values, var, values, time);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        SetCurrentValues_${n}.set(x_values, var, values, time);
#end
#end
        if ( time == 0 )
        {
            SetCurrentInitialValues_0.set(initialValues, values, time);
#if($indicatorInit > 0)
#foreach( $n in [1..$indicatorInit] )
            SetCurrentInitialValues_${n}.set(initialValues, values, time);
#end
#end
#if ($calculateInitialParametersMethod!="")
            $calculateInitialParametersCall
#end
        }
#if ( $calculateParametersMethod.length() > 0 || $algebraicMethodCall!="" )
        else
            $calculateParametersCall
#end
    }
##
########################################Event Temp Variables Declaration################################################################
##
#if ($sew.isOfType($engine.getModelType(), $sew.getEMODEL_EVENT_TYPE()) || $sew.isOfType($engine.getModelType(), $sew.getEMODEL_STATE_TRANSITION_TYPE()))
$br
#set ( $events = $model.getEvents() )
#set ( $evNumber = $events.size() )
##
########################################Create Check Event Method######################################################################
##
$br
    public double[] checkEvent(double time, double[] x_values) throws Exception
    {
        this.time = time;
        this.x_values = x_values;
#if ( $calculateParametersMethod.length() > 0 || $algebraicMethodCall!="" )
        $calculateParametersCall
#end
#set ( $result = $engine.generateUniqueLocalVariable("z") )
        double[] $result  = new double[$evNumber];
#set ($index = 0)
#foreach ( $ev in $events )
#set ($trigger = "")
#if ($ev.getDelay() != "0")
#set ( $trigger = "this.time >= getNextExecutionTime(${index})" )
#end
#if ( $ev.getDelay() == "0" || !$ev.isTriggerPersistent() )
#set ( $statementWithDeclaration = $engine.formatMath($ev.getTrigger(), $ev) )
#if ( $statementWithDeclaration.get(0)!="" )
        $statementWithDeclaration.get(0)
#end
#if ($trigger != "")
#set ($trigger = "$trigger && ")
#end
#set ( $trigger = "${trigger}$statementWithDeclaration.get(1)" )
#end
        $result[$index] = ($trigger) ? 1 : -1; // $ev.getDiagramElement().getTitle();
#set ( $index = $index + 1 )
#end
        return $result;
    }
##
######################################Create Process Event Method###########################################################
##
#set ( $eventIndex = $engine.generateUniqueLocalVariable("i") )
#set ( $assignments = $engine.generateUniqueLocalVariable("assignments") )
#set ( $executionTime = $engine.generateUniqueLocalVariable("executionTime") )
#set ( $processEventMethod = $sew.createStringBuilder() )
#set ( $counter = 0 )
#set ( $processInd = 0 )
$br
    public void processEvent(int $eventIndex)
    {
        double[] $assignments = null;
        double $executionTime;
        switch ( $eventIndex )
        {
#foreach ( $ev in $events )
#if ( $counter > 0 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
            case ( $counter ): //$ev.getDiagramElement().getTitle()
            {
#if ($sew.isTerminal($ev))
                 CONSTRAINTS__VIOLATED = 1;
                 break;
            }
#set ( $counter = $counter + 1 )
#else
#set ( $nbytes = 0 )
#if ( $sew.isDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
#set ( $assignmentIndex = 0 )
                $assignments = getNextAssignments($counter);
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $rightSide = "$assignments[$assignmentIndex]*$engine.formatMath($sa.getMath(), $ev).get(1);" )
#set ( $mathBytes = 8 + $sew.estimateVariableByteCodeLength($sa.getVariable()) + 3 )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$engine.getVariableCodeName($sa.getVariable()) = $rightSide; //$nbytes${newLine}${spaces}") )
#set ( $assignmentIndex = $assignmentIndex + 1)
#end
#else
#if ( $sew.isTriggerForDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
                $assignments = new double[$ev.getEventAssignment().size() - 1];
#end
#set ( $assignmentIndex = 0 )
#if( !$sew.isTriggerForDelayedEvent($ev) && !$ev.isUseValuesFromTriggerTime() )
                $assignments = new double[$ev.getEventAssignment().size()];
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $leftSide = "$assignments[$assignmentIndex]" )
#set ( $math = $engine.getMath($sa.getMath(), $ev) )
#set ( $statementWithDeclaration = $engine.formatMath($math) )
#set ($mathBytes = $sew.estimateByteCodeLength($math, 8) )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#if ( $statementWithDeclaration.get(0) != "" )
#set ( $processEventMethod = $processEventMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}") )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$leftSide = $statementWithDeclaration.get(1); //$nbytes${newLine}${spaces}") )
#set ( $assignmentIndex = $assignmentIndex + 1 )
#end
#set ( $assignmentIndex = 0 )
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $rightSide = "$assignments[$assignmentIndex]" )
#set ( $mathBytes = 8 + $sew.estimateVariableByteCodeLength($sa.getVariable()) + 3 )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$engine.getVariableCodeName($sa.getVariable()) = $rightSide; //$nbytes${newLine}${spaces}") )
#set ( $assignmentIndex = $assignmentIndex + 1 )
#end
#else
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $math = $engine.getMath($sa.getMath(), $ev) )
#set ( $statementWithDeclaration = $engine.formatMath($math) )
#set ( $leftSide = "" )
#if ( $sew.isTriggerForDelayedEvent($ev) )
#if ( $assignmentIndex == 0)
#if ( $statementWithDeclaration.get(0) != "" )
                $statementWithDeclaration.get(0)
#end
                $executionTime = $statementWithDeclaration.get(1);
#else
#set ( $leftSide = "$assignments[$assignmentIndex - 1]" )
#end
#set ( $assignmentIndex = $assignmentIndex + 1)
#else
#set ( $leftSide = "$engine.getVariableCodeName($sa.getVariable())" )
#end
#if ( $leftSide != "" )
#set ($mathBytes = $sew.estimateByteCodeLength($math, 3) + 7 )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#if ( $statementWithDeclaration.get(0) != "" )
#set ( $processEventMethod = $processEventMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}") )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$leftSide = $statementWithDeclaration.get(1); //$nbytes${newLine}${spaces}") )
#end
#end
#end
#end
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#if ( $sew.isDelayedEvent($ev) )
                removeDelayedEvent($counter);
#elseif ( $sew.isTriggerForDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
                addDelayedEvent($counter + 1, $executionTime, $assignments);
#elseif ( $sew.isTriggerForDelayedEvent($ev) )
                addDelayedEvent($counter + 1, $executionTime, null);
#end
                break;
            }
#set ( $counter = $counter + 1 )
#end
#end
            default:
                break;
        }
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_0.class.getName();" ) )
    class ProcessEvent_0
    {
        public void run(double[] $assignments)
        {
        $processEventMethod}
    }
## end of process event method
##
########################################Create Event Priority Method######################################################################
##
##
$br
    public double[] getEventsPriority(double time, double[] x_values) throws Exception
    {
        double[] priority = new double[$evNumber];
#if ( $calculateParametersMethod.length() > 0 || $algebraicMethodCall!="" )
        $calculateParametersCall
#end
#set ($priorities = "")
#set ($preparation = "")
#foreach ($ev in $events)
#if (!$ev.getPriority() )
#set($priorities = "${priorities}${newLine}${spaces2}Double.NEGATIVE_INFINITY, //$ev.getDiagramElement().getTitle()")
#else
#set ($math = $engine.formatMath($ev.getPriority(), $ev))
#if ($math.get(1).isEmpty())
#set($priorities = "${priorities}${newLine}${spaces2}Double.NEGATIVE_INFINITY, //$ev.getDiagramElement().getTitle()")
#else
#if ( $math.get(0)!="" )
#set($preparation = "${preparation}${newLine}${spaces}$math.get(0)")
#end
#set($priorities = "${priorities}${newLine}${spaces}$math.get(1), //$ev.getDiagramElement().getTitle()")
#end
#end
#end
#set ($priorities = "${spaces2}return new double[] {${priorities}${newLine}${spaces}};")
#if(!$preparation.isEmpty())
$preparation
#end
$priorities
    }
##
########################################Create Event Trigger Initial Value Method######################################################################
##
##
$br
    public boolean getEventsInitialValue(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($result = $ev.isTriggerInitialValue())
#if ( $result == "false" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces}")
#end
#set ($counter = $counter + 1)
#end
#if ( $methodBody != "" )
#set ($methodBody = "${methodBody}${spaces}return false;${br}${spaces2}${spaces}")
#set ($methodBody = "${methodBody}default:${br}${spaces2}${spaces2}return true;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return true;
#end
    }
##
##
########################################Create Event Trigger Persistent Method######################################################################
##
##
$br
    public boolean isEventTriggerPersistent(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($result = $ev.isTriggerPersistent())
#if ( $result == "false" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces}")
#end
#set ($counter = $counter + 1)
#end
#if ($methodBody != "")
#set ($methodBody = "${methodBody}${spaces}return false;${br}${spaces2}${spaces}")
#set ($methodBody = "${methodBody}default:${br}${spaces2}${spaces2}return true;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return true;
#end
    }
##
##
##
########################################Create Event Message Method######################################################################
##
##
$br
    public final String getEventMessage(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($message = $ev.getTriggerMessage())
#if ( $message != "" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces2}return ${quote}${message}${quote};")
#end
#set ($counter = $counter + 1)
#end
#if ($methodBody != "")
#set ($methodBody = "${methodBody}${br}${spaces2}${spaces}default:${br}${spaces2}${spaces2}return null;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return null;
#end
    }
#end
##end of event methods
##
#############################################History methods########################################
##
#if ($engine.containsDelays())
$br
    public double getPrehistory(double time, int i)
    {
        switch (i)
        {
#foreach ($v in $engine.getVarNameHistoryIndexMapping().keySet())
            case $engine.getVarNameHistoryIndexMapping().get($v):
            {
#set( $variable = $model.getVariable($v) )
#if ( $variable.getAttributes().getValue("isRate") == true )
               return 0;
            }  
#else
#set( $hasEquation = false )
#set ($equations = $engine.getDefiningEquations($v))
#foreach ($eq in $equations)
#if ( $sew.isScalar($eq) )
#set ($rightSide = $engine.formatMath($eq.getFormula(), $eq, $engine.getPrehistoryASTVisitors()).get(1))
#set ($hasEquation = true )
#end
#end
#if (!$hasEquation)
#set ($rightSide = $model.getVariable($v).getInitialValue())
#end
                return $rightSide;
            }
#end
#end
        }
        return 0;
    }
$br
    public double[] getCurrentHistory()
    {
#set ($historyVars = $engine.generateUniqueLocalVariable("z"))
        double[] $historyVars  = new double[$engine.getHistoricalVariableNumber()];
#foreach ($v in $engine.getVarNameHistoryIndexMapping().keySet())
#set ($indexInHistory = $engine.getVarNameHistoryIndexMapping().get($v))
        $historyVars[$indexInHistory] = $engine.getVariableCodeName($v);
#end
        return $historyVars;
    }
#end
##end of history methods

#if( $staticInits.length() > 0 )
    static
    {$staticInits
    }
#end
}

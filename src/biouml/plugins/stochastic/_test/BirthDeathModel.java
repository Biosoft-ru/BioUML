package biouml.plugins.stochastic._test;

/*
 * This code is generated by BioUML FrameWork
 * for dsmts-001-01.xml diagram  at 2011.12.15 10:55:15
 */
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import biouml.plugins.stochastic.StochasticModel;
public class BirthDeathModel extends StochasticModel
{
    protected double Cell;
    protected double Mu;
    protected double Lambda;
    @Override
    public void doReaction(int i, double[] x_values, double k)
    {
        switch( i )
        {
           case 1 : //reaction $$rate_Birth
            {
                x_values[ 0 ] -=  1 * k;
                x_values[ 0 ] +=  2 * k;
                break;
            }
           case 0 : //reaction $$rate_Death
            {
                x_values[ 0 ] -=  1 * k;
                break;
            }
        }
    }
    @Override
    public Set<Integer> getIndexesOfSubstrate(int i)
    {
        Set<Integer> result = new HashSet<>();
        switch( i )
        {
            case 1 : //reaction $$rate_Birth
            {
                result.add( 0 );
                result.add( 0 );
                break;
            }
            case 0 : //reaction $$rate_Death
            {
                result.add( 0 );
                break;
            }
        }
        return result;
    }
    @Override
    public void updatePropensities(double[] propensities, int i, double[] x_values)
    {
        switch( i )
        {
            case 1 :   //reaction $$rate_Birth
            {
                propensities[1] = Lambda*x_values[0];
                propensities[0] = Mu*x_values[0];
                break;
            }
            case 0 :   //reaction $$rate_Death
            {
                propensities[1] = Lambda*x_values[0];
                propensities[0] = Mu*x_values[0];
                break;
            }
        }
    }
    @Override
    public double[] getPropensities(double[] x_values)
    {
        final double[] propensities = new double[2];
        propensities[1] = Lambda*x_values[0];
        propensities[0] = Mu*x_values[0];
        return propensities;
    }
    @Override
    public void init()
    {
        Cell = 1.0; // initial value of $Cell
        Mu = 0.11; // initial value of Mu
        Lambda = 0.1; // initial value of Lambda
        time = 0.0; // initial value of time
        getInitialValues();
    }
    @Override
    public double[] getInitialValues()
    {
        double[] x_values = new double[1];
        this.time = 0.0;
        x_values[0] = 100.0 ; //  initial value of $Cell.X
        return x_values;
    }
    @Override
    public double[] extendResult(double time, double[] x_values)
    {
        this.time = time;
        double[] yv0 = new double[7];
        yv0[0] = Cell;
        yv0[1] = Mu;
        yv0[2] = Lambda;
        yv0[4] = x_values[0];
        yv0[5] = time;
        return yv0;
    }
    @Override
    public void init(double[] initialValues, Map<String, Double> parameters)
    {
    }
    @Override
    public Map<Integer, Integer>[] getProductStochiometry()
    {
        // TODO Auto-generated method stub
        return null;
    }
    @Override
    public Map<Integer, Integer>[] getReactantStochiometry()
    {
        // TODO Auto-generated method stub
        return null;
    }
}

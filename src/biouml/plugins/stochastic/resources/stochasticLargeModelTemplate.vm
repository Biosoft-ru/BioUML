#set ($maxCodeSize = 60000)
##Initializing
#if (!$engine) ##when using template from info tab we do not have engine yet
	#set ($engine = $sew.prepareEngine($de))
#end
#set ($diagram = $engine.getDiagram())
#set ($model = $diagram.getRole())
#set ($dimension = $engine.getRateEquationNumber())
#set ($variables = $model.getVariables())
#set ($scalarEquations = $model.getOrderedScalarEquations())
#set ($equations = $model.getEquations().toList())
#set ($br = "
")
#set ($reactionIndexMapping = $engine.getReactionNameIndexMapping())
#set ($spaces = "    ")
#set ($spaces2 = "${spaces}${spaces}")
#set ($newLine = "${br}${spaces}")
#set ($quote= '"')
/*
 * This code is generated by BioUML FrameWork
 * for $model.getDiagramElement().getName() diagram  at $creationTime
 */
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import biouml.plugins.stochastic.StochasticModel;
import ru.biosoft.math.MathRoutines;

public class $engine.normalize($model.getDiagramElement().getName()) extends StochasticModel
{
#set( $staticInits = $sew.createStringBuilder() )
#set( $counter = 0)
#foreach( $v in $variables )
#if (!$engine.isArrayModeVariable($v) && !$sew.isInternal($v) && !$v.getName().equals("time"))
    #set($counter = $counter + 1)
#end
#end
    public double[] var = new double[$counter];

##########################################Initial Values#########################################
#set ($calculateInitialParametersMethod = $sew.createStringBuilder())
#set ($ipIndicator = 0)
#set ($nbytes2 = 0)
#set ($eqBytes = 0)
#foreach ($eq in $model.getOrderedInitialEquations())
#if ($calculateInitialParametersMethod.length() > 0)
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${newLine}${spaces}"))
#end
#set($math = $eq.getMath())
#set($varName = $eq.getVariable())
#set ($eqBytes = $sew.estimateByteCodeLength($math, 3) + $sew.estimateVariableByteCodeLength($varName) + 3)
#set($nbytes2 = $nbytes2 + $eqBytes)
#if ($nbytes2 + 4 > $maxCodeSize)
#set($nbytes2 = $eqBytes)
#set ($ipIndicator = $ipIndicator + 1)
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("}${newLine}}"))
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${br}${newLine}class CalculateInitialParameters_$ipIndicator${newLine}{"))
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${newLine}${spaces}public void run()${newLine}${spaces}{${newLine}${spaces}"))
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateInitialParameters_$ipIndicator" ).append( ".class.getName();" ) )
#end
#set ($statementWithDeclaration = $engine.formatMath($eq.getFormula(), $eq))
#if ($statementWithDeclaration.get(0) && $statementWithDeclaration.get(0) != "")
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}"))
#end
#set ($calculateInitialParametersMethod = $calculateInitialParametersMethod.append("${spaces}$engine.getVariableCodeName($varName) = $statementWithDeclaration.get(1); // $nbytes2"))
#end

#if ($calculateInitialParametersMethod.length() > 0)
#set ($calculateInitialParametersCall = "calculateInitialParameters();")
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateInitialParameters.class.getName();" ) )
    class CalculateInitialParameters
    {
        public void run()
        {
        $calculateInitialParametersMethod
        }
    }$br
    private void calculateInitialParameters()
    {
        (new CalculateInitialParameters()).run();
#if($ipIndicator > 0)
#foreach( $n in [1..$ipIndicator] )
        (new CalculateInitialParameters_${n}()).run();
#end
#end
    }
$br
#end
## 
###########################################Create Scalar Methods########################################################################
##
#set ($calculateParametersMethod = $sew.createStringBuilder())## Declaration of calculateScalar method
#set ($calculateParametersCall = "")##Calling of caluclateScalar method
#set ($nbytes = 0)
#set ($cpIndicator = 0)
#foreach ($seq in $scalarEquations)
#if ( !$sew.isEQUATION_TYPE_SCALAR_INTERNAL($seq.getType()))
#if ($calculateParametersMethod.length() > 0)
#set ($calculateParametersMethod = $calculateParametersMethod.append("${newLine}${spaces}"))
#end
#set ( $math = $seq.getMath() )
#set ( $varName = $seq.getVariable() )
#set ($eqBytes1 = $sew.estimateByteCodeLength($math, 3) + $sew.estimateVariableByteCodeLength($varName) + 3)
#set ( $nbytes = $nbytes + $eqBytes1 )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $eqBytes1 )
#set ($cpIndicator = $cpIndicator + 1)
#set ($calculateParametersMethod = $calculateParametersMethod.append("}${newLine}}"))
#set ($calculateParametersMethod = $calculateParametersMethod.append("${br}${newLine}class CalculateParameters_$cpIndicator${newLine}{"))
#set ($calculateParametersMethod = $calculateParametersMethod.append("${newLine}${spaces}public void run(double[] x_values)${newLine}${spaces}{${newLine}${spaces}"))
#set ( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateParameters_$cpIndicator" ).append( ".class.getName();" ) )
#end
#set ( $statementWithDeclaration = $engine.formatMath($seq.getFormula(), $seq) )
#if ($statementWithDeclaration.get(0) && $statementWithDeclaration.get(0) != "")
#set ($calculateParametersMethod = $calculateParametersMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}"))
#end
#set ($calculateParametersMethod = $calculateParametersMethod.append("${spaces}$engine.getVariableCodeName($varName) = $statementWithDeclaration.get(1); // $nbytes"))
#end
#end

#if ($calculateParametersMethod.length() > 0)
#set ($calculateParametersCall = "calculateParameters(x_values);")
#set( $staticInits = $staticInits.append( "${newLine}${spaces}CalculateParameters.class.getName();" ) )
    class CalculateParameters
    {
        public void run(double[] x_values)
        {
        $calculateParametersMethod
        }
    }$br
    private void calculateParameters(double[] x_values)
    {
        (new CalculateParameters()).run(x_values);
#if($cpIndicator > 0)
#foreach($n in [1..$cpIndicator] )
        (new CalculateParameters_${n}()).run(x_values);
#end
#end
    }
#end

##
#############################################Do Reaction Method#############################################################
##
#set ( $doReactIndex = 0 )
    @Override
    public void doReaction(int i, double[] x_values, double k)
    {
        switch( i )
        {
#set ( $nbytes = 0 )
#foreach ( $rEntry in $reactionIndexMapping.entrySet() )
            case $rEntry.getValue() : //reaction $rEntry.getKey()
            {
#set ( $reactionEdges = $engine.getReactionNode($rEntry.getKey()).getEdges() )
#foreach ( $edge in $reactionEdges )
#if ( $sew.isSpecieReference($edge) )
#set ( $sr = $edge.getKernel() )
#if ($sr.isProduct() || $sr.isReactant())
#if  ( $sr.isReactant() )
#set ( $node = $edge.getInput() )
#set ( $operation = "-=")
#elseif( $sr.isProduct() )
#set ( $node = $edge.getOutput() )
#set ( $operation = "+=")
#end
#set ( $value = $sr.getStoichiometry() )
#if ( $value == "1" )
#set ( $value = "k" )
#else
#set ( $value = $value + " * k" )
#end
#if ($sew.isVariable($node))
#set($varName = $node.getRole().getName())
#set ( $leftSide = "x_values[ $engine.getVariableRateIndex( $varName ) ]" )
#if ( $engine.isArrayModeVariable($model.getVariable($varName)))
#set ( $eqBytes = 27 )## (BYTE_CODE_PER_ARRAY_VARIABLE + 3)*2 + BYTE_CODE_PER_CONST + BYTE_CODE_PER_CALL + BYTE_CODE_PER_VARIABLE + 3
#set ( $nbytes = $nbytes + $eqBytes )
#if ( $nbytes + 4 > $maxCodeSize )
                doReaction_${doReactIndex}(i, x_values, k);
                break;
            }
            default:
                doReaction_${doReactIndex}(i, x_values, k);
                break;
        }
    }
    private void doReaction_${doReactIndex}(int i, double[] x_values, double k)
    {
        switch( i )
        {
            case $rEntry.getValue() : //reaction $rEntry.getKey()
            {
#set ( $nbytes = $eqBytes )
#set ( $doReactIndex = $doReactIndex + 1 )
#end
                $leftSide $operation $value; // $nbytes
#end
#end
#end
#end
#end
                break;
            }
#end
        }
    }

##
#############################################Get Indexes of Substrate Method#############################################################
## 
#set ( $index = 0 )
    @Override
    public Set<Integer> getIndexesOfSubstrate(int i)
    {
        Set<Integer> result = new HashSet<Integer>();
   
        switch( i )
        {
#set ( $nbytes = 0 )
#foreach ( $rEntry in $reactionIndexMapping.entrySet() )
            case $rEntry.getValue() : //reaction $rEntry.getKey()
            {
#set ( $reactionEdges = $engine.getReactionNode($rEntry.getKey()).getEdges() )
#foreach ( $edge in $reactionEdges )
#if ( $sew.isSpecieReference($edge) && $edge.getKernel().isReactant() )
#set ( $node = $edge.getInput() )
#if ( $sew.isVariable($node) )
#set ( $varName = $node.getRole().getName() )
#if ( $engine.isArrayModeVariable($model.getVariable($varName)))
#set ( $line = "result.add( $engine.getVariableRateIndex( $varName ) )" )
#set ( $eqBytes = $sew.estimateByteCodeLength($line, 3) )
#set ( $nbytes = $nbytes + $eqBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $eqBytes )
                result = getIndexesOfSubstrate_${index}(i, result);
                break;
            }
            default:
                result = getIndexesOfSubstrate_${index}(i, result);
        }
        return result;
    }
    public Set<Integer> getIndexesOfSubstrate_${index}(int i, Set<Integer> result)
    {
        switch( i )
        {
            case $rEntry.getValue() : //reaction $rEntry.getKey()
            {
#set ( $index = $index + 1 )
#end
                ${line}; // $nbytes
#end
#end
#end
#end
                break;
            }
#end
        }
        return result;
    }
   
##
#############################################Update Propensities  Method#############################################################
##
    @Override
    public void updatePropensities(double[] propensities, int i, double[] x_values)
    {
        if( i < 0 )
            return;
#if ( $calculateParametersMethod.length() > 0 )
        $calculateParametersCall
#end
        if( this.reactionDependencies != null && i < this.reactionDependencies.length )
        {
            for( int j : this.reactionDependencies[i] )
                propensities[j] = updatePropensity(j, x_values);
        }
        else if( this.reactionDependencies == null )
        {
            for( int j = 0; j < $engine.getReactionNumber(); j++ )
                propensities[j] = updatePropensity(j, x_values);
        }
    }

#set ( $staticInits = $staticInits.append( "${newLine}${spaces}UpdatePropensity.class.getName();" ) )
    public double updatePropensity(int i, double[] x_values)
    {
        return (new UpdatePropensity()).run(i, x_values);
    }
    class UpdatePropensity
    {
        public double run(int i, double[] x_values)
        {
#set ( $index = 1 )
#set ( $nbytes = 0 )
#set ( $number = 1 )
            switch( i )
            {
#foreach ( $rEntry in $reactionIndexMapping.entrySet() )
#set ( $equation = $engine.getReactionNode($rEntry.getKey()).getRole() )
#set ( $f = $engine.formatMath( $equation.getFormula(), $equation ) )
#set ( $declaration = $f.get(0) )
#set ( $value = $f.get(1) )
#set ( $varBytes = 8 )## BYTE_CODE_PER_ARRAY_VARIABLE + 3
#set ( $eqBytes = $varBytes + $sew.estimateByteCodeLength( $equation.getMath(), $varBytes ) )
#set ( $nbytes = $nbytes + $eqBytes )
#if ( $nbytes + 12 + 8*$number > $maxCodeSize )
#set ( $nbytes = $eqBytes )
                default:
                    return run_${index}(i, x_values);
            }
        }
        public double run_${index}(int i, double[] x_values)
        {
            switch( i )
            {
#set ( $number = 1 )
#set( $index = $index + 1 )
#end
#set ( $number = $number + 1 )
                case $rEntry.getValue() : //reaction $rEntry.getKey()
#if ( $declaration && $declaration.length() > 0)
                    $decalaration
#end
                    return $value; // $nbytes
#end
                default:
                    throw new IllegalArgumentException("Cannot find reaction with number " + i + " in reaction index map.");
            }
        }
    }

##
#############################################Get Propensities  Method#############################################################
##
    @Override
    public double[] getPropensities(double[] x_values)
    {
#set ( $nbytes = 0 )
#set ( $callIndex = 0 )
        double[] propensities = new double[$engine.getReactionNumber()];
#if ( $calculateParametersMethod.length() > 0 )
        $calculateParametersCall
#end

        for( int i = 0; i < $engine.getReactionNumber(); i++ )
            propensities[i] = updatePropensity(i, x_values);
        return propensities;
    }
##
#############################################Model initialization###########################################################
##
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}Init.class.getName();" ) )
    private static class Init
    {
        public static void run($engine.normalize($model.getDiagramElement().getName()) _this)
        {
#set ($nbytes = 0)
#set($indicator = 0)
#foreach( $v in $variables )
#if ( !$engine.isArrayModeVariable($v) && !$engine.isTemp($v))
#set($varName = $v.getName())
#set($varBytes = $sew.estimateVariableByteCodeLength($varName) + 7)
#set ($nbytes = $nbytes + $varBytes)
#if ($nbytes + 25 > $maxCodeSize)
#set ($nbytes = $varBytes)
#set($indicator = $indicator + 1)
        }
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}Init_$indicator" ).append( ".class.getName();" ) )
    private static class Init_$indicator
    {
        public static void run($engine.normalize($model.getDiagramElement().getName()) _this)
        {
#end
            _this.$engine.getVariableCodeName($varName) = $sew.getCode($v.getInitialValue()); // initial value of $v.getName(); bytes = $nbytes
#end
#end
        }
    }
$br
    @Override
    public void init() throws Exception
    {
        Init.run(this);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
        Init_${n}.run(this);
#end
#end
        initialValues = getInitialValues();
        this.isInit = true;
    }
$br
    @Override
    public void init(double[] initialValues, Map<String, Double> parameters) throws Exception
    {
        super.init(initialValues, parameters);
###########################Consider initial assignments###############################
#if ($calculateInitialParametersMethod.length() > 0)
        $calculateInitialParametersCall
#end
        this.initialValues = x_values.clone();
    }
##
##
############################Create getInitialValues method#################################
##
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}GetInitialValues.class.getName();" ) )
    private static class GetInitialValues
    {
        public static void run(double[] x_values)
        {
###########################Array variables initial values###########################
#set ($nbytes = 0)
#set($indicator = 0)
#set( $ind = 0 )
#foreach( $v in $variables )
#if( $engine.isArrayModeVariable($v) )
#set ($initialValue = $v.getInitialValue())
#if ($initialValue != "0.0")
#set ($nbytes = $nbytes+8+$sew.estimateConstantByteCodeLength($ind))
#if ($nbytes > $maxCodeSize)
#set ($nbytes = 8+$sew.estimateConstantByteCodeLength($ind))
#set($indicator = $indicator + 1)
        }
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}GetInitialValues_$indicator" ).append( ".class.getName();" ) )
    private static class GetInitialValues_$indicator
    {
        public static void run(double[] x_values)
        {
#end
            x_values[$ind] = $initialValue;   //$nbytes
#end
#set( $ind = $ind + 1 )
#end
#end
        }
    }
$br
    @Override
    public double[] getInitialValues() throws Exception
    {
        if (!this.isInit)
        {
            this.x_values = new double[$dimension];
            this.time = $engine.getInitialTime();
            GetInitialValues.run(this.x_values);
#if($indicator > 0)
#foreach( $n in [1..$indicator] )
            GetInitialValues_${n}.run(this.x_values);
#end
#end
            return this.x_values;
        }
        else
            return initialValues;
    }  

##
###########################################Create Extend Result Methods#############################################################
##
$br
    @Override
    public double[] extendResult(double time, double[] x_values) throws Exception
    {
#set ($nbytes = 17)
#set($indicator=1)
        this.time = time;
        this.x_values = x_values;
#if ( $calculateParametersMethod.length() > 0 )
        $calculateParametersCall
#end
#set ($y = $engine.generateUniqueLocalVariable("y"))
        double[] $y = new double[$engine.getVarIndexMapping().size()];
#foreach ($v in $variables)
#if ($engine.isSignificant($v))
#set ($rightSide = $engine.getVariableCodeName($v.getName()))
#if ($rightSide)
#set ($nbytes = $nbytes + $sew.estimateVariableByteCodeLength($v.getName()) + 8)
####################Transform to concentration units if needed##################
#if( $sew.isInitialConcentration($v) )
#set ( $compartmentRole = $sew.getCompartmentVariable($v) )
#if($compartmentRole)
#set ( $rightSide= "${rightSide}/$engine.getVariableCodeName($compartmentRole.getName())" )
## Use is made of specific digit (10) to estimate right side byte code length, because math parser fails during parsing expressions which
## contains array variables. As soon as only aditional part of right side should be estimated ($v byte code length was estimated just above):
## estimateByteCodeLength("/variableCodeName(compartmentRoleName)") <= BYTE_CODE_PER_EMBEDDED_OPERATION + BYTE_CODE_PER_ARRAY_VARIABLE + BYTE_CODE_PER_INTEGER(<= 3) < 10
#set ($nbytes = $nbytes + 10)
#end
#end
#set ($index = $engine.getVarIndexMapping().get($v.getName()))
#if ($nbytes + 9 > $maxCodeSize)
#set ($nbytes = $sew.estimateVariableByteCodeLength($v.getName()) + 18)
        return extendResult_$indicator(time, x_values, y);
    }
$br
    public double[] extendResult_$indicator(double time, double[] x_values, double[] y) throws Exception
    {
#set ($indicator=$indicator+1)
#end
        $y[$index] = ${rightSide};    // $nbytes
#end
#end
#end
        return $y;
    }

#set ( $nbytesR = 0 )
#set ( $nbytesP = 0 )
#set ( $indexR = 0 )
#set ( $indexP = 0 )
#set ( $getReactStochMethod = $sew.createStringBuilder() )
#set ( $getProdStochMethod = $sew.createStringBuilder() )
#foreach ( $rEntry in $reactionIndexMapping.entrySet() )
#set ( $startExpr = "result[$rEntry.getValue()]=new HashMap <Integer,Integer>()" )## bytecode can be estimated by 12
#set ( $eqBytes = 12 )
#set ( $nbytesR = $nbytesR + $eqBytes )
#set ( $nbytesP = $nbytesP + $eqBytes )
#set ( $getReactStochMethod = $getReactStochMethod.append( "${newLine}${spaces2}$startExpr; // $nbytesR" ) )
#set ( $getProdStochMethod = $getProdStochMethod.append( "${newLine}${spaces2}$startExpr; // $nbytesP" ) )
#set ( $reactionEdges = $engine.getReactionNode($rEntry.getKey()).getEdges() )
#foreach ( $edge in $reactionEdges )
#if  ( $sew.isSpecieReference( $edge ) )
#set ( $sr = $edge.getKernel() )
#if  ( $sr.isReactant() )
#set ( $node = $edge.getInput() )
#if ( $sew.isVariable( $node ) )
#set ( $varName = $node.getRole().getName() )
#if ( $engine.isArrayModeVariable( $model.getVariable( $varName ) ) )
#set ( $line = "result[$rEntry.getValue()].put($engine.getVariableRateIndex( $varName ) , $sr.getStoichiometry())" )## bytecode can be estimated by 24
#set ( $eqBytes = 24 )
#set ( $nbytesR = $nbytesR + $eqBytes )
#if ( $nbytesR + 4 > $maxCodeSize )
#set ( $nbytesR = 0 )
#set ( $nbytesR = $eqBytes )
#set ( $getReactStochMethod = $getReactStochMethod.append( "${newLine}${spaces2}return run_$indexR(result);${newLine}${spaces}}" ) )
#set ( $getReactStochMethod = $getReactStochMethod.append( "${newLine}${spaces}private Map<Integer,Integer>[] run_$indexR(Map<Integer,Integer>[] result)${newLine}${spaces}{" ) )
#set ( $indexR = $indexR + 1 )
#end
#set ( $getReactStochMethod = $getReactStochMethod.append("${newLine}${spaces2}$line; // $nbytesR") )
#end
#end
#elseif ( $sr.isProduct() )
#set ( $node = $edge.getOutput() )
#if ( $sew.isVariable( $node ) )
#set ( $varName = $node.getRole().getName() )
#if ( $engine.isArrayModeVariable( $model.getVariable( $varName ) ) ) 
#set ( $line = "result[$rEntry.getValue()].put($engine.getVariableRateIndex( $varName ) , $sr.getStoichiometry())" )## bytecode can be estimated by 24
#set ( $eqBytes = 24 )
#set ( $nbytesP = $nbytesP + $eqBytes )
#if ( $nbytesP + 4 > $maxCodeSize )
#set ( $nbytesP = 0 )
#set ( $nbytesP = $eqBytes )
#set ( $getProdStochMethod = $getProdStochMethod.append( "${newLine}${spaces2}return run_${indexP}(result);${newLine}${spaces}}" ) )
#set ( $getProdStochMethod = $getProdStochMethod.append( "${newLine}${spaces}private Map<Integer,Integer>[] run_${indexP}(Map<Integer,Integer>[] result)${newLine}${spaces}{" ) )
#set ( $indexP = $indexP + 1 )
#end
#set ( $getProdStochMethod = $getProdStochMethod.append("${newLine}${spaces2}$line; // $nbytesP") )
#end
#end
#end
#end
#end
#end
    @Override
    public Map<Integer,Integer>[] getReactantStochiometry()
    {
        return (new GetReactantStoichiometry()).run();
    }
#set( $staticInits = $staticInits.append( "${newLine}${spaces}GetReactantStoichiometry" ).append( ".class.getName();" ) )
    public class GetReactantStoichiometry
    {
        public Map<Integer,Integer>[] run()
        {
            Map<Integer,Integer>[] result=new HashMap [$reactionIndexMapping.size()];
        $getReactStochMethod

            return result;
        }
    }

    @Override
    public Map<Integer,Integer>[] getProductStochiometry()
    {
        return (new GetProductStoichiometry()).run();
    }
#set( $staticInits = $staticInits.append( "${newLine}${spaces}GetProductStoichiometry" ).append( ".class.getName();" ) )
    public class GetProductStoichiometry
    {
        public Map<Integer,Integer>[] run()
        {
            Map<Integer,Integer>[] result=new HashMap [$reactionIndexMapping.size()];
        $getProdStochMethod

            return result;
        }
    }

########################################Event Temp Variables Declaration################################################################
##
#if ($sew.isOfType($engine.getModelType(), $sew.getEMODEL_EVENT_TYPE()) || $sew.isOfType($engine.getModelType(), $sew.getEMODEL_STATE_TRANSITION_TYPE()))
$br
#set ( $events = $model.getEvents() )
#set ( $evNumber = $events.size() )
##
########################################Create Check Event Method######################################################################
##
$br
    public double[] checkEvent(double time, double[] x_values) throws Exception
    {
        this.time = time;
        this.x_values = x_values;
#if ( $calculateParametersMethod.length() > 0 )
        $calculateParametersCall
#end
#set ( $result = $engine.generateUniqueLocalVariable("z") )
        double[] $result  = new double[$evNumber];
#set ($index = 0)
#foreach ( $ev in $events )
#set ($trigger = "")
#if ($ev.getDelay() != "0")
#set ( $trigger = "this.time >= getNextExecutionTime(${index})" )
#end
#if ( $ev.getDelay() == "0" || !$ev.isTriggerPersistent() )
#set ( $statementWithDeclaration = $engine.formatMath($ev.getTrigger(), $ev) )
#if ( $statementWithDeclaration.get(0)!="" )
        $statementWithDeclaration.get(0)
#end
#if ($trigger != "")
#set ($trigger = "$trigger && ")
#end
#set ( $trigger = "${trigger}$statementWithDeclaration.get(1)" )
#end
$result[$index] = ($trigger) ? 1 : -1; // $ev.getDiagramElement().getTitle();
#set ( $index = $index + 1 )
#end
        return $result;
    }
##
######################################Create Process Event Method###########################################################
##
#set ( $eventIndex = $engine.generateUniqueLocalVariable("i") )
#set ( $assignments = $engine.generateUniqueLocalVariable("assignments") )
#set ( $executionTime = $engine.generateUniqueLocalVariable("executionTime") )
#set ( $processEventMethod = $sew.createStringBuilder() )
#set ( $counter = 0 )
#set ( $processInd = 0 )
$br
    public void processEvent(int $eventIndex)
    {
        double[] $assignments = null;
        double $executionTime;
        switch ( $eventIndex )
        {
#foreach ( $ev in $events )
#if ( $counter > 0 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
            case ( $counter ): //$ev.getDiagramElement().getTitle()
            {
#set ( $nbytes = 0 )
#if ( $sew.isDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
#set ( $assignmentIndex = 0 )
                $assignments = getNextAssignments($counter);
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $rightSide = "$assignments[$assignmentIndex]" )
#set ( $mathBytes = 8 + $sew.estimateVariableByteCodeLength($sa.getVariable()) + 3 )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$engine.getVariableCodeName($sa.getVariable()) = $rightSide; //$nbytes${newLine}${spaces}") )
#set ( $assignmentIndex = $assignmentIndex + 1)
#end
#else
#if ( $sew.isTriggerForDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
                $assignments = new double[$ev.getEventAssignment().size() - 1];
#end
#set ( $assignmentIndex = 0 )
#if( !$sew.isTriggerForDelayedEvent($ev) && !$ev.isUseValuesFromTriggerTime() )
                $assignments = new double[$ev.getEventAssignment().size()];
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $leftSide = "$assignments[$assignmentIndex]" )
#set ( $math = $engine.getMath($sa.getMath(), $ev) )
#set ( $statementWithDeclaration = $engine.formatMath($math) )
#set ($mathBytes = $sew.estimateByteCodeLength($math, 8) )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#if ( $statementWithDeclaration.get(0) != "" )
#set ( $processEventMethod = $processEventMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}") )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$leftSide = $statementWithDeclaration.get(1); //$nbytes${newLine}${spaces}") )
#set ( $assignmentIndex = $assignmentIndex + 1 )
#end
#set ( $assignmentIndex = 0 )
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $rightSide = "$assignments[$assignmentIndex]" )
#set ( $mathBytes = 8 + $sew.estimateVariableByteCodeLength($sa.getVariable()) + 3 )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$engine.getVariableCodeName($sa.getVariable()) = $rightSide; //$nbytes${newLine}${spaces}") )
#set ( $assignmentIndex = $assignmentIndex + 1 )
#end
#else
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $math = $engine.getMath($sa.getMath(), $ev) )
#set ( $statementWithDeclaration = $engine.formatMath($math) )
#set ( $leftSide = "" )
#if ( $sew.isTriggerForDelayedEvent($ev) )
#if ( $assignmentIndex == 0)
#if ( $statementWithDeclaration.get(0) != "" )
                $statementWithDeclaration.get(0)
#end
                $executionTime = $statementWithDeclaration.get(1);
#else
#set ( $leftSide = "$assignments[$assignmentIndex - 1]" )
#end
#set ( $assignmentIndex = $assignmentIndex + 1)
#else
#set ( $leftSide = "$engine.getVariableCodeName($sa.getVariable())" )
#end
#if ( $leftSide != "" )
#set ($mathBytes = $sew.estimateByteCodeLength($math, 3) + 7 )
#set ( $nbytes = $nbytes + $mathBytes )
#if ( $nbytes + 4 > $maxCodeSize )
#set ( $nbytes = $mathBytes )
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#set ( $processEventMethod = $processEventMethod.append("}${newLine}}") )
#set ( $processEventMethod = $processEventMethod.append("${br}${newLine}class ProcessEvent_$processInd${newLine}{") )
#set ( $processEventMethod = $processEventMethod.append("${newLine}${spaces}public void run(double[] $assignments)${newLine}${spaces}{${newLine}${spaces}") )
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_$processInd" ).append( ".class.getName();" ) )
#end
#if ( $statementWithDeclaration.get(0) != "" )
#set ( $processEventMethod = $processEventMethod.append("${spaces}$statementWithDeclaration.get(0)${newLine}${spaces}") )
#end
#set ( $processEventMethod = $processEventMethod.append("${spaces}$leftSide = $statementWithDeclaration.get(1); //$nbytes${newLine}${spaces}") )
#end
#end
#end
#end
                (new ProcessEvent_${processInd}()).run($assignments);
#set ( $processInd = $processInd + 1 )
#if ( $sew.isDelayedEvent($ev) )
                removeDelayedEvent($counter);
#elseif ( $sew.isTriggerForDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
                addDelayedEvent($counter + 1, $executionTime, $assignments);
#elseif ( $sew.isTriggerForDelayedEvent($ev) )
                addDelayedEvent($counter + 1, $executionTime, null);
#end
                break;
            }
#set ( $counter = $counter + 1 )
#end
            default:
                break;
        }
    }
$br
#set( $staticInits = $staticInits.append( "${newLine}${spaces}ProcessEvent_0.class.getName();" ) )
    class ProcessEvent_0
    {
        public void run(double[] $assignments)
        {
        $processEventMethod}
    }
## end of process event method
##
########################################Create Event Priority Method######################################################################
##
##
$br
    public double[] getEventsPriority(double time, double[] x) throws Exception
    {
        double[] priority = new double[$evNumber];
#if ( $calculateParametersMethod.length() > 0 )
        $calculateParametersCall
#end
#set ($counter = 0)
#foreach ($ev in $events)
#if (!$ev.getPriority() )
        priority[$counter] = Double.NEGATIVE_INFINITY; //$ev.getDiagramElement().getTitle()
#else
#set ($statementWithDeclaration = $engine.formatMath($ev.getPriority(), $ev))
#if ($statementWithDeclaration.get(1).isEmpty())
        priority[$counter] = Double.NEGATIVE_INFINITY; //$ev.getDiagramElement().getTitle()
#else
        priority[$counter] = $statementWithDeclaration.get(1); //$ev.getDiagramElement().getTitle()
#end
#end
#set ($counter = $counter + 1)
#end
        return priority;
    }
##
########################################Create Event Trigger Initial Value Method######################################################################
##
##
$br
    public boolean getEventsInitialValue(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($result = $ev.isTriggerInitialValue())
#if ( $result == "false" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces}")
#end
#set ($counter = $counter + 1)
#end
#if ( $methodBody != "" )
#set ($methodBody = "${methodBody}${spaces}return false;${br}${spaces2}${spaces}")
#set ($methodBody = "${methodBody}default:${br}${spaces2}${spaces2}return true;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return true;
#end
    }
##
##
########################################Create Event Trigger Persistent Method######################################################################
##
##
$br
    public boolean isEventTriggerPersistent(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($result = $ev.isTriggerPersistent())
#if ( $result == "false" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces}")
#end
#set ($counter = $counter + 1)
#end
#if ($methodBody != "")
#set ($methodBody = "${methodBody}${spaces}return false;${br}${spaces2}${spaces}")
#set ($methodBody = "${methodBody}default:${br}${spaces2}${spaces2}return true;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return true;
#end
    }
#end
##end of event methods
##
#############################################History methods########################################
##
#if ($engine.containsDelays())
$br
    public double getPrehistory(double time, int i)
    {
        switch (i)
        {
#foreach ($v in $engine.getVarNameHistoryIndexMapping().keySet())
            case $engine.getVarNameHistoryIndexMapping().get($v):
            {
#set( $hasEquation = false )
#set ($equations = $engine.getDefiningEquations($v))
#foreach ($eq in $equations)
#if ( $sew.isScalar($eq) )
#set ($rightSide = $engine.formatMath($eq.getFormula(), $eq, $engine.getPrehistoryASTVisitors()).get(1))
#set ($hasEquation = true )
#end
#end
#if (!$hasEquation)
#set ($rightSide = $model.getVariable($v).getInitialValue())
#end
                return $rightSide;
            }
#end
        }
        return 0;
    }
$br
    public double[] getCurrentHistory()
    {
#set ($historyVars = $engine.generateUniqueLocalVariable("z"))
        double[] $historyVars  = new double[$engine.getHistoricalVariableNumber()];
#foreach ($v in $engine.getVarNameHistoryIndexMapping().keySet())
#set ($indexInHistory = $engine.getVarNameHistoryIndexMapping().get($v))
        $historyVars[$indexInHistory] = $engine.getVariableCodeName($v);
#end
        return $historyVars;
    }
#end
##end of history methods

##
##############################################Create Functions###############################################################
##
#set ($functions = $model.getFunctions())
#foreach ($f in $functions)
#set ($math = $engine.formatMath($f.getFormula(), $f, $engine.getFunctionDeclarationASTVisitors()))
#set ($functionBody = $engine.createFunctionBody($math.get(0) , $math.get(1)))
$functionBody
#end

#if( $staticInits.length() > 0 )
    static
    {$staticInits
    }
#end
}

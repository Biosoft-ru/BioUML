##Initializing
#if (!$engine) ##when using template from info tab we do not have engine yet
	#set ($engine = $sew.prepareEngine($de, "biouml.plugins.stochastic.StochasticSimulationEngine"))
#end
#set ($diagram = $engine.getDiagram())
#set ($model = $diagram.getRole())
#set ($dimension = $engine.getRateEquationNumber())
#set ($variables = $model.getVariables())
#set ($br = "
")
#set ($reactionIndexMapping = $engine.getReactionNameIndexMapping())
#set ($spaces = "    ")
#set ($spaces2 = "${spaces}${spaces}")
#set ($newLine = "${br}${spaces}")
#set ($newLine2 = "${newLine}${spaces}")
#set ($quote= '"')

#set ($zVariables = $engine.generateUniqueLocalVariable("z"))

/*
 * This code is generated by BioUML FrameWork
 * for $model.getDiagramElement().getName() diagram  at $creationTime
 */
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import biouml.plugins.stochastic.StochasticModel;
import biouml.plugins.simulation.ae.AeSolver;
import biouml.plugins.simulation.java.JavaBaseModel;
import ru.biosoft.math.MathRoutines;

public class $engine.normalize($model.getDiagramElement().getName()) extends StochasticModel
{

#foreach( $v in $variables )
#if (!$engine.isArrayModeVariable($v) && !$v.getName().equals("time"))
    public double $engine.getVariableCodeName($v.getName());
#end
#end

    public double getMolecules(String var)
    {
        switch(var)
        {
#foreach ($v in $variables)
#if ($engine.isValueTransformed($v))
            case "$v.getName()":
            {
                return $engine.getMolecules($v); 
            }
#end
#end
            default:
            {
                return 1.0;
            }
        }
    }
##
###########################################Create Scalar Methods########################################################################
##
#set ($calcParameters = "")## Declaration of calculateScalar method
#set ($scalarEq = $model.getOrderedScalarEquations())
#foreach ($seq in $scalarEq)
#if ($sew.isEQUATION_TYPE_SCALAR($seq.getType()) || $sew.isEQUATION_TYPE_SCALAR_DELAYED($seq.getType()))
##########################################Scalar Equations#########################################
#set ($math = $engine.formatMath($seq.getFormula(), $seq))
#if ($calcParameters != "")
#set ($calcParameters = "${calcParameters}${newLine2}")
#end
#if ($math.get(0) != "")
#set ($calcParameters = "${calcParameters}$math.get(0)${newLine}")
#end
#set ($calcParameters = "${calcParameters}$engine.getVariableCodeName($seq.getVariable()) = $math.get(1);")
#end
#end
##########################################Initial Values#########################################
#set ($calcInitial = "")
#foreach ($eq in $model.getOrderedInitialEquations())
#if (!$sew.isEQUATION_TYPE_SCALAR_INTERNAL($eq.getType()))
#if ($calcInitial != "")
#set ($calcInitial = "${calcInitial}${newLine2}")
#end
#if ($sew.isEQUATION_TYPE_INITIAL_VALUE($eq.getType()))
#set ($math = $engine.formatMath($eq.getFormula(), $eq, $engine.getInitialValuesASTVisitors()))
#else
#set ($math = $engine.formatMath($eq.getFormula(), $eq))
#end
#if ($math.get(0) != "")
#set ($calcInitial = "${calcInitial}$math.get(0)${newLine}")
#end
#set ($calcInitial = "${calcInitial}$engine.getVariableCodeName($eq.getVariable()) = $math.get(1);")
#end
#end
############################################Create Calculate Algebraic Methods########################################################################
##
#set ($algebraicMethodCall = "")## Calling of caluclateAlgebraic method
#if ($sew.isOfType($engine.getModelType(), $sew.getEMODEL_ALGEBRAIC_TYPE()))
#set ($algebraicBegin = "")
#set ($algebraicEnd = "")
#set ($algebraicSolve = "")
#set ($size = 0)
#foreach ($v in $variables)
#if ($engine.isAlgebraic($v.getName()))
#set ($variableCodeName = $engine.getVariableCodeName($v.getName()))
#set ($algebraicBegin = "${algebraicBegin}${newLine2}initialGuess[$size] =  $variableCodeName;")
#set ($algebraicEnd = "${algebraicEnd}${newLine2}$variableCodeName = result[$size];")
#set ($algebraicSolve = "${algebraicSolve}${newLine2}$variableCodeName = $zVariables[$size];")
#set ($size = $size + 1)
#end
#end
#if ( $size != 0)
#set ($algebraicMethodCall = "calculateAlgebraic();")
#if ( $calcParameters!="")
#set ( $calcParameters = "${calcParameters}${newLine2}")
#end
#set ( $calcParameters = "calculateAlgebraic();${newLine2}${calcParameters}")
$br
    private void calculateAlgebraic()  throws Exception
    {
        double[] initialGuess = new double [$size];
        $algebraicBegin
        double[] result = aeSolver.solve(initialGuess, this);
        $algebraicEnd
    }
$br
    public final double[] solveAlgebraic(double[] $zVariables)
    {
        $algebraicSolve
#set ($algebraic = $model.getAlgebraic().toList())
        final double [] result = new double [$algebraic.size()];
#set ($counter = 0)
#foreach ($eq in $algebraic)
#set ($math = $engine.formatMath($eq.getFormula(), $eq))
#if ($math.get(0) != "")
        $math.get(0);
#end        
        result[$counter] = $math.get(1);
#set ($counter = $counter + 1)
#end
        return result;
    }
#end
#end
## end of: if ($sew.isOfType($engine.getModelType(), $sew.getEMODEL_ALGEBRAIC_TYPE()))
##
##############################################Create parameters calculation body###############################################################
##
#if ($calcParameters!="")
#set ($calcParametersCall = "calculateParameters();")
$br
    private void calculateParameters() throws Exception
    {
        double[] x_values = this.x_values;
        $calcParameters
    }
#end
#if ($calcInitial.length() > 0)
#set ($calcInitialCall = "calculateInitialParameters();")
$br
    private void calculateInitialParameters()
    {
#if ($calcInitial.length() > 0)
        double[] x_values = this.x_values;
        $calcInitial
#end
    }
#end
##
##############################################Create Functions###############################################################
##
#set ($functions = $model.getFunctions())
#foreach ($f in $functions)
#set ($math = $engine.formatMath($f.getFormula(), $f, $engine.getFunctionDeclarationASTVisitors()))
#set ($functionBody = $engine.createFunctionBody($math.get(0) , $math.get(1)))
$functionBody
#end
##
#############################################Model initialization###########################################################
##
$br
    @Override
    public final void init() throws Exception
    {
        CONSTRAINTS__VIOLATED = 0;
        this.simulationResultHistory.clear();
        this.simulationResultTimes.clear();
#foreach( $v in $variables )
#if ( !$engine.isArrayModeVariable($v) && !$engine.isTemp($v))
        $engine.getVariableCodeName($v.getName()) = $sew.getCode($v.getInitialValue()); // initial value of $v.getName()
#end
#end
        calculateInitialValues();
        this.isInit = true;
    }
$br
    @Override
    public final void init(double[] initialValues, Map<String, Double> parameters) throws Exception
    {
        super.init(initialValues, parameters);
###########################Consider initial assignments###############################
#foreach ($eq in $model.getInitialAssignments().toList())
#set ( $varName = $eq.getVariable() )
#set ($variable = $model.getVariable($varName))
#set ($math = $engine.formatMath($eq.getMath()))
#if ($math.get(0)!="")
        $math.get(0)
#end
        $engine.getVariableCodeName($varName) = $math.get(1);
#end   
############################Algebraic rules calculation######################
#if ($algebraicMethodCall != "")
        $algebraicMethodCall
#end
        this.initialValues = x_values.clone();
    }
##
############################Create calculateInitialValues method#################################
##
$br
    private final void calculateInitialValues() throws Exception
    {
        double[] x_values = this.x_values = new double[$dimension];
        this.time = $engine.getInitialTime();
###########################Array variables initial values###########################
#set( $ind = 0 )
#foreach( $v in $variables )
#if( $engine.isArrayModeVariable($v) )
#set ($initialValue = $v.getInitialValue())
#if ($initialValue != "0.0")
        x_values[$ind] = $initialValue; //  initial value of $v.getName()
#end
#set( $ind = $ind + 1 )
#end
#end
##Before calculating initial assignments we need to initialize initialValues (which will be recalculated e.g. concentration -> amount)
        this.initialValues = x_values.clone();
###########################Consider initial assignments###############################
#if ($calcInitial.length() > 0)
        $calcInitialCall
#end
############################Algebraic rules calculation######################
#if ($algebraicMethodCall != "")
        $algebraicMethodCall
#end
        this.initialValues = x_values.clone();
    }
$br
##
###########################################Create Extend Result Methods#############################################################
##
$br
    public final double[] extendResult(double time, double[] x_values) throws Exception
    {
        this.time = time;
        this.x_values = x_values;
#if ($calcParameters!="")
        $calcParametersCall
#end
        return getCurrentState(); 
    }
##
##
###########################################Create get Current State Method#############################################################
##
$br
    public final double[] getCurrentState()
    {
        return new double[] {
#foreach ($v in $variables)
#if ($engine.isSignificant($v))
#set ($rightSide = false)
#set ($rightSide = $engine.getVariableCodeName($v.getName()))
#if ($rightSide)
####################Transform to moles if needed##################
#set ($rightSide = "$rightSide / $engine.getMoleculeScale($v)")
####################Transform to concentration units if needed##################
#if( $sew.isOutputConcentration($v))
#set ( $compartmentRole = $sew.getCompartmentVariable($v ))
#if($compartmentRole)
#set ( $rightSide= "${rightSide}/$engine.getVariableCodeName($compartmentRole.getName())")
#end
#end
            ${rightSide},
#end
#end
#end
        };
    }
##
###########################################Create Set Current Values Methods#############################################################
##
    public final void setCurrentValues(double[] values) throws Exception
    {
        CONSTRAINTS__VIOLATED = 0;
        if ( time == 0 )
        {
#foreach ($v in $variables)
#if ( $engine.isArrayModeVariable($v) )
#set ( $rateIndex = $engine.getVariableRateIndex( $v.getName() ) )
#set ( $leftSide = "initialValues[$rateIndex]")
#else
#set ( $leftSide = "$engine.getVariableCodeName($v.getName())")
#end
#set ( $globalIndex = $engine.getVarIndexMapping().get( $v.getName() ) )
            $leftSide = values[$globalIndex];        
#end
#if ($calcInitial!="")
            $calcInitialCall  
#end              
            this.initialValues = x_values.clone();
            return;
        }
#foreach ($v in $variables)
#if ($engine.isSignificant($v))
#set ($index = $engine.getVarIndexMapping().get($v.getName()))
#set ($rightSide = "values[${index}]")
#set($rightSide = "$rightSide * $engine.getMoleculeScale($v)")
####################Transform to amount units if needed##################
#if( $sew.isOutputConcentration($v))
#set ( $compartmentRole = $sew.getCompartmentVariable($v ))
#if($compartmentRole)
#set ( $rightSide= "${rightSide}*$engine.getVariableCodeName($compartmentRole.getName())")
#end
#end
        $engine.getVariableCodeName($v.getName()) = ${rightSide};        
#end
#end

#if ($calcParameters!="")
           $calcParametersCall
#end
    }
##
########################################Event Temp Variables Declaration################################################################
##
#if ($sew.isOfType($engine.getModelType(), $sew.getEMODEL_EVENT_TYPE()) || $sew.isOfType($engine.getModelType(), $sew.getEMODEL_STATE_TRANSITION_TYPE()))
$br
#set ( $events = $model.getEvents() )
#set ( $evNumber = $events.size() )
##
########################################Create Check Event Method######################################################################
##
$br
    public final double[] checkEvent(double time, double[] x_values) throws Exception
    {
        this.time = time;
        this.x_values = x_values;
#if ( $calcParameters!="" )
        $calcParametersCall
#end
#set ( $result = $engine.generateUniqueLocalVariable("z") )
        double[] $result  = new double[$evNumber];
#set ($index = 0)
#foreach ( $ev in $events )
#set ($trigger = "")
#if ($ev.getDelay() != "0")
#set ( $trigger = "this.time >= getNextExecutionTime(${index})" )
#end  
#if ( $ev.getDelay() == "0" || !$ev.isTriggerPersistent() )
#set ( $math = $engine.formatMath($ev.getTrigger(), $ev) )
#if ( $math.get(0)!="" )
        $math.get(0)
#end
#if ($trigger != "")
#set ($trigger = "$trigger && ")
#end
#set ( $trigger = "${trigger}$math.get(1)" )
#end
        $result[$index] = ($trigger) ? 1 : -1; // $ev.getDiagramElement().getTitle();
#set ( $index = $index + 1 )
#end
        return $result;
    }
##
######################################Create Process Event Method###########################################################
##
#set ( $eventIndex = $engine.generateUniqueLocalVariable("i") )
#set ( $assignments = $engine.generateUniqueLocalVariable("assignments") )
#set ( $executionTime = $engine.generateUniqueLocalVariable("executionTime") )
$br
    public final void processEvent(int $eventIndex)
    {
        double[] $assignments;
        double $executionTime;
#set ( $counter = 0 )
        switch ( $eventIndex )
        {
#foreach ( $ev in $events )
            case ( $counter ): //$ev.getDiagramElement().getTitle()
            {
#if ($sew.isTerminal($ev))
                 CONSTRAINTS__VIOLATED = 1;
                 break;
            }
#set ( $counter = $counter + 1 )
#else
#if ( $sew.isDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
#set ( $assignmentIndex = 0 )
                $assignments = getNextAssignments($counter);
#foreach ( $sa in $ev.getEventAssignment() )
                $engine.getVariableCodeName($sa.getVariable()) = $assignments[$assignmentIndex] * $engine.formatMath($sa.getMath(), $ev).get(1);
#set ($assignmentIndex = $assignmentIndex + 1)
#end
#else
#set ( $assignmentIndex = 1 )
#if ( $sew.isTriggerForDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
#set ( $assignmentIndex = 0 )
                $assignments = new double[$ev.getEventAssignment().size() - 1];
#end
#if (!$ev.isUseValuesFromTriggerTime() && !$sew.isTriggerForDelayedEvent($ev))
                $assignments = new double[$ev.getEventAssignment().size()];
#set ( $assignmentIndex = 0 )
#foreach ( $sa in $ev.getEventAssignment() )
#set ( $math = $engine.formatMath($sa.getMath(), $ev) )
#if ( $math.get(0)!="" )
        $math.get(0)
#end
                $assignments[$assignmentIndex] =  $math.get(1);
#set ($assignmentIndex = $assignmentIndex + 1)
#end
#set ( $assignmentIndex = 0 )
#foreach ( $sa in $ev.getEventAssignment() )
                $engine.getVariableCodeName($sa.getVariable()) = $assignments[$assignmentIndex];
#set ( $assignmentIndex = $assignmentIndex + 1 )
#end
#else
#set ( $assignmentIndex = 0 )
#foreach ( $sa in $ev.getEventAssignment() )
#if ( $sew.isTriggerForDelayedEvent($ev) )
#if ( $assignmentIndex == 0)
#set( $leftSide = "$executionTime" )
#else
#set ( $leftSide = "$assignments[$assignmentIndex - 1]" )
#end
#set ( $assignmentIndex = $assignmentIndex + 1)
#else
#set ( $leftSide = "$engine.getVariableCodeName($sa.getVariable())" )
#end
#set ( $math = $engine.formatMath($sa.getMath(), $ev) )
#if ( $math.get(0)!="" )
                $math.get(0)
#end
                $leftSide = $math.get(1);
#end
#end
#end
#if ( $sew.isDelayedEvent($ev) )
                removeDelayedEvent($counter);
#elseif ( $sew.isTriggerForDelayedEvent($ev) && $ev.isUseValuesFromTriggerTime() )
                addDelayedEvent($counter + 1, $executionTime, $assignments);
#elseif ( $sew.isTriggerForDelayedEvent($ev) )
                addDelayedEvent($counter + 1, $executionTime, null);
#end
                break;
            }
#set ( $counter = $counter + 1 )
#end
#end
            default:
                break;
        }
    }
## end of process event method
##
########################################Create Event Priority Method######################################################################
##
##
$br
    public final double[] getEventsPriority(double time, double[] x_values) throws Exception
    {
#if ($calcParameters!="")
        $calcParametersCall
#end
#set ($priorities = "")
#set ($preparation = "")
#foreach ($ev in $events)
#if (!$ev.getPriority() )
#set($priorities = "${priorities}${newLine2}Double.NEGATIVE_INFINITY, //$ev.getDiagramElement().getTitle()")
#else
#set ($math = $engine.formatMath($ev.getPriority(), $ev))
#if ($math.get(1).isEmpty())
#set($priorities = "${priorities}${newLine2}Double.NEGATIVE_INFINITY, //$ev.getDiagramElement().getTitle()")
#else
#if ( $math.get(0)!="" )
#set($preparation = "${preparation}${newLine2}$math.get(0)")
#end
#set($priorities = "${priorities}${newLine2}$math.get(1), //$ev.getDiagramElement().getTitle()")
#end
#end
#end
#set ($priorities = "${spaces}return new double[] {${priorities}${newLine2}};")
#if(!$preparation.isEmpty())
$preparation
#end
$priorities
    }

##
########################################Create Event Trigger Initial Value Method######################################################################
##
##
$br
    public final boolean getEventsInitialValue(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($result = $ev.isTriggerInitialValue())
#if ( $result == "false" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces}")
#end
#set ($counter = $counter + 1)
#end
#if ( $methodBody != "" )
#set ($methodBody = "${methodBody}${spaces}return false;${br}${spaces2}${spaces}")
#set ($methodBody = "${methodBody}default:${br}${spaces2}${spaces2}return true;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return true;
#end
    }
##
##
########################################Create Event Trigger Persistent Method######################################################################
##
##
$br
    public final boolean isEventTriggerPersistent(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($result = $ev.isTriggerPersistent())
#if ( $result == "false" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces}")
#end
#set ($counter = $counter + 1)
#end
#if ($methodBody != "")
#set ($methodBody = "${methodBody}${spaces}return false;${br}${spaces2}${spaces}")
#set ($methodBody = "${methodBody}default:${br}${spaces2}${spaces2}return true;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return true;
#end
    }
##end of event methods
##
##
########################################Create Event Message Method######################################################################
##
##
$br
    public final String getEventMessage(int $eventIndex) throws IndexOutOfBoundsException
    {
#set ($methodBody = "")
#set ($counter = 0)
#foreach ($ev in $events)
#set ($message = $ev.getTriggerMessage())
#if ( $message != "" )
#set ($methodBody = "${methodBody}case ( ${counter} )://$ev.getDiagramElement().getTitle()${br}${spaces2}${spaces2}return ${quote}${message}${quote};")
#end
#set ($counter = $counter + 1)
#end
#if ($methodBody != "")
#set ($methodBody = "${methodBody}${br}${spaces2}${spaces}default:${br}${spaces2}${spaces2}return null;")
        switch ( $eventIndex )
        {
            $methodBody
        }
#else
        return null;
#end
    }
#end
##end of event methods
##
#############################################History methods########################################
##
#if ($engine.containsDelays())
$br
    public final double getPrehistory(double time, int i)
    {
        switch (i)
        {
#foreach ($v in $engine.getVarNameHistoryIndexMapping().keySet())
            case $engine.getVarNameHistoryIndexMapping().get($v):
            {
#set( $variable = $model.getVariable($v) )
#if ( $variable.getAttributes().getValue("isRate") == true )
               return 0;
            }  
#else
#set( $hasEquation = false )
#set ($equations = $engine.getDefiningEquations($v))
#foreach ($eq in $equations)
#if ( $sew.isScalar($eq) )
#set ($math = $engine.formatMath($eq.getFormula(), $eq, $engine.getPrehistoryASTVisitors()))
#if ($math.get(0) != "")
        $math.get(0);
#end        
#set ($rightSide = $math.get(1))
#set ($hasEquation = true )
#end
#end
#if (!$hasEquation)
#set ($rightSide = $model.getVariable($v).getInitialValue())
#end
                return $rightSide;
            }
#end
#end
        }
        return 0;
    }
$br
    public final double[] getCurrentHistory()
    {
#set ($historyVars = $engine.generateUniqueLocalVariable("z"))
        double[] $historyVars  = new double[$engine.getHistoricalVariableNumber()];
#foreach ($v in $engine.getVarNameHistoryIndexMapping().keySet())
#set ($indexInHistory = $engine.getVarNameHistoryIndexMapping().get($v))
        $historyVars[$indexInHistory] = $engine.getVariableCodeName($v);
#end
        return $historyVars;
    }
#end
##end of history methods


##
#############################################Do Reaction Method#############################################################
##
    @Override
    public void doReaction(int i, double[] x_values, double k)
    {
        switch( i )
        {
#foreach ( $reactionName in $reactionIndexMapping.keySet() )
           case $reactionIndexMapping.get($reactionName) : //reaction $reactionName
            {
#set ( $reactionEdges = $engine.getReactionNode($reactionName).getEdges() )
#foreach ( $edge in $reactionEdges )
#if  ( $sew.isSpecieReference($edge) )
#set ( $sr = $edge.getKernel() )
#if ($sr.isProduct() || $sr.isReactant())
#if  ( $sr.isReactant() )
#set ( $node = $edge.getInput() )
#set ( $operation = "-=")
#elseif( $sr.isProduct() )
#set ( $node = $edge.getOutput() )
#set ( $operation = "+=")
#end
#if ($sew.isVariable($node))
#set($varName = $node.getRole().getName())
#if ( $engine.isArrayModeVariable($model.getVariable($varName))) 
                x_values[ $engine.getVariableRateIndex( $node.getRole().getName() ) ] $operation  $sr.getStoichiometry() * k;    
#end
#end
#end
#end
#end
                break;
            }
#end
        }
    }
  
##
#############################################Get Indexes of Substrate Method#############################################################
## 
    @Override
    public Set<Integer> getIndexesOfSubstrate(int i)
    {
        Set<Integer> result = new HashSet<Integer>();
   
        switch( i )
        {
#foreach ( $reactionName in $reactionIndexMapping.keySet() )
            case $reactionIndexMapping.get($reactionName) : //reaction $reactionName
            {
#set ( $reactionEdges = $engine.getReactionNode($reactionName).getEdges() )
#foreach ( $edge in $reactionEdges )
#if ( $sew.isSpecieReference($edge) && $edge.getKernel().isReactant() )
#set ( $node = $edge.getInput() )
#if ( $sew.isVariable($node) )
#set($varName = $node.getRole().getName())
#if ( $engine.isArrayModeVariable($model.getVariable($varName))) 
                result.add( $engine.getVariableRateIndex( $node.getRole().getName() ) );
#end
#end
#end
#end           
                break;
            }
#end
        }
        return result;
    }
   
##
#############################################Update Propensities  Method#############################################################
##
    @Override
    public void updatePropensities(double[] propensities, int i, double[] x_values) throws Exception
    {
        if( i < 0 )
            return;
#if ($calcParameters!="")
        $calcParametersCall
#end
        if( this.reactionDependencies != null && i < this.reactionDependencies.length )
        {
            for( int j : this.reactionDependencies[i] )
                propensities[j] = updatePropensity(j, x_values);
        }
        else if( this.reactionDependencies == null )
        {
            for( int j = 0; j < $engine.getReactionNumber(); j++ )
                propensities[j] = updatePropensity(j, x_values);
        }
    }

    public double updatePropensity(int i, double[] x_values)
    {
        switch( i )
        {
#foreach ( $rEntry in $reactionIndexMapping.entrySet() )
#set ( $equation = $engine.getReactionNode( $rEntry.getKey() ).getRole() )
#set ( $f = $engine.formatMath( $equation.getFormula(), $equation ) )
#set ( $declaration = $f.get(0) )
#set ( $formula = $f.get(1) )
            case $rEntry.getValue() : //reaction $rEntry.getKey()
#if ( $declaration && $declaration.length() > 0)
                $decalaration
#end
                return $formula;
#end
            default:
                throw new IllegalArgumentException("Cannot find reaction with number " + i + " in reaction index map.");
        }
    }

##
#############################################Get Propensities  Method#############################################################
##
    @Override
    public double[] getPropensities(double[] x_values) throws Exception
    {
        double[] propensities = new double[$engine.getReactionNumber()];
#if ($calcParameters!="")
        $calcParametersCall
#end

        for( int i = 0; i < $engine.getReactionNumber(); i++ )
            propensities[i] = updatePropensity(i, x_values);
        return propensities;
    }
##

public Map<Integer,Integer>[] getReactantStochiometry()
    {
        Map<Integer,Integer>[] result=new HashMap [$reactionIndexMapping.size()];
#set ($reactionIndexMapping = $engine.getReactionNameIndexMapping())
#foreach ( $reactionName in $reactionIndexMapping.keySet() )
#set($number=$reactionIndexMapping.get($reactionName))
        result[$number]=new HashMap <Integer,Integer>();
#set ( $reactionEdges = $engine.getReactionNode($reactionName).getEdges() )
#foreach ( $edge in $reactionEdges )
#if  ( $sew.isSpecieReference($edge) )
#set ( $sr = $edge.getKernel() )
#if  ( $sr.isReactant() )
#set ( $node = $edge.getInput() )
#if ($sew.isVariable($node))
#set($varName = $node.getRole().getName())
#if ( $engine.isArrayModeVariable($model.getVariable($varName))) 
        result[$number].put($engine.getVariableRateIndex( $node.getRole().getName() ) , $sr.getStoichiometry());
#end
#end
#end
#end
#end
#end
        return result;
    }

    public Map<Integer,Integer>[] getProductStochiometry()
    {
        Map<Integer,Integer>[] result=new HashMap [$reactionIndexMapping.size()];
#set ($reactionIndexMapping = $engine.getReactionNameIndexMapping())
#foreach ( $reactionName in $reactionIndexMapping.keySet() )
#set($number=$reactionIndexMapping.get($reactionName))
        result[$number]=new HashMap <Integer,Integer>();
#set ( $reactionEdges = $engine.getReactionNode($reactionName).getEdges() )
#foreach ( $edge in $reactionEdges )
#if  ( $sew.isSpecieReference($edge) )
#set ( $sr = $edge.getKernel() )
#if  ( $sr.isProduct() )
#set ( $node = $edge.getOutput() )
#if ($sew.isVariable($node))
#set($varName = $node.getRole().getName())
#if ( $engine.isArrayModeVariable($model.getVariable($varName))) 
        result[$number].put($engine.getVariableRateIndex( $node.getRole().getName() ) , $sr.getStoichiometry());
#end
#end
#end
#end
#end
#end
        return result;
    }
}

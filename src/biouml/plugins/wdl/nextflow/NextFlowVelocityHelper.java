package biouml.plugins.wdl.nextflow;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.developmentontheedge.beans.DynamicProperty;

import biouml.model.Compartment;
import biouml.model.Diagram;
import biouml.model.Node;
import biouml.plugins.wdl.WorkflowUtil;
import biouml.plugins.wdl.WorkflowVelocityHelper;
import biouml.plugins.wdl.diagram.WDLConstants;
import biouml.plugins.wdl.model.ExpressionInfo;
import one.util.streamex.StreamEx;

public class NextFlowVelocityHelper extends WorkflowVelocityHelper
{
    private boolean isEntryScript = true;

    public NextFlowVelocityHelper(Diagram diagram)
    {
        super( diagram );
    }

    public NextFlowVelocityHelper(Diagram diagram, boolean isEntryScript)
    {
        super( diagram );
        this.isEntryScript = isEntryScript;
    }

    public Node getCallByOutput(Node node)
    {
        return node.edges().map( e -> e.getOtherEnd( node ) ).findAny( n -> WorkflowUtil.isCall( n ) ).orElse( null );
    }

    @Override
    public String getCommand(Compartment c)
    {
        String command = super.getCommand( c );
        command = command.replace( "$", "\\$" );
        command = command.replace( "~{", "${" );
        return command;
    }

    @Override
    public String getExpression(Node n)
    {
        String expression = super.getExpression( n );
        if( expression == null )
            return null;
        expression = expression.replace( "~{", "${" );
        return expression;
    }

    @Override
    public String getType(Node n)
    {
        return getNextFlowType( super.getType( n ) );
    }

    /**
     * Transforms WDL type to Nextflow type
     */
    private static String getNextFlowType(String wdlType)
    {
        switch( wdlType )
        {
            case "File":
            case "Array[File]":
                return "path";
            case "tuple":
                return "tuple";
            default:
                return "val";
        }
    }

    public String getExternalInput(Node n)
    {
        if( n == null )
            return "??";

        StringBuilder result = new StringBuilder();
        result.append( getName( n ) );
        String expression = getExpression( n );
        if( expression != null && !expression.isEmpty() )
        {
            result.append( " = " + expression );
        }
        return result.toString();
    }

    public String getVersion()
    {
        return WorkflowUtil.getVersion( diagram );
    }

    public String getCycleName(Compartment c)
    {
        Node cycleVarNode = WorkflowUtil.getCycleVariableNode( c );
        if( cycleVarNode == null )
            return null;
        Node source = WorkflowUtil.getSource( cycleVarNode );
        if( source == null )
            return null;
        return getName( source );
    }

    public String createChannelName(String input)
    {
        return input.replace( ".", "_" ) + "_ch";
    }

    public List<Node> getCallsScatters(Compartment compartment)
    {
        List<Node> result = new ArrayList<>();
        for( Node c : orderedCalls )
        {
            if( c.getParent().equals( compartment ) )
                result.add( c );
        }
        return result;
    }

    public String getInputName(Node n)
    {
        Node source = WorkflowUtil.getSource( n );
        if( source != null )
            n = source;
        String name = WorkflowUtil.getName( n );
        String type = WorkflowUtil.getType( n );
        if( WorkflowUtil.isExternalParameter( n ) )
        {
            String result = name;
            if( "File".equals( type ) )
                result = "channel.fromPath(" + result + ")";
            return result;
        }
        if( WorkflowUtil.isCall( n.getCompartment() ) )
            return getResultName( n.getCompartment() ) + "." + name;
        return name;
    }


    /**
     * @return name of the result generated by call associated with compartment
     */
    public String getResultName(Compartment c)
    {
        return "result_" + WorkflowUtil.getCallName( c );
    }

    public String getInputName(Compartment call)
    {
        List<Node> inputs = getOrderedInputs( call );
        if( inputs.isEmpty() )
            return "";

        if( WorkflowUtil.isCycle( call.getCompartment() ) )
            return "input_" + WorkflowUtil.getCallName( call );
        else
            return StreamEx.of( inputs ).map( n -> getFullName( WorkflowUtil.getSource( n ) ) ).joining( "," );
    }

    public String getFullName(Node node)
    {
        if( WorkflowUtil.isCall( node.getCompartment() ) )
        {
            return getResultName( node.getCompartment() ) + "." + getName( node );
        }
        return getName( node );
    }


    private String[] processCycleNodes(String mappingName, List<Node> nodes, StringBuffer defs, StringBuffer result, StringBuffer out,
            StringBuffer calls, boolean insideCondition)
    {
        for( Node n : nodes )
        {
            if( WorkflowUtil.isExpression( n ) )
            {
                if( insideCondition )
                    defs.append( "\n    " + WorkflowUtil.getName( n ) + " = " + getExpression( n ) );
                else
                    defs.append( "\n    def " + WorkflowUtil.getName( n ) + " = " + getExpression( n ) );
                out.append( "\n  " + WorkflowUtil.getName( n ) + " = " + mappingName + "." + WorkflowUtil.getName( n ) );
                result.append( "\n    " + WorkflowUtil.getName( n ) + ": " + WorkflowUtil.getName( n ) );
            }
            else if( WorkflowUtil.isCall( n ) )
            {
                // #set ($inputs = $helper.getOrderedInputs($call))
                //                $helper.getResultName($call) = $helper.getCallName($call)( #foreach($input in $inputs)$helper.getCallInputName($input)#comma($inputs) #end)$BR

                List<Node> inputs = WorkflowUtil.getOrderedInputs( (Compartment)n );
                //                calls.append( insideCondition )
                inputs = StreamEx.of( inputs ).filter( input -> !WorkflowUtil.isCallResult( input ) ).toList();
                if( inputs.size() == 0 )
                    continue;
                result.append( "\n    " );
                result.append( WorkflowUtil.getCallName( n ) + "_input: tuple(" );
                result.append( StreamEx.of( inputs ).map( input -> WorkflowUtil.getExpression( input ) ).joining( ", " ) );
                result.append( ")" );
            }
            else if( WorkflowUtil.isConditional( n ) )
            {
                StringBuffer conditionalDefs = new StringBuffer();
                StringBuffer conditionalResult = new StringBuffer();
                StringBuffer conditionalOut = new StringBuffer();
                processCycleNodes( mappingName, WorkflowUtil.orderCallsScatters( (Compartment)n ), conditionalDefs, conditionalResult,
                        conditionalOut, calls, true );
                String newDefs = conditionalDefs.toString();
                for( String newDef : newDefs.split( "\n" ) )
                {
                    if( !newDef.trim().isEmpty() )
                    {
                        newDef = newDef.substring( 0, newDef.indexOf( "=" ) - 1 ) + " = null";
                        defs.append( "\n    def " + newDef );
                    }
                }
                defs.append( "\n    if (" + WorkflowUtil.findCondition( (Compartment)n ) + ") {" );
                defs.append( conditionalDefs );
                result.append( conditionalResult.toString() );
                out.append( conditionalOut.toString() );
                defs.append( "\n    }" );
            }
        }
        return new String[] {defs.toString(), result.toString(), out.toString()};
    }


    private boolean dependsOnTask(Node expression, Set<Compartment> possibleTasks)
    {
        List<Compartment> calls = WorkflowUtil.getSources( expression ).filter( n -> WorkflowUtil.isCall( n.getCompartment() ) )
                .map( n -> n.getCompartment() ).toList();
        for( Compartment call : calls )
        {
            if( possibleTasks.contains( call ) )
                return true;
        }
        return false;
    }


    private List<List<Node>> breakOrderedTasks(List<Node> nodes)
    {
        List<List<Node>> result = new ArrayList<>();
        List<Node> part = new ArrayList<>();
        result.add( part );
        for( Node node : nodes )
        {
            if( WorkflowUtil.isCall( node ) )
                part = new ArrayList<>();
            result.add( part );
            part.add( node );
        }
        return result;
    }

    private String getChannelName(Node cycledVar)
    {
        return getChannelName( cycledVar, true );
    }

    private String getChannelName(Node cycledVar, boolean toChannel)
    {
        String cycledVarName = getName( cycledVar );
        String channelName = cycledVarName;
        if( WorkflowUtil.isCycleVariable( cycledVar ) )
        {
            if( toChannel )
                channelName = "toChannel(" + getCycleName( cycledVar.getCompartment() ) + ")";//TODO: expr depending on expr
            else
                channelName = getCycleName( cycledVar.getCompartment() );
        }
        else if( isCall( cycledVar.getCompartment() ) )
        {
            channelName = getResultName( cycledVar.getCompartment() ) + "." + getName( cycledVar );
        }
        return channelName;
    }


    public String describeNodeInCycle(Node node, Compartment cycle)
    {
        StringBuilder sb = new StringBuilder();
        if( isExpression( node ) )
        {
            List<Node> cycledSources = getCycledSources( node );

            sb.append( "\n " );
            if( cycledSources.size() == 0 )
            {
                sb.append( getName( node ) + " = " + getExpression( node ) );//simply repeat it wo changes
            }
            if( cycledSources.size() == 1 )
            {
                Node cycledVar = cycledSources.get( 0 );
                String cycledVarName = getName( cycledVar );
                String channelName = getChannelName( cycledVar );
                String expression = getExpression( node );
                if( isCall( cycledVar.getCompartment() ) )
                    expression = expression.replace( getCallName( cycledVar.getCompartment() ) + ".", "" );
                sb.append( getName( node ) + " = " + channelName + ".map { " + cycledVarName + " -> " + expression + " }" );
            }
            else
            {
                List<Compartment> allCycles = WorkflowUtil.getParentCycles( node ).reversed();
                List<Node> allNodes = new ArrayList<>();
                sb.append( getName( node ) + " = " );
                String expression = getExpression( node );
                Map<String, List<Node>> cycledGroups = new HashMap<>();
                for( int i = 0; i < cycledSources.size(); i++ )
                {
                    Node cycledVar = cycledSources.get( i );
                    Compartment parentCycle = WorkflowUtil.getParentCycle( cycledVar );
                    cycledGroups.computeIfAbsent( parentCycle.getName(), k -> new ArrayList() ).add( cycledVar );

                    if( isCall( cycledVar.getCompartment() ) )//TODO: move somewhere
                        expression = expression.replace( getCallName( cycledVar.getCompartment() ) + ".",
                                getCallName( cycledVar.getCompartment() ) + "_" );
                }

                List<String> merged = new ArrayList<String>();
                for( Compartment parentCycle : allCycles )
                {
                    List<Node> nodes = cycledGroups.get( parentCycle.getName() );
                    allNodes.addAll( nodes );
                    merged.add( getChannelName( nodes.get( 0 ) )
                            + StreamEx.of( nodes ).skip( 1 ).map( n -> ".merge( " + getChannelName( n ) + " )" ).joining() );
                }
                sb.append( merged.get( 0 ) + StreamEx.of( merged ).skip( 1 ).map( n -> ".combine(" + n + ")" ).joining() );

                sb.append( ".map { " );
                sb.append( StreamEx.of( allNodes ).map( s -> getName( s ) ).joining( "," ) );
                sb.append( " -> " );
                sb.append( expression );
                sb.append( " }" );
            }
        }
        else if( isCall( node ) )
        {
            Compartment call = (Compartment)node;
            List<Node> inputs = WorkflowUtil.getOrderedInputs( call );
            List<String> inputNames = new ArrayList<>();
            List<String> inputDeclarations = new ArrayList<>();
            List<Compartment> parentCycles = WorkflowUtil.getParentCycles( node ).reversed();
            sb.append( "\n" );
            for( Node input : inputs )
            {
                //                sb.append( "  " + createInputName( input ) + " = " + combine( parentCycles, input ) + "\n" );
                List<Node> cycledSources = getCycledSources( input );
                if( cycledSources.size() == 0 )
                {
                    inputNames.add( getExpression( input ) );
                }
                else
                {
                    inputDeclarations.add( createInputName( input ) + " = " + combine( parentCycles, input ) );
                    inputNames.add( createInputName( input ) );
                }
            }

            sb.append( StreamEx.of( inputDeclarations ).joining( "\n  ", "  ", "" ) );
            sb.append( "  \n" + getResultName( call ) + " = " + getCallName( call ) + "( " + StreamEx.of( inputNames ).joining( ", " )
                    + " )\n" );
        }
        //        y=arr.map { (it >2) ? it : null}.filter{ it !=  null }

        else if( isConditional( node ) ) //TODO: nested conditions, conditions in nested cycle
        {
            Compartment conditional = (Compartment)node;
            sb.append( "\n" );
            Node conditionNode = WorkflowUtil.findConditionNode( conditional );
            List<Node> cycledSources = getCycledSources( conditionNode );
            if( cycledSources.size() == 1 )
            {
                Node cycledVar = cycledSources.get( 0 );
                String cycledVarName = getName( cycledVar );
                String channelName = getChannelName( cycledVar );

                String condition = getExpression( conditionNode );
                for( Node inConditional : WorkflowUtil.orderCallsScatters( conditional ) )
                {
                    String expression = getExpression( inConditional );
                    if( isCall( cycledVar.getCompartment() ) )
                        expression = expression.replace( getCallName( cycledVar.getCompartment() ) + ".", "" );
                    sb.append( getName( inConditional ) + " = " + channelName + ".map { " + cycledVarName + "-> ( " + condition + " ) ? "
                            + expression + ": null }.filter { it != null }" );
                }
            }
        }
        else if( WorkflowUtil.isCycle( node ) )
        {
            sb.append( describeCycle( (Compartment)node ) );
        }
        return sb.toString();
    }

    private String createInputName(Node input)
    {
        return getCallName( input.getCompartment() ) + "_input_" + getName( input );
    }



    /**
     * Creates channel for given input
     * If input directly  depends on cycled variable it is added to channel
     * If input directly depends on call inside cycle it is added to channel
     * If input does not depend on anything from parent cycle - cycle variable is added to channel
     * E.g.
     * for (i...) 
     * { 
     *    result1 = call1( i )
     *    for (j...) 
     *    { 
     *       result2 = call2( j + 2 )
     *       for ( k...) 
     *       {
     *          result3 = call3(  result2 )
     *       }
     *    }
     * }
     * Will be translated to 
     * 
     * i_ch = toChannel( i )
     * j_ch = toChannel( j )
     * k_ch = toChannel( k )
     * result1 = call1( i_ch )
     * result2 = call2( i_ch.combine( j_ch ).map{ i,j -> j+2 )
     * result3 = call3 (  result2.combine( k ).map {  result1, result2, k ->  i + result1 + result2 }
     * TODO: add merge
     */
    private String combine(List<Compartment> parentCycles, Node input)
    {
        StringBuilder sb = new StringBuilder();
        String expression = getExpression( input );
        List<Node> cycledSources = getCycledSources( input );
        Map<Compartment, List<Node>> cycleToSources = new HashMap<>(); //cycle to all nodes in cycle from which input depends
        for( Compartment parentCycle : parentCycles )
            cycleToSources.put( parentCycle, new ArrayList<>() );

        if( cycledSources.size() == 1 )
        {
            Node cycledSource = cycledSources.get( 0 );
            List<Node> sources = WorkflowUtil.getSources( input ).toList();
            Node otherSource = null;
            if( sources.size() <= 2 )//sometimes edge is missing TODO: fix
            {
                otherSource = sources.size() == 2 ? StreamEx.of( sources ).without( cycledSource ).findAny().orElse( null )
                        : sources.get( 0 );
                Compartment cycle = WorkflowUtil.getParentCycle( input );
                String sycledName = WorkflowUtil.getCycleVariable( cycle );
                if( isCall( otherSource.getCompartment() ) )
                {
                    //Special case: we iterate through call output
                    String qualified = getCallName( otherSource.getCompartment() ) + "." + getName( otherSource );
                    if( expression.equals( qualified + '[' + sycledName + ']' ) )
                        return "result_" + qualified;
                }
                else if( WorkflowUtil.isExternalParameter( otherSource ) )
                {
                    if( expression.equals( getName( otherSource ) + '[' + sycledName + ']' ) )
                        return "toChannel("+getName( otherSource )+")";
                }
            }
        }
        for( Node cycledSource : cycledSources )
        {
            Compartment cycle = WorkflowUtil.getParentCycle( cycledSource );
            Compartment parent = cycledSource.getCompartment();
            if( isCall( parent ) )
            	  expression = replaceCallPrefix( expression, parent );
            cycleToSources.computeIfAbsent( cycle, k -> new ArrayList<>() ).add( cycledSource );
        }

        List<String> merged = new ArrayList<String>();
        List<Node> indexNodes = new ArrayList<>();
        for( Compartment cycle : parentCycles )
        {
            List<Node> toMerge = cycleToSources.get( cycle );
            if( toMerge.isEmpty() )
                toMerge.add( WorkflowUtil.getCycleVariableNode( cycle ) );

            List<String> channels = StreamEx.of( toMerge ).map( n -> getChannelName( n, false ) ).toList();
            merged.add( join( channels, ".merge( ", " )" ) );
            indexNodes.addAll( toMerge );
        }

        sb.append( merged.size() == 1 ? "toChannel( " + merged.get( 0 ) + " )"
                : StreamEx.of( merged ).joining( ", ", "combineAll( [ ", " ] )" ) );
        String indexes = StreamEx.of( indexNodes ).map( s -> withCallPrefix( s ) ).joining( ", " );
        if( ! ( indexes.equals( expression ) ) )
            sb.append( ".map { " + indexes + " -> " + expression + " }" );
        return sb.toString();
    }

    private boolean isOutputCycle(Node input, Node source)
    {
        String expression = getExpression( input );
        String qualified = getCallName( source.getCompartment() ) + "." + getName( source );
        return expression.contains( qualified + '[' );
    }

    public static String removeArrayAccess(String input, String callName)
    {
        String regex = Pattern.quote( callName ) + "\\[\\p{Alnum}+\\]";
        Matcher matcher = Pattern.compile( regex ).matcher( input );
        StringBuilder result = new StringBuilder();

        int lastEnd = 0;

        while( matcher.find() )
        {
            // Append text before match
            result.append( input, lastEnd, matcher.start() );
            // Append only the prefix part (without group capture)
            result.append( callName );
            lastEnd = matcher.end();
        }
        // Append remaining text
        result.append( input, lastEnd, input.length() );

        return result.toString();
    }

    private String replaceCallPrefix(String expression, Compartment call)
    {
        return expression.replace( getCallName( call ) + ".", getCallName( call ) + "_" );
    }

    private String withCallPrefix(Node node)
    {
        if( isCall( node.getCompartment() ) )
            return getCallName( node.getCompartment() ) + "_" + getName( node );
        return getName( node );
    }

    public String join(List<String> strings, String prefix, String suffix)
    {
        return strings.get( 0 ) + StreamEx.of( strings ).skip( 1 ).map( n -> prefix + n + suffix ).joining();
    }

    public String describeCycle(Compartment cycle)
    {
        StringBuilder sb = new StringBuilder();
        List<Node> nodes = WorkflowUtil.orderCallsScatters( cycle );
        if( nodes.isEmpty() )
            return "";

        for( Node node : nodes )
        {
            sb.append( describeNodeInCycle( node, cycle ) );
        }

        return sb.toString();
    }

    public String describeCycle2(Compartment cycle)
    {
        List<Node> nodes = WorkflowUtil.orderCallsScatters( cycle );
        if( nodes.isEmpty() )
            return "";

        StringBuilder sb = new StringBuilder();
        List<List<Node>> parts = breakOrderedTasks( nodes );

        int suffix = 1;
        for( List<Node> part : parts )
        {
            String partDescripion = describeCycle( cycle, part, suffix++ );
            sb.append( partDescripion );
            sb.append( "\n" );
        }

        return sb.toString();
    }
    /**
     *  cycle_inputs = range_i.combine(range_j).combine(range_k).multiMap* { i, j, k ->
     *      call_1_inputs: tuple(i, j)
     *      call_2_inputs: tuple(i, k)
     *  }
     */
    public String describeCycle(Compartment cycle, List<Node> nodes, int suffix)
    {

        List<Compartment> cycles = WorkflowUtil.getParentCycles( cycle );
        String name = getCycleName( cycle );
        String mappingName = name + "_mapping";

        StringBuffer defs = new StringBuffer();
        StringBuffer result = new StringBuffer();
        StringBuffer out = new StringBuffer();
        StringBuffer calls = new StringBuffer();
        String[] content = processCycleNodes( mappingName, nodes, defs, result, out, calls, false );
        if( content[0].isEmpty() && content[1].isEmpty() )
            return "";
        StringBuilder sb = new StringBuilder( "  " + mappingName + " = " );
        cycles.addFirst( cycle );
        cycles = cycles.reversed();
        List<String> cycleVars = StreamEx.of( cycles ).map( c -> getCycleVariable( c ) ).toList();
        List<String> cycleNames = StreamEx.of( cycles ).map( c -> getCycleName( c ) ).toList();
        sb.append( "toChannel(" + cycleNames.get( 0 ) + ")" );
        for( int i = 1; i < cycleNames.size(); i++ )
            sb.append( ".combine( " + cycleNames.get( i ) + ")" );

        sb.append( ".multiMap {" + StreamEx.of( cycleVars ).joining( ", " ) + " -> " );
        sb.append( content[0] );
        sb.append( "\n" );
        sb.append( content[1] );
        sb.append( "\n" );
        sb.append( "  }" );
        sb.append( "\n" );
        sb.append( content[2] );
        return sb.toString();
    }

    /**
     * Retrns all inputs of current call that depends on cycle variable or other calls executed in cycle
     */
    private List<Node> getCycledInputs(Compartment c)
    {
        List<Node> cycled = new ArrayList<>();
        for( Node input : WorkflowUtil.getInputs( c ) )
        {
            for( Node source : WorkflowUtil.getSources( input ) )
            {
                if( isArrayVariable( source ) )
                {
                    cycled.add( input );
                    break;
                }
            }
        }
        return cycled;
    }

    private List<Node> getCycledSources(Node expression)
    {
        List<Node> result = new ArrayList<>();
        for( Node source : WorkflowUtil.getSources( expression ) )
        {
            if( isArrayVariable( source ) )
                result.add( source );
        }
        return result;
    }

    /**
     * Returns true if node corresponds either to cycled variable or result of call which is performed inside cycle
     */
    private boolean isArrayVariable(Node node)
    {
        if( WorkflowUtil.isCycleVariable( node ) )
            return true;
        Compartment parent = node.getCompartment();
        if( WorkflowUtil.isCall( parent ) && isInsideCycle( parent ) )
            return true;

        for( Node source : WorkflowUtil.getSources( node ) )
            if( isArrayVariable( source ) )
                return true;
        return false;

    }

    public String prepareInputs(Compartment call)
    {
        StringBuilder sb = new StringBuilder( "  " );

        List<Compartment> cycles = WorkflowUtil.getParentCycles( call );
        if( cycles.size() > 1 )
            return "";

        Compartment cycle = call.getCompartment();
        String cycleVar = getCycleVariable( cycle );
        String cycleName = getCycleName( cycle );
        Set<Node> arrayInputs = getArrayDepenedantInputs( cycleVar, call );
        for( Node input : arrayInputs )
        {
            String expression = WorkflowUtil.getExpression( input );
            if( ( cycleVar.equals( expression ) ) )
                sb.append( getName( input ) + " = " + cycleName );
            else if( expression.contains( "[" ) )
                sb.append( getName( input ) + " = " + expression.substring( 0, expression.indexOf( "[" ) ) );
            else
            {
                sb.append( ".map{" + cycleVar + " -> " + expression + "}" );
            }
            //            if( ! ( cycleVar.equals( expression ) ) )
            //                sb.append( ".map{" + cycleVar + " -> " + expression + "}" );
            sb.append( "\n" );
        }
        return sb.toString();
    }

    public String getCallInputName(Node input)
    {
        Compartment call = input.getCompartment();
        if( !isInsideCycle( call ) || WorkflowUtil.isCallResult( input ) )
        {
            String result = getCallEmit( input );
            if( result == null )
                result = WorkflowUtil.getExpression( input );

            List<Node> sources = getSources( input );
            for( Node source : sources )
            {
                if( isInsideCycle( source.getCompartment() ) )
                {
                    String callName = getCallName( source.getCompartment() );
                    result = result.replace( callName + "." + getName( source ), callName + "." + getName( source ) + ".collect()" );
                }
            }

            if( result == null || result.isEmpty() )
                result = "\"" + WDLConstants.NO_VALUE + "\"";

            if( result.startsWith( "[" ) && result.endsWith( "]" ) )
                result = result.substring( 1, result.length() - 1 );

            if( isInsideCycle( call ) )//TODO: probably move to preproccessing
            {
                Set<String> cycleVariables = StreamEx.of( WorkflowUtil.getParentCycles( call ) )
                        .map( cycle -> WorkflowUtil.getCycleVariable( cycle ) ).toSet();
                for( String cycleVariable : cycleVariables )
                    result = result.replace( "[" + cycleVariable + "]", "" );
            }

            return result;
        }
        else
        {
            //            List<Compartment> cycles = WorkflowUtil.getParentCycles( call );
            //            if( cycles.size() > 1 )
            //            {
            //            int pos = WorkflowUtil.getPosition( input );
            //            String/ cycleName = WorkflowUtil.getCycleName( cycles.get( 0 ) ); //split_inputs.add_inputs.map { it[0] },
            //            return cycleName + "_mapping." + WorkflowUtil.getCallName( call ) + "_input.map { it[" + pos + "] }";
            //            }

            //            Compartment cycle = call.getCompartment();
            //            String cycleVar = getCycleVariable( cycle );
            //            if( isArray( cycleVar, input ) )
            //                return getName( input );//getExpression(input).replaceAll("\\[\\s*"+cycleVar+"\\s*\\]", "");//getName( input ) + "_ch";
            //            else
            //            {
            String result = getCallEmit( input );
            if( result == null )
                result = getExpression( input );
            if( result == null || result.isEmpty() )
                result = "\"" + WDLConstants.NO_VALUE + "\"";
            if( result.startsWith( "[" ) && result.endsWith( "]" ) )
                result = result.substring( 1, result.length() - 1 );
            return result;
            //            }
        }
    }

    public String getOutputExpression(Node node)
    {
        return getCallEmit( node );
    }

    public String getCallEmit(Node node)
    {
        String expression = getExpression( node );
        List<Node> sources = getSources( node );
        for( Node source : sources )
        {
            if( source != null && isCall( source.getCompartment() ) )
            {
                String result = getResultName( source.getCompartment() );
                String name = getCallName( source.getCompartment() );



                expression = expression.replace( name, result );
                //            boolean startBracket = expression.startsWith( "[" );
                //            expression = expression.substring( expression.indexOf( "." ) + 1 );
                //            if( startBracket )
                //                result = "[" + result;
                //            return result + "." + expression;
            }
        }
        return expression;
    }


    /**
     * replace all variables with 
     * e.g. i * 2 -> array.map { i->i*2}
     */
    public String processExpression(Node node)
    {
        String expression = getCallEmit( node );
        Compartment cycle = getClosestCycle( node );
        if( cycle == null )
            return expression;

        String variable = getCycleVariable( cycle );
        String name = getCycleName( cycle );
        //        if (expression.matches( name ))

        return name + ".map {" + variable + "->" + expression + " }";
    }

    public String getRuntimeProperty(Compartment process, String name)
    {
        DynamicProperty dp = process.getAttributes().getProperty( WDLConstants.RUNTIME_ATTR );
        if( dp == null || ! ( dp.getValue() instanceof String[] ) )
            return null;
        String[] options = (String[])dp.getValue();
        for( String option : options )
        {
            String[] parts = option.split( "#" );
            if( parts[0].equals( name ) )
            {
                return substituteVariables( parts[1], process );
            }
        }
        return null;
    }

    private String substituteVariables(String expression, Compartment process)
    {
        Map<String, String> replacements = new HashMap<>();
        List<String> variables = WorkflowUtil.findVariables( expression );
        for( String variable : variables )
        {
            String variableExpression = WorkflowUtil.findExpression( variable, process );
            if( variableExpression != null )
            {
                replacements.put( "~{" + variable + "}", variableExpression );
            }
        }
        for( Entry<String, String> e : replacements.entrySet() )
        {
            expression = expression.replace( e.getKey(), e.getValue() );
        }
        return expression;
    }

    public String getContainer(Compartment process)
    {
        return getRuntimeProperty( process, "docker" );
    }

    public String getCPUs(Compartment process)
    {
        return getRuntimeProperty( process, "cpu" );
    }

    public String getMemory(Compartment process)
    {
        return getRuntimeProperty( process, "memory" );
    }

    public String getMaxRetries(Compartment process)
    {
        return getRuntimeProperty( process, "maxRetries" );
    }

    public boolean shouldCollect(Compartment producer, Compartment consumer)
    {
        return true;
    }


    public String[] getMandatoryFunctions()
    {
        return new String[] {"toChannel", "get", "getDefault", "combineAll"};
    }
    /**
     * Functions that should be imported from biouml_function.nf
     */
    public String getWDLFunctions()
    {
        return "basename; sub; length; range; read_int; read_string; read_float; numerate; select_first; select_all";
    }

    public String getFunctions()
    {
        List<String> result = StreamEx.of( getMandatoryFunctions() ).toList();
        String[] funNames = getWDLFunctions().split( ";" );

        for( String funName : funNames )
        {
            if( isFunctionCalled( funName.trim() ) )
                result.add( funName );
        }
        return StreamEx.of( result ).joining( "; " );
    }

    public boolean isFunctionCalled(String funName)
    {
        for( String value : diagram.recursiveStream().select( Node.class ).map( n -> WorkflowUtil.getExpression( n ) ) )
        {
            if( value != null && value.toString().contains( funName ) )
                return true;
        }

        for( Compartment compartment : diagram.recursiveStream().select( Compartment.class ).filter( c -> WorkflowUtil.isTask( c ) ) )
        {
            String command = WorkflowUtil.getCommand( compartment );
            if( command != null && command.contains( funName ) )
                return true;

            Object before = WorkflowUtil.getBeforeCommand( compartment );
            if( before instanceof ExpressionInfo[] )
            {
                for( ExpressionInfo declaration : (ExpressionInfo[])before )
                {
                    if( declaration.getExpression().contains( funName ) )
                        return true;
                }
            }

        }
        return false;
    }

    public Compartment[] getImportedCalls()
    {
        return WorkflowUtil.getAllCalls( diagram ).stream().filter( c -> WorkflowUtil.getDiagramRef( c ) != null )
                .toArray( Compartment[]::new );
    }

    public String getImportedAlias(Compartment call)
    {
        return WorkflowUtil.getCallName( call );
    }



    public String writePrivateDeclaration(ExpressionInfo declaration)
    {
        String expression = declaration.getExpression();
        expression = expression.replace( "~{", "${" );
        return declaration.getName() + " = " + expression;
    }

    public Object getPrivateDeclarations(Compartment task)
    {
        return super.getBeforeCommand( task );
    }

    /**
     * @return names of all inputs for call which depends on scatter array
     */
    public Set<Node> getArrayDepenedantInputs(String cycleVar, Compartment call)
    {
        Set<Node> result = new HashSet<>();
        List<Node> inputs = WorkflowUtil.getInputs( call );
        for( Node input : inputs )
        {
            if( isArray( cycleVar, input ) )
                result.add( input );
        }
        return result;
    }

    public boolean isArray(String cycleVar, Node input)
    {
        return input.edges().map( e -> e.getInput() ).anyMatch( n -> WorkflowUtil.isCycleVariable( n ) );
    }

    public String getExternalParamaterName(Node input)
    {
        String result = "params." + getName( input );
        if( "File".equals( WorkflowUtil.getType( input ) ) )
            return "file(" + result + ")";
        //        else if( WorkflowUtil.getType( input ).contains( "Array" ) )
        //            return "toChannel(" + result + ").flatten()";
        else
            return result;
    }

    public boolean isNotEmpty()
    {
        return !WorkflowUtil.getAllCalls( diagram ).isEmpty();
    }

    public boolean isEntryScript()
    {
        return isEntryScript;
    }

    public static class CallInfo
    {
        public Compartment compartment;
        public Map<String, String> inputString = new HashMap<>();

        public CallInfo(Compartment compartment)
        {
            this.compartment = compartment;
        }
    }
    
    public List<Compartment> getNamedWorkflows()
    {
        return WorkflowUtil.getWorkflows( diagram );
    }

}
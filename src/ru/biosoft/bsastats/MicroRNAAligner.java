package ru.biosoft.bsastats;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;

import one.util.streamex.EntryStream;
import ru.biosoft.access.core.DataCollection;
import ru.biosoft.access.core.DataElement;
import ru.biosoft.access.core.DataElementPath;
import ru.biosoft.access.FileDataElement;
import ru.biosoft.access.FileImporter;
import ru.biosoft.access.repository.DataElementPathEditor;
import ru.biosoft.access.security.SecurityManager;
import ru.biosoft.access.task.TaskPool;
import ru.biosoft.analysiscore.AnalysisMethodSupport;
import ru.biosoft.bsa.ColorAlphabet;
import ru.biosoft.bsa.LinearSequence;
import ru.biosoft.bsa.Nucleotide5LetterAlphabet;
import ru.biosoft.bsa.Sequence;
import ru.biosoft.bsa.Site;
import ru.biosoft.bsa.Track;
import ru.biosoft.bsa.align.Alignment;
import ru.biosoft.bsa.align.LocalAlignmentScheme;
import ru.biosoft.bsa.align.NeedlemanWunsch;
import ru.biosoft.bsa.align.ScoringScheme;
import ru.biosoft.bsastats.ProcessTasks.FastqSiteWriter;
import ru.biosoft.bsastats.ProcessTasks.SiteWriter;
import ru.biosoft.exception.ExceptionRegistry;
import ru.biosoft.jobcontrol.Iteration;
import ru.biosoft.table.RowDataElement;
import ru.biosoft.table.TableDataCollection;
import ru.biosoft.table.TableDataCollectionUtils;
import ru.biosoft.util.bean.BeanInfoEx2;

public class MicroRNAAligner extends AnalysisMethodSupport<MicroRNAAligner.Parameters>
{
    private static final int CHUNK_SIZE = 10000;

    public MicroRNAAligner(DataCollection<?> origin, String name)
    {
        super( origin, name, new Parameters() );
    }

    @Override
    public Object justAnalyzeAndPut() throws Exception
    {
        TableDataCollection result = TableDataCollectionUtils.createTableDataCollection( parameters.getResults() );
        result.getColumnModel().addColumn( "miRNA", String.class );
        result.getColumnModel().addColumn( "Read", String.class );
        result.getColumnModel().addColumn( "Alignment", String.class );
        result.getColumnModel().addColumn( "Score", Double.class );
        result.getColumnModel().addColumn( "Percent identity", Double.class );

        Map<String, byte[]> miRNASequences = new HashMap<>();
        DataCollection<Site> miRNACollection = parameters.getMiRNASequences().getDataElement(Track.class).getAllSites();
        for( Site miRNA : miRNACollection )
        {
            Sequence miRNAWithAdapter =null;
            if(parameters.isSolidInput())
            {
                miRNAWithAdapter = new LinearSequence(miRNA.getName(),
                        ( "T" + new String( miRNA.getSequence().getBytes() ) + parameters.getAdapter() ),
                        Nucleotide5LetterAlphabet.getInstance() );
                miRNAWithAdapter = ColorAlphabet.translateToColorSpace( miRNAWithAdapter );
            }else
            {
                miRNAWithAdapter = new LinearSequence( miRNA.getName(), new String( miRNA.getSequence().getBytes()).toUpperCase() + parameters.getAdapter(), Nucleotide5LetterAlphabet.getInstance() );
            }

            miRNASequences.put( miRNA.getName(), miRNAWithAdapter.getBytes() );
        }

        ProgressIterator<Task> it = parameters.getTasksIterator();
        long readId = 0;
        Map<String, Task> chunk = new HashMap<>();
        log.info( "Using " + parameters.getThreadCount() + " threads" );
        while( it.hasNext() )
        {
            Task task = it.next();
            readId++;


            String queryName = String.valueOf( readId );
            if(!parameters.isAutoGeneratedQueryNames())
            {
                if(task.getData() != null)
                {
                    if(task.getData() instanceof DataElement)
                        queryName = ((DataElement)task.getData()).getName();
                    else
                        queryName = task.getData().toString().split( "\n" )[0];
                }
            }
            chunk.put( queryName, task );
            if(chunk.size() == CHUNK_SIZE)
            {
                processChunk(chunk, miRNASequences, result);
                chunk.clear();
                jobControl.setPreparedness( (int) ( it.getProgress() * 100 ) );
            }
        }
        if(!chunk.isEmpty())
            processChunk( chunk, miRNASequences, result );
        result.finalizeAddition();
        parameters.getResults().save( result );

        if( unmappedWriter != null )
        {
            unmappedWriter.close();
            new FileImporter().doImport( parameters.getUnmapped().getParentCollection(), unmappedFile, parameters.getUnmapped().getName(), null, log );
            unmappedFile.delete();
        }


        return result;
    }

    private final Map<String, List<ResultElement>> cache = new ConcurrentHashMap<>();

    private void processChunk(final Map<String, Task> chunk, final Map<String, byte[]> miRNASequences, final TableDataCollection table) throws Exception
    {
        final Set<String> mapped = new ConcurrentSkipListSet<>();

        TaskPool.getInstance().iterate( chunk.entrySet(), (Iteration<Entry<String, Task>>)read -> {

            String readSequenceStr = new String( read.getValue().getSequence() ).toUpperCase();
            if( parameters.isSolidInput() )
                readSequenceStr = readSequenceStr.substring( 1 );

            List<ResultElement> results = cache.computeIfAbsent( readSequenceStr, k -> {
                byte[] readSequence = k.getBytes();
                ScoringScheme scoringScheme = new LocalAlignmentScheme( parameters.getMatchScore(), parameters.getMismatchPenalty(),
                        parameters.getGapPenalty() );
                NeedlemanWunsch nw = new NeedlemanWunsch( scoringScheme );
                return EntryStream.of(miRNASequences)
                    .filterValues( miRNASequence -> nw.isScoreBetter( miRNASequence, readSequence, parameters.getAlignmentScoreThreshold() ) )
                    .mapKeyValue( ( name, miRNASequence ) -> {
                        Alignment alignment = nw.findBestAlignment( miRNASequence, readSequence );
                        ScoringScheme errorCountingScheme = new LocalAlignmentScheme( 0, -1, -1 );
                        double errors = -alignment.getScore( errorCountingScheme );
                        double percentIdentity = 1.0 - errors / Math.max( miRNASequence.length, readSequence.length );
                        return new ResultElement( alignment, name, read.getKey(), percentIdentity );
                    }).toList();
            });

            if( !results.isEmpty() )
            {
                if(parameters.getUnmapped() != null)
                    mapped.add( read.getKey() );
                saveResults( results, read.getKey(), table );
            }

            return true;
        }, parameters.getThreadCount() );


        if( parameters.getUnmapped() != null )
            for( Map.Entry<String, Task> entry : chunk.entrySet() )
                if( !mapped.contains(entry.getKey()) )
                    reportUnmapped(entry.getValue());
    }

    private int row = 0;

    private void saveAlignment(ResultElement e, String readName, TableDataCollection table)
    {
        try
        {
            table.addRow( e.asTableRow( String.valueOf( row++ ), table, readName ) );
        }
        catch( Exception t )
        {
            throw ExceptionRegistry.translateException( t );
        }
    }

    private synchronized void saveResults(List<ResultElement> results, String readName, TableDataCollection table)
    {
        for(ResultElement e : results)
            saveAlignment( e, readName, table );
    }


    private SiteWriter<Task> unmappedWriter;
    private File unmappedFile;

    private void reportUnmapped(Task t) throws Exception
    {
        if(unmappedWriter == null)
        {
            unmappedFile = File.createTempFile( "unmapped", ".fastq" );
            unmappedWriter = new FastqSiteWriter( unmappedFile, (byte)33 ) ;
        }
        unmappedWriter.write( t );
    }

    @SuppressWarnings ( "serial" )
    public static class Parameters extends AbstractReadsSourceSelectorParameters
    {
        private DataElementPath miRNASequences, results, unmapped;

        private String adapter = "CGCCTTGGCCGTACAGCAG";//"330201030313112312";
        private double mismatchPenalty = -1, gapPenalty = -1, matchScore = 0, alignmentScoreThreshold = -2;
        private int threadCount = SecurityManager.getMaximumThreadsNumber();

        private boolean autoGeneratedQueryNames = true;

        public Parameters()
        {
            decodeColorSpace = false;
        }

        public DataElementPath getUnmapped()
        {
            return unmapped;
        }
        public boolean isSolidInput()
        {
            return getSource().equals( "Solid" );
        }
        public void setUnmapped(DataElementPath unmapped)
        {
            Object oldValue = this.unmapped;
            this.unmapped = unmapped;
            firePropertyChange( "unmapped", oldValue, unmapped );
        }

        public DataElementPath getMiRNASequences()
        {
            return miRNASequences;
        }

        public void setMiRNASequences(DataElementPath miRNASequences)
        {
            Object oldValue = this.miRNASequences;
            this.miRNASequences = miRNASequences;
            firePropertyChange( "miRNASequences", oldValue, miRNASequences );
        }

        public String getAdapter()
        {
            return adapter;
        }

        public void setAdapter(String adapter)
        {
            Object oldValue = this.adapter;
            this.adapter = adapter;
            firePropertyChange( "adapter", oldValue, adapter );
        }

        public double getMatchScore()
        {
            return matchScore;
        }
        public void setMatchScore(double matchScore)
        {
            Object oldValue = this.matchScore;
            this.matchScore = matchScore;
            firePropertyChange( "matchScore", oldValue, matchScore );
        }

        public double getMismatchPenalty()
        {
            return mismatchPenalty;
        }

        public void setMismatchPenalty(double mismatchPenalty)
        {
            Object oldValue = this.mismatchPenalty;
            this.mismatchPenalty = mismatchPenalty;
            firePropertyChange( "mismatchPenalty", oldValue, mismatchPenalty );
        }

        public double getGapPenalty()
        {
            return gapPenalty;
        }

        public void setGapPenalty(double gapPenalty)
        {
            Object oldValue = this.gapPenalty;
            this.gapPenalty = gapPenalty;
            firePropertyChange( "gapPenalty", oldValue, gapPenalty );
        }

        public double getAlignmentScoreThreshold()
        {
            return alignmentScoreThreshold;
        }

        public void setAlignmentScoreThreshold(double alignmentScoreThreshold)
        {
            Object oldValue = this.alignmentScoreThreshold;
            this.alignmentScoreThreshold = alignmentScoreThreshold;
            firePropertyChange( "alignmentScoreThreshold", oldValue, alignmentScoreThreshold );
        }


        public DataElementPath getResults()
        {
            return results;
        }
        public void setResults(DataElementPath results)
        {
            Object oldValue = this.results;
            this.results = results;
            firePropertyChange( "results", oldValue, results );
        }
        public int getThreadCount()
        {
            return threadCount;
        }

        public void setThreadCount(int threadCount)
        {
            if(threadCount > SecurityManager.getMaximumThreadsNumber())
                threadCount = SecurityManager.getMaximumThreadsNumber();
            Object oldValue = this.threadCount;
            this.threadCount = threadCount;
            firePropertyChange( "threadCount", oldValue, threadCount );
        }


        public boolean isAutoGeneratedQueryNames()
        {
            return autoGeneratedQueryNames;
        }
        public void setAutoGeneratedQueryNames(boolean autoGeneratedQueryNames)
        {
            Object oldValue = this.autoGeneratedQueryNames;
            this.autoGeneratedQueryNames = autoGeneratedQueryNames;
            firePropertyChange( "autoGeneratedQueryNames", oldValue, autoGeneratedQueryNames );
        }

    }

    public static class ParametersBeanInfo extends BeanInfoEx2<Parameters>
    {
        public ParametersBeanInfo()
        {
            super( Parameters.class );
        }

        @Override
        protected void initProperties() throws Exception
        {
            property("source").tags( AbstractReadsSourceSelectorParameters.getSources()).add();
            property( "track" ).inputElement( Track.class ).hidden( "isTrackHidden" ).add();
            property( "fastq" ).inputElement( FileDataElement.class ).hidden( "isFastqHidden" ).add();
            property( "encoding" ).editor( EncodingSelector.class ).hidden( "isFastqHidden" ).add();
            property( "csfasta" ).inputElement( FileDataElement.class ).hidden( "isSolidHidden" ).add();
            property( "qual" ).inputElement( FileDataElement.class ).hidden( "isSolidHidden" ).add();
            property( "miRNASequences" ).inputElement( Track.class ).add();
            add( "adapter" );
            add( "matchScore" );
            add( "mismatchPenalty" );
            add( "gapPenalty" );
            add( "alignmentScoreThreshold" );
            add( "threadCount" );
            add( "autoGeneratedQueryNames" );
            add( DataElementPathEditor.registerOutput( "unmapped", beanClass, FileDataElement.class, true ) );
            add( DataElementPathEditor.registerOutput( "results", beanClass, TableDataCollection.class ) );
        }
    }


    public static class ResultElement
    {
        Alignment alignment;
        String miRNAName;
        double percentIdentity;

        public ResultElement(Alignment alignment, String miRNAName, String readName, double percentIdentity)
        {
            this.alignment = alignment;
            this.miRNAName = miRNAName;
            this.percentIdentity = percentIdentity;
        }

        public RowDataElement asTableRow(String name, TableDataCollection parent, String readName)
        {
            RowDataElement rde = new RowDataElement( name, parent );
            rde.setValues( new Object[] {miRNAName, readName,
                    "<pre style='font-family:monospace'>" + alignment + "</pre>", alignment.getScore(), percentIdentity} );
            return rde;
        }
    }
}

/* Generated By:JJTree: Do not edit this line. AstConstant.java */
package ru.biosoft.math.model;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import one.util.streamex.StreamEx;

/**
 * Function declaration, it corresponds lambda element in MathML.
 *
 * Function declaration syntax is following:
 * <pre>
 * FunctionDeclaration ::= ( "function" Identifier "(" ArgumentDeclaration ( "," ArgumentDeclaration )* ")" <ASSIGNMENT> Expression )
 * </pre>
 *
 * Example:
 * <pre> function f(x, y) = sin(x) + cos(y); </pre>
 *
 * Parser context issues:
 * Linear parser checks whether the function uses declared variables, for this purpose it uses its
 * own parser context.
 */
public class AstFunctionDeclaration extends SimpleNode implements ParserContext, Function
{
    public AstFunctionDeclaration(int id)
    {
        super(id);
    }

    ///////////////////////////////////////////////////////////////////
    // Function interface implimentation:
    //

    /** Function name. */
    private String name;
    @Override
    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }

    @Override
    public int getPriority()
    {
        return FUNCTION_PRIORITY;
    }

    @Override
    public int getNumberOfParameters()
    {
        Set<String> varNames = new HashSet<>();
        for( int i = 0; i < jjtGetNumChildren(); i++ )
        {
            if( jjtGetChild(i) instanceof AstVarNode )
            {
                AstVarNode varNode = (AstVarNode)jjtGetChild(i);
                if( !varNames.contains(varNode.getName()) && !containsConstant(varNode.getName()) )
                    varNames.add(varNode.getName());
            }
            else
                break;
        }
        return varNames.size();
    }
    
    public StreamEx<AstVarNode> getParameters()
    {
        Map<String, AstVarNode> result = new HashMap<>();
        for( int i = 0; i < jjtGetNumChildren(); i++ )
        {
            if( ! ( jjtGetChild(i) instanceof AstVarNode ) )
                break;
            AstVarNode node = (AstVarNode)jjtGetChild(i);
            if( !containsConstant(node.getName()) )
                result.put(node.getName(), node);
        }
        return StreamEx.of(result.values());
    }

    @Override
    public String toString()
    {
        return "Function declaration: " + name;
    }

    ///////////////////////////////////////////////////////////////////
    // Parser context issues:
    //

    ParserContext parent;

    public void init(ParserContext parent)
    {
        this.parent = parent;
    }
    FunctionVariableResolver resolver = new FunctionVariableResolver();
    public VariableResolver getVariableResolver()
    {
        return resolver;
    }

    ///////////////////////////////////////////////////////////////////
    // Constants - we are reusing parent constants
    //

    @Override
    public boolean containsConstant(String name)
    {
        return parent.containsConstant(name);
    }

    @Override
    public Object getConstantValue(String name)
    {
        return parent.getConstantValue(name);
    }

    @Override
    public void declareConstant(String name, Object value)
    {
        throw new UnsupportedOperationException("Function declaration can not declare constants.");
    }
    
    @Override
    public void removeConstant(String name)
    {
        throw new UnsupportedOperationException("Function declaration can not remove constants.");
    }

    ///////////////////////////////////////////////////////////////////
    // Variable - function body uses only variables that were
    // declared in its argument list.
    //

    protected Map<String, Object> variablesMap = new HashMap<>();

    @Override
    public boolean containsVariable(String name)
    {
        return variablesMap.containsKey(name);
    }

    @Override
    public Object getVariableValue(String name)
    {
        return variablesMap.get(name);
    }

    @Override
    public void declareVariable(String name, Object value)
    {
        variablesMap.put(name, value);
    }

    public Node getFunctionBody()
    {
        return jjtGetChild(jjtGetNumChildren() - 1);
    }
    
    ///////////////////////////////////////////////////////////////////
    // Function - we are reusing parent functions
    //

    @Override
    public Function getFunction(String name)
    {
        return parent.getFunction(name);
    }

    @Override
    public void declareFunction(Function function)
    {
        throw new UnsupportedOperationException("Function declaration can not declare internal functions.");
    }

    @Override
    public AstFunctionDeclaration cloneAST()
    {
        AstFunctionDeclaration functionDeclaration = new AstFunctionDeclaration(id);
        functionDeclaration.variablesMap = variablesMap;
        functionDeclaration.name = name;
        functionDeclaration.parent = parent;
        return functionDeclaration;
    }

    @Override
    public boolean equals(Object obj)
    {
        if( this == obj )
            return true;
        if( obj == null )
            return false;
        if( getClass() != obj.getClass() )
            return false;

        final AstFunctionDeclaration other = (AstFunctionDeclaration)obj;
        if( name == null )
        {
            if( other.name != null )
                return false;
        }
        else if( !name.equals(other.name) )
            return false;

        if( parent == null )
        {
            if( other.parent != null )
                return false;
        }
        else if( !parent.equals(other.parent) )
            return false;
        if( variablesMap == null )
        {
            if( other.variablesMap != null )
                return false;
        }
        else if( !variablesMap.equals(other.variablesMap) )
            return false;
        
        return true;
    }

    @Override
    public boolean canDeclare(String value)
    {
        return true;
    }

    public class FunctionVariableResolver implements VariableResolver
    {
        protected int varNameMode;

        @Override
        public String getVariableName(String variableTitle)
        {
            if( containsVariable( variableTitle ) )
                return variableTitle;
            throw new IllegalArgumentException( "Undefined variable " + variableTitle );
        }

        @Override
        public String resolveVariable(String variableName)
        {
            if( containsVariable( variableName ) )
                return variableName;
            throw new IllegalArgumentException( "Undefined variable " + variableName );
        }

    }

}

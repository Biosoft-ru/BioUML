/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. UnitParser.jj */
/*@egen*//***************************************************************
 OPTIONS
 ***************************************************************/

options
{
                 
                             
    STATIC = false;

                       
}

PARSER_BEGIN(UnitParser)
package ru.biosoft.math.unitparser;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.io.StringReader;

public class UnitParser/*@bgen(jjtree)*/implements UnitParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTUnitParserState jjtree = new JJTUnitParserState();

/*@egen*/
    private static Logger log = Logger.getLogger( UnitParser.class.getName() );
    public UnitParser()
    {
        this (new StringReader("0"));
    }
    public AstStart parse(String expression) throws ParseException
        {
            AstStart astStart;
            ReInit( new StringReader(expression) );
            astStart = Start();
            return astStart;

        }



}


PARSER_END(UnitParser)

/***************************************************************
 SKIP
 ***************************************************************/

SKIP :
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
 TOKENS
 ***************************************************************/

TOKEN : /* LITERALS */
{
    < INTEGER_LITERAL: <DECIMAL_LITERAL> >
    |
    < #DECIMAL_LITERAL: (<MINUS>)? ["0"-"9"] (["0"-"9"])* >
    |
    < FLOATING_POINT_LITERAL: (<MINUS>)?
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
        | "." (["0"-"9"])+ (<EXPONENT>)?
        | (["0"-"9"])+ <EXPONENT>
    >
    |
    < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}



TOKEN : /* IDENTIFIERS */
{
< TYPE: ("ampere"| "gram" | "katal" | "metre" | "second" | "watt" | "becquerel"| "gray"
        | "kelvin" | "mole" | "siemens" | "weber" |"candela" | "henry" | "kilogram" | "newton"
        | "sievert" | "coulomb" | "hertz" | "litre" | "ohm" | "steradian" | "dimensionless"
        | "item" | "lumen"|  "pascal" | "tesla" | "farad" | "joule" | "lux" | "radian" | "volt")>
}

/* OPERATORS */
TOKEN:
{
    < PLUS: "+"  >
    |       < MINUS:"-"  >
    |       < MUL:  "*"  >
    |       < DIV:  "/"  >
    |       < POWER:"^"  >
}

/***************************************************************
 GRAMMAR START
 ***************************************************************/

AstStart Start()        :
{/*@bgen(jjtree) Start */
  AstStart jjtn000 = new AstStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    MultiplicativeExpression()

    (";")?
    <EOF>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}


/***************************************************************
 EXPRESSION
 ***************************************************************/

 void MultiplicativeExpression() :
 {
 }
 {

   UnitOrUnaryExpression()

   (/*@bgen(jjtree) #FunNode( 2) */
     {
       AstFunNode jjtn001 = new AstFunNode(JJTFUNNODE);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
     }
     try {
/*@egen*/
     ( <MUL> UnitOrUnaryExpression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtc001 = false;
       }
/*@egen*/
       {
         jjtn001.setOperator("*");
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte001) {
       if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         throw (RuntimeException)jjte001;
       }
       if (jjte001 instanceof ParseException) {
         throw (ParseException)jjte001;
       }
       throw (Error)jjte001;
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  2);
       }
     }
/*@egen*/            
         |/*@bgen(jjtree) #FunNode( 2) */
     {
       AstFunNode jjtn002 = new AstFunNode(JJTFUNNODE);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
     }
     try {
/*@egen*/
     (
     <DIV> UnitOrUnaryExpression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn002,  2);
         jjtc002 = false;
       }
/*@egen*/
       {
         jjtn002.setOperator("/");
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte002) {
       if (jjtc002) {
         jjtree.clearNodeScope(jjtn002);
         jjtc002 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte002 instanceof RuntimeException) {
         throw (RuntimeException)jjte002;
       }
       if (jjte002 instanceof ParseException) {
         throw (ParseException)jjte002;
       }
       throw (Error)jjte002;
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002,  2);
       }
     }
/*@egen*/            
   )*
 }

void UnitOrUnaryExpression() :
{Token t;}
 {
        LOOKAHEAD(12)/*@bgen(jjtree) #UnitNode( 2) */
         {
           AstUnitNode jjtn001 = new AstUnitNode(JJTUNITNODE);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/
         (MultiplicativeConstantExpression()
         MultiplicativeTypeExpression())/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/             
         |
         ParenthesesExpression()
 }


 void ParenthesesExpression() : {}
 {
    "(" MultiplicativeExpression() ")"
    [/*@bgen(jjtree) #FunNode( 2) */
       {
         AstFunNode jjtn001 = new AstFunNode(JJTFUNNODE);
         boolean jjtc001 = true;
         jjtree.openNodeScope(jjtn001);
       }
       try {
/*@egen*/
       ( <POWER> UnaryConstantExpression()/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn001,  2);
           jjtc001 = false;
         }
/*@egen*/
         {
           jjtn001.setOperator("^");
         }
       )/*@bgen(jjtree)*/
       } catch (Throwable jjte001) {
         if (jjtc001) {
           jjtree.clearNodeScope(jjtn001);
           jjtc001 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte001 instanceof RuntimeException) {
           throw (RuntimeException)jjte001;
         }
         if (jjte001 instanceof ParseException) {
           throw (ParseException)jjte001;
         }
         throw (Error)jjte001;
       } finally {
         if (jjtc001) {
           jjtree.closeNodeScope(jjtn001,  2);
         }
       }
/*@egen*/            
       ]
 }

/***************************************************
* CONSTANT EXPRESSION
****************************************************/
void MultiplicativeConstantExpression() :
{
}
{
    PowerConstantExpression()
    (/*@bgen(jjtree) #FunNode( 2) */
        {
          AstFunNode jjtn001 = new AstFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( <MUL> PowerConstantExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtc001 = false;
        }
/*@egen*/
        {
            jjtn001.setOperator("*");
        }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/            
        |/*@bgen(jjtree) #FunNode( 2) */
        {
          AstFunNode jjtn002 = new AstFunNode(JJTFUNNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        ( <DIV> PowerConstantExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002,  2);
          jjtc002 = false;
        }
/*@egen*/
        {
            jjtn002.setOperator("/");
        }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/            
    )*
}




 void PowerConstantExpression() :
 {
 }
 {
     UnaryConstantExpression()
     [
     LOOKAHEAD(2)/*@bgen(jjtree) #FunNode( 2) */
         {
           AstFunNode jjtn001 = new AstFunNode(JJTFUNNODE);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/
         ( <POWER>   UnaryConstantExpression()/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn001,  2);
           jjtc001 = false;
         }
/*@egen*/
         {
         jjtn001.setOperator("^");
         }
         )/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/            
     ]
 }
 void UnaryConstantExpression() :
 {
 }
 {
     RealConstant()
     |
     ParenthesesConstantExpression()
 }

 void ParenthesesConstantExpression() :
 {}
 {
    "(" MultiplicativeConstantExpression() ")"
 }

void RealConstant()          :
{/*@bgen(jjtree) Constant */
AstConstant jjtn000 = new AstConstant(JJTCONSTANT);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t;
Number value;
}
{/*@bgen(jjtree) Constant */
    try {
/*@egen*/
    (t=<INTEGER_LITERAL>
    {
        try
        {
            value = new Integer(t.image);
        }
        catch (Exception e)
        {
            value = null;
            log.log(Level.SEVERE, "Can't parse \"" + t.image + "\"");
        }
        jjtn000.setValue(value);

    }
    |
    t=<FLOATING_POINT_LITERAL>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        try
        {
        value = new Double(t.image);
        }
        catch (Exception e)
        {
        value = null;
        log.log(Level.SEVERE, "Can't parse \"" + t.image + "\"");
        }
        jjtn000.setValue(value);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
/***************************************************
* TYPE EXPRESSION
****************************************************/
void MultiplicativeTypeExpression() :
{
}
{
    PowerTypeExpression()
    ( LOOKAHEAD(2) (/*@bgen(jjtree) #FunNode( 2) */
        {
          AstFunNode jjtn001 = new AstFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( <MUL> PowerTypeExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtc001 = false;
        }
/*@egen*/
        {
            jjtn001.setOperator("*");
        }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/            
        |/*@bgen(jjtree) #FunNode( 2) */
        {
          AstFunNode jjtn002 = new AstFunNode(JJTFUNNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        ( <DIV> PowerTypeExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002,  2);
          jjtc002 = false;
        }
/*@egen*/
        {
            jjtn002.setOperator("/");
        }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/            )
    )*
}
void PowerTypeExpression() :
{
Token t;
}
{
    Type()
    [
    LOOKAHEAD(2)/*@bgen(jjtree) #FunNode( 2) */
        {
          AstFunNode jjtn001 = new AstFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (
        <POWER> UnaryConstantExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
            jjtn001.setOperator("^");
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/            
    ]

}


void Type()      :
{/*@bgen(jjtree) Type */
 AstType jjtn000 = new AstType(JJTTYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    t = <TYPE> ("s")?/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setValue(t.image);}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
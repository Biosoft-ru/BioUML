var keyHooker = {
	addListener: function() {}	
};// This mystical line forces correct obfuscator behavior
Function.prototype.dummy = null;

function isFF()
{
    return navigator.userAgent.indexOf("Firefox") > 0 || navigator.userAgent.indexOf("Iceweasel") > 0;
}

function isIE()
{
    return ( navigator.userAgent.indexOf("MSIE") > 0 && navigator.userAgent.indexOf("Opera") < 0 ) || navigator.userAgent.indexOf("Trident/") > 0;
}

function createPopupDiv( id )
{
    var div = document.createElement('div');
    div.id = id;
    div.style.position = "absolute";
    div.style.textAlign = "right";
    div.style.color = "black";
    div.style.backgroundColor = "white";
    div.style.zIndex = "10000";
    div.style.fontFamily ="Arial";
    div.style.fontSize = "10pt";
    div.style.padding = "10px";
    div.style.border = "2px solid black";
    div.style.borderRadius = "4px";
    div.style["-moz-border-radius"] = "4px";
    div.style["-webkit-border-radius"] = "4px";
    div.style["box-shadow"] = "gray 7px 7px 8px";
    div.style["-webkit-box-shadow"] = "7px 7px 8px gray";
    div.style["-moz-box-shadow"] = "7px 7px 8px gray";
    return div;
}

Logger = null;

var initLogSettingsUI = function()
{
    var keyListener =  function( e )
    {
        if( !e ) e = window.event;
        if( !e.ctrlKey || !e.altKey || !e.shiftKey || e.keyCode != 76 ) // Ctrl-Alt-Sfift - L
        {
            return true;
        }
        // init log settings div
        var backDiv = document.getElementById( "_logging_div_" );
        if( !backDiv )
        {
            var logDiv = createPopupDiv( "_logging_div_" );
            logDiv.style.top = "6px";
            logDiv.style.left = "6px";

            var addOption = function( box, name )
            {
                var option = document.createElement("option");
                option.value = name;
                option.innerHTML = name;
                box.appendChild( option );
            };

            // add log level selector
            logDiv.innerHTML = "Log level:";
            var logLevelBox = document.createElement("select");
            logLevelBox.id = "_log_level_box";
            logLevelBox.style.width = "100px";
            addOption( logLevelBox, "NONE" );
            addOption( logLevelBox, "DEBUG" );
            addOption( logLevelBox, "INFO" );
            addOption( logLevelBox, "WARN" );
            addOption( logLevelBox, "ERROR" );
            addOption( logLevelBox, "FATAL" );
            logDiv.appendChild( logLevelBox );
            logDiv.innerHTML += "<br>";

            // add log method selector
            logDiv.innerHTML += "Log method:";
            var logMethodBox = document.createElement("select");
            logMethodBox.id = "_log_method_box";
            logMethodBox.style.width = "100px";
            addOption( logMethodBox, "writeLogger" );
            addOption( logMethodBox, "consoleLogger" );
            addOption( logMethodBox, "popupLogger" );
            addOption( logMethodBox, "alertLogger" );
            logDiv.appendChild( logMethodBox );
            logDiv.innerHTML += "<br>";

            // add Apply button
            var buttonDiv = document.createElement('div');
            buttonDiv.style.width = "100%";
            buttonDiv.style.paddingTop = "5px";
            buttonDiv.style.textAlign = "center";
            var button = document.createElement("input");
            button.style.marginRight = "5px";
            button.type = "button";
            button.value = "Apply";
            button.onclick = function()
            {
                var mainWindow = window.opener != null ? window.opener.top : window;
                mainWindow._log_level = document.getElementById( "_log_level_box" ).value;
                mainWindow._log_method = document.getElementById( "_log_method_box" ).value;
                initLogger( mainWindow._log_level, mainWindow._log_method );
                logDiv.style.visibility = "hidden";
            }
            buttonDiv.appendChild( button );
            // add Cancel button
            button = document.createElement("input");
            button.style.marginLeft = "5px";
            button.type = "button";
            button.value = "Cancel";
            button.onclick = function()
            {
                logDiv.style.visibility = "hidden";
            }
            buttonDiv.appendChild( button );

            logDiv.appendChild( buttonDiv );
            document.body.appendChild( logDiv );
        }
        else
        {
            backDiv.style.visibility = "visible";
        }
        var mainWindow = window.opener != null ? window.opener.top : window;
        if( mainWindow._log_level )
        {
            document.getElementById( "_log_level_box" ).value = mainWindow._log_level;
        }
        if( mainWindow._log_method )
        {
            document.getElementById( "_log_method_box" ).value = mainWindow._log_method;
        }
    };
    if( document.addEventListener )
    {
        document.addEventListener("keydown", keyListener, false);
    }
    else if( document.attachEvent )
    {
        document.attachEvent("onkeydown", keyListener );
    }
    else
    {
        document.onkeydown = keyListener;
    }
    var mainWindow = window;
    try
    {
        var newMainWindow = window.opener != null ? window.opener.top : window;
        var testLogLevel = newMainWindow._log_level;
        var testLogMethod = newMainWindow._log_method;
        mainWindow = newMainWindow;
    }
    catch( e ) // catch Exception in IE
    {
    }
    if( mainWindow._log_level && mainWindow._log_method )
    {
        initLogger( mainWindow._log_level, mainWindow._log_method );
    }
};

initLogSettingsUI();

var initSelectionSumUI = function()
{
    if( !window.M_SUM_MESSAGE )
    {
        return;
    }
    var selectedElements = [];
    var selectedElementBackgrounds = {};

    var restoreElements =  function()
    {
        for( var i in selectedElements )
        {
            var element = selectedElements[i];
            if( element && element.style )
                element.style.background = selectedElementBackgrounds[ element ];
        }
        selectedElements = [];
        selectedElementBackgrounds = {};
    }

    var mouseListener =  function( e )
    {
        if( !e ) e = window.event;
        if( !e.ctrlKey  )
        {
            if( selectedElements.length > 0 )
            {
                restoreElements();
                var sumDiv = document.getElementById( "_sum_div_" );
                if( sumDiv != null )
                {
                    sumDiv.style.visibility = "hidden";
                }
                var sumBox = document.getElementById( "_sum_box_" );
                if( sumBox != null )
                {
                    sumBox.innerHTML = 0;
                }
            }
            return true;
        }
        // save element and and its background
        var element = e.target ? e.target : e.srcElement;
        if( selectedElements.indexOf && selectedElements.indexOf( element ) > -1 ) // element already selected
        {
            return true;
        }
        selectedElements[ selectedElements.length ] = element;
        selectedElementBackgrounds[ element ] = element.style.background;
        element.style.background = "coral";
        sumDiv = document.getElementById( "_sum_div_" );
        if( !sumDiv ) // create sum div
        {
            sumDiv = createPopupDiv( "_sum_div_" );
            sumDiv.innerHTML += window.M_SUM_MESSAGE + ": ";
            sumBox = document.createElement("b");
            sumBox.id = "_sum_box_";
            sumBox.innerHTML = 0;
            sumDiv.appendChild( sumBox );

            document.body.appendChild( sumDiv );
        }
        sumDiv.style.bottom = "6px";
        sumDiv.style.right = "6px";
        sumDiv.style.visibility = "visible";
        // calculate and display sum
        var sum = new Number( document.getElementById( "_sum_box_" ).innerHTML );
        try
        {
            var val = element.value ? element.value : element.innerHTML ;
            val = val.replace( "&nbsp;", "" ).replace( /,/, "." ).replace( /[\s]+/g, "" );
            var num = parseFloat( val );
            if( !isNaN( num ) )
            {
                sum += num;
                sum = new Number( sum.toFixed(10) );
            }
        }
        catch( ex )
        {
        }
        document.getElementById( "_sum_box_" ).innerHTML = sum;
    };
    if( document.addEventListener )
    {
        document.addEventListener("mouseup", mouseListener, false);
    }
    else if( document.attachEvent )
    {
        document.attachEvent("onmouseup", mouseListener );
    }
    else
    {
        document.onmouseup = mouseListener;
    }
};

initSelectionSumUI();

function loadScript( scriptUrl, okCallback, errorCallback )
{
    if( typeof( jQueryPath ) != 'undefined' && scriptUrl == jQueryPath && typeof( jQuery ) != 'undefined' )
    {
        if( okCallback )
        {
            okCallback();
        }
        return;
    }

    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.lang = 'JavaScript';
    script.src = scriptUrl;
    if( isIE() )
    {
        var head = document.getElementsByTagName('head')[0];
        var done = false;
        // Attach handlers for all browsers
        script.onload = script.onreadystatechange = function()
        {
            try
            {
                if( !done && (!script.readyState || script.readyState === "loaded" || script.readyState === "complete") )
                {
                    done = true;
                    if( okCallback )
                    {
                        okCallback();
                    }
                    // Handle memory leak in IE
                    script.onload = script.onreadystatechange = null;
                    if( head && script.parentNode )
                    {
                        head.removeChild( script );
                    }
                }
            }
            catch( e )
            {
                if( errorCallback )
                {
                    errorCallback( e );
                }
            }
        };
        // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
        // This arises when a base node is used (#2709 and #4378).
        head.insertBefore( script, head.firstChild );
    }
    else // if FF or Opera
    {
        script.onerror = function()
        {
            if( errorCallback )
            {
                errorCallback();
            }
        }
        script.onload = function()
        {
            if( okCallback )
            {
                okCallback();
            }
        }

        document.getElementsByTagName('head')[0].appendChild(script);
    }
}

function loadCSS4jQuery( url )
{
    if( document.createStyleSheet )
    {
        document.createStyleSheet( url );
    }
    else
    {
        jQuery( 'head' ).append( jQuery( '<link rel="stylesheet" type="text/css" />' ).prop( 'href', url ) );
    }
}

function loadPlugin( name, okCallback, errorCallback )
{
    if( name == "autocomplete" )
    {
        loadScript( "lib/jquery-plugins/autocomplete/jquery.autocomplete.min.js", okCallback, errorCallback );
    }
    else if( name == "chosen" )
    {
        loadScript( "lib/jquery-plugins/chosen/chosen.jquery.min.js", okCallback, errorCallback );
        loadCSS4jQuery( "lib/jquery-plugins/chosen/chosen.min.css" );
    }
    else if( name == "vipnet" )
    {
        loadScript( "lib/jquery.vipnet.js", okCallback, errorCallback );
    }
    else if( name == "select2" )
    {
        loadScript( "lib/jquery-plugins/select2/select2.min.js", okCallback, errorCallback );
        loadCSS4jQuery( "lib/jquery-plugins/select2/select2.ccs" );
    }
    else if( name == "typeahead" )
    {
        loadScript( "lib/jquery-plugins/typeahead/hogan.min.js" );
        loadScript( "lib/jquery-plugins/typeahead/typeahead.min.js", okCallback, errorCallback );
    }
}

function initLogger( level, type )
{
    if( !window.Log )
    {
        var url = "log4js-mini.js";
        loadScript( url, function()
        {
            createLogger( level, type );
        }, null );
    }
    else
    {
        createLogger( level, type );
    }
}

function createLogger( level, type )
{
    var defLogFunc = function( msg, level )
    {
        var elem = document.createElement('div');

        var d = new Date();
        var h = d.getHours();
        if (h<10) { h="0"+h; }
        var m = d.getMinutes();
        if (m<10) { m="0"+m; }
        var s = d.getSeconds();
        if (s<10) { s="0"+s; }
        var date = d.getFullYear()+"-"+(d.getMonth()+1)+"-"+d.getDate()+"&nbsp;"+h+":"+m+":"+s;

        elem.innerHTML = date + "&nbsp;-&nbsp;" + level + "&nbsp;-&nbsp;" + msg + "<br />";
        document.body.appendChild( elem );
    };

    Logger = new Log( eval( "Log." + level ), eval( "Log." + type ) ? eval( "Log." + type ) : defLogFunc, null );
}

var __BE_IND_ID = '__BE_loading_indicator';

var __BE_updateIndicatorPosition = function()
{
    var elem = document.getElementById(__BE_IND_ID);
    if( elem )
    {
        elem.style.left = "" + ( document.body.clientWidth - 75 ) + "px";
    }
};

function __BE_showLoading()
{
    var elem = document.getElementById(__BE_IND_ID);
    var width = 75;
    if( !elem )
    {
        elem = document.createElement('div');
        elem.id = __BE_IND_ID;
        elem.innerHTML = window.M_PROCESSING_MESSAGE + "...";
        elem.style.fontSize = '11';
        elem.style.fontFamily = "verdana, ms sans serif, arial, sans-serif";
        elem.style.position = 'absolute';
        elem.style.top = "0px";
        elem.style.height = "14px";
        elem.style.background = '#FF5500';
        elem.style.color = 'white';
        elem.style.width = width;
        var body = document.getElementsByTagName("body").item(0);
        body.appendChild(elem);
        if( isIE() )
        {
            var f = window.onresize;
            window.onresize = f ? function( e )
            {
                f( e );
                __BE_updateIndicatorPosition();
            } : __BE_updateIndicatorPosition;
        }
        else
        {
            window.addEventListener('resize', __BE_updateIndicatorPosition, false);
        }
    }
    elem.style.left = "" + ( document.body.clientWidth - width ) + "px";
    elem.style.display = 'block';
}

function __BE_hideLoading()
{
    var elem = document.getElementById(__BE_IND_ID);
    if( elem != null )
    {
        elem.style.display = 'none';
    }
}

/*requestCounter = 0;*/

function getUniqueId()
{
    if(!getUniqueId.counter)
        getUniqueId.counter = 1;

    return new Date().getTime() + '_' + getUniqueId.counter++;
}

/**
 * pass additional parameters in "params" object
 * params.varName - result array variable name
 * params.params - additional URL parameters
 * params.listener - listener of successfull processing event
 * params.timeout - Timeout value (default is 10 seconds)
 * params.timeoutListener - listener of timeout expiration event (alert by default)
 * params.errorListener - listener of processing error event  (alert by default)
 */
function invokeRemoteMethod( methodName, inUrl, params )
{
    var invokeOldStyle = false;
    var jsCardSettings = window.systemSettings && window.systemSettings.ATTRIBUTES_module ? 
           window.systemSettings.ATTRIBUTES_module : {};

    if( jsCardSettings.JQUERY_INVOKEREMOTEMETHOD !== undefined )
    {
        invokeOldStyle = jsCardSettings.JQUERY_INVOKEREMOTEMETHOD !== 'true';
    }
    
    // to avoid multiple params checking
    var pp = params ? params : { };

    var url = inUrl;

    var varName = pp.varName;
    if( invokeOldStyle || !varName && (/^\w+\:\/\//.test(inUrl) || !window.jQuery) )
    {
        invokeOldStyle = true;
        varName = 'v' + getUniqueId();
    }
    else if( varName )
    {
        invokeOldStyle = true;
        varName = varName + getUniqueId();
    }

    var sep = (url.indexOf('?') == -1) ? '?' : '&';

    var enc = pp.encoding ? pp.encoding : null;
    url += sep+'_enc_=' + encodeURIComponent(enc ? enc : "UTF-8");

    if( varName )
    {
        url += '&_jsvar_=' + encodeURIComponent(varName);
    }

    if( pp.search )
    {
        url += '&_search_=true';
    }
    if( pp.limit )
    {
        url += '&_jslimit_=' + encodeURIComponent(pp.limit);
    }
    if( pp.colNames )
    {
        url += '&_jscolnames_=' + encodeURIComponent(pp.colNames);
    }
    if( pp.urlPrefix )
    {
        url = pp.urlPrefix + url;
    }

    var p = pp.params;
    if( p )
    {
        for( var i = 0; i < p.length; i++ )
        {
            var par = p[i];
            if( par && par[ 0 ] )
            {
                url += "&" + encodeURIComponent( par[ 0 ] ) + "=" + ( par[ 1 ] ? encodeURIComponent( par[ 1 ] ) : "" );
            }
        }
    }

    // set 10 seconds as default timeout
    var timeout = pp.timeout ? pp.timeout : 10000;
    var endTime = new Date().getTime() + timeout;

    var doNotShowLoading = pp.doNotShowLoading ? pp.doNotShowLoading : false;

    var isDone = false;

    /*requestCounter++;*/

    var successHandler = function( data )
    {
        __BE_hideLoading();
        isDone = true;
        try
        {
            if( pp.listener )
            {
                pp.listener( data );
            }
        }
        catch( e )
        {
            alert("Error in params.listener! " + e + e.stack);
        }
        /*requestCounter--;*/
    } 

    var errorHandler = function()
    {
        __BE_hideLoading();
        isDone = true;
        if( pp.errorListener )
        {
            pp.errorListener();
        }
        else
        {
            alert("Error in " + methodName + " (old style=" + invokeOldStyle + ")!");
        }
        /*requestCounter--;*/
    };

    if( invokeOldStyle )
    {
        // Old style: probably useful for cross-site requests
        loadScript( url, function() { successHandler( window[varName] ); }, errorHandler );
    } // old BE way
    else if( false && window.fetch )
    {
        // tribute to IE8: ["catch"] is used instead of .catch( 
        fetch( url, { method: 'get' }).then( function (response) 
        {
           var json = response.json(); 
           return json;
        }).then( successHandler )["catch"]( errorHandler ); 
    } // fetch
    else
    {
        var jparams = {
            dataType: 'json',
            type: 'GET',
            success: successHandler,
            error: errorHandler
        };

        if( pp.async !== undefined )
        {
            jparams.async = pp.async;
        }

        if( jsCardSettings.ASYNC_INVOKEREMOTEMETHOD !== undefined )
        {
            jparams.async = jsCardSettings.ASYNC_INVOKEREMOTEMETHOD === 'true';
        }

        jQuery.ajax( url, jparams );
    } // jQuery way

    if( !doNotShowLoading )
    {
        __BE_showLoading();
    }

    var timer = window.setInterval(
        function()
        {
            if( isDone )
            {
                clearInterval(timer);
                return;
            }

            if( new Date().getTime() > endTime )
            {
                clearInterval(timer);
                __BE_hideLoading();
                if( pp.timeoutListener )
                {
                    pp.timeoutListener()
                }
                else
                {
                    alert('Timeout occured in "' + methodName + '"!');
                }
                /*requestCounter--;*/
                return;
            }
        }, 100);
}

function calcUsingQueryId( queryId, params )
{
    var url = "calcUsingQuery?_q_=" + encodeURIComponent(queryId);
    invokeRemoteMethod("calcUsingQuery", url, params );
}

function calcUsingQuery( entity, queryName, params )
{
    var url = "calcUsingQuery?_t_=" + encodeURIComponent(entity) + "&_qn_=" + encodeURIComponent(queryName);
    invokeRemoteMethod("calcUsingQuery", url, params );
}

function applyTagsToSelect( oSelect, tags, msgForNull, selectedOption )
{
    if( oSelect == undefined )
    {
        return;
    }
    if( !selectedOption )
    {
        selectedOption = oSelect.value;
    }

    oSelect.options.length = 0;
    if( !tags )
        return;

    if( oSelect.className != "notNull" )
    {
        if( !msgForNull )
        {
            msgForNull = "";
        }
        var defaultOption = document.createElement("OPTION");
        oSelect.options.add(defaultOption);
        defaultOption.value = "";
        defaultOption.text = defaultOption.innerText = msgForNull;
        if ('' === selectedOption)
        {
            defaultOption.selected = true;
        }
    }
    for( var i in tags )
    {
        var tag = tags[ i ];
        var oOption = document.createElement( "OPTION" );
        oSelect.options.add( oOption );
        oOption.value = tag[ 0 ];
        oOption.text = oOption.innerText = tag.length > 1 ? tag[ 1 ] : tag[ 0 ];

        if( tags[ i ][ 2 ] )
        {
           oOption.setAttribute("style", tags[ i ][ 2 ]);
        }

        if (tag[ 0 ] == selectedOption)
        {
            oOption.selected = true;
        }
    }

    if( jQuery && jQuery.fn.chosen )
    {
        jQuery("#" + oSelect.id).trigger("chosen:updated");
    }
}


function Utils_insert( entity, values, params )
{
    var pp = params ? params : {};
    pp.params = values;
    var url = "Utils.insert?_t_=" + encodeURIComponent(entity);
    invokeRemoteMethod( "Utils.insert", url, pp );
}

function Utils_update( entity, records, values, params )
{
    var pp = params ? params : {};
    pp.params = values;
    var url = "Utils.update?_t_=" + encodeURIComponent(entity);
    for( var i = 0; i < records.length; i++ )
    {
        url += "&_rec_" + encodeURIComponent(records[ i ]) + "=1";
    }

    invokeRemoteMethod( "Utils.update", url, pp );
}

function Utils_delete( entity, records, params )
{
    var url = "Utils.delete?_t_=" + encodeURIComponent(entity);
    for( var i = 0; i < records.length; i++ )
    {
        url += "&_rec_" + encodeURIComponent(records[ i ]) + "=1";
    }

    invokeRemoteMethod( "Utils.delete", url, params );
}

function invokeOperation( entity, opName, params )
{
    var url = "ops?_t_=" + encodeURIComponent(entity) + "&_on_=" + encodeURIComponent(opName);

    invokeRemoteMethod( "ops", url, params );
}

function invokeServlet( servletName, params )
{
    invokeRemoteMethod( servletName, servletName, params );
}

function getDistinctValues( entity, queryName, columns, params )
{
    var url = "distinctValues?_t_=" + encodeURIComponent(entity) + "&_qn_=" + encodeURIComponent(queryName);
        if (columns.length)
        {
            for( var i in columns )
                {
                        url += "&_f_=" + encodeURIComponent(columns[i]);
                }
        }
        else
        {
                url += "&_f_=" + encodeURIComponent(columns);
        }
    invokeRemoteMethod( "distinctValues", url, params );
}

function getSessionVar( varName, params )
{
    var pp = params ? params : {};
    var url = "getSessionVar?_js_svname_=" + encodeURIComponent(varName);
    invokeRemoteMethod( "getSessionVar", url, pp );
}

function setSessionVar( varName, varValue, params )
{
    var pp = params ? params : {};
    var url = "setSessionVar?_js_svname_=" + encodeURIComponent(varName) +
         "&_js_svval_=" + encodeURIComponent(varValue);
    invokeRemoteMethod( "setSessionVar", url, pp );
}

function removeSessionVar( varName, params )
{
    var pp = params ? params : {};
    var url = "setSessionVar?_js_svname_=" + encodeURIComponent(varName) +
         "&_js_svval_=";
    invokeRemoteMethod( "setSessionVar", url, pp );
}

function initAsyncCalcs( maxParallel )
{
    var elements = jQuery( "div.asyncCalc" );
    maxParallel = ( maxParallel < elements.length ? maxParallel : elements.length );
    for( var i = 0; i < maxParallel; i++ )
    {
        asyncCalc( elements, i, maxParallel );
    }
}

function asyncCalc( elements, pos, step )
{
    var jQueryEl = jQuery( elements[ pos ] );
    jQueryEl.html( " " );
    jQueryEl.addClass('spinner');

    var url = "calcUsingQuery";
    var entity = jQueryEl.prop( "be-table" );
    var queryName = jQueryEl.prop( "be-queryName" );
    var using = jQueryEl.prop( "be-using" );
    var columns = jQueryEl.prop( "be-columns" );
    var result = jQueryEl.prop( "be-result" );

    var params = {};   
    params[ "_enc_" ] = "UTF-8";
    params[ "_json_" ] = "json";
    params[ "_t_" ] = entity;
    params[ "_qn_" ] = queryName;
    
    var cols = columns.split( "," );
    var vals = using.split( "," );
    for( var i = 0; i < cols.length; i++ )
    {
        params[ cols[ i ] ] = vals[ i ];
    }

    jQuery.ajax({
        url: url,
        type: "GET",
        async:true,
        data: params,
        cache: false,
        dataType: "json",
        success: function(data)
        {
            jQueryEl.removeClass('spinner');
            jQueryEl.html( data[ 0 ][ result ] );
            if( pos + step < elements.length )
            {
                asyncCalc( elements, pos + step, step );
            }
        },
        error: function()
        {
            jQueryEl.removeClass('spinner');
            jQueryEl.html( 'ERROR' );
            if( pos + step < elements.length )
            {
                asyncCalc( elements, pos + step, step );
            }
        }
    });
}


function hideColumnAndColumnSettings(column, column_name, value)
{
    if( !window.queryID || window.queryID == "0" )
    {
        window.hideColumn(column, value);
        return;
    }

    var pp = { listener: function( ret ) { /* query2.js */ window.hideColumn(column, value); } };
    var url = "quick?quick=" + ( value ? "yes" : "no" ) +
         "&column_name=" + encodeURIComponent( column_name ) +
         "&queryID=" + window.queryID;
    invokeRemoteMethod( "quick", url, pp );
}


var __BE_SEL_LIST = '__BE_selection_list';

var __BE_findPos = function(obj)
{
    var curleft = 0;
    var curtop = 0;
    if( obj.offsetParent )
    {
        curleft = obj.offsetLeft;
        curtop = obj.offsetTop;
        while( obj = obj.offsetParent )
        {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        }
    }
    return [ curleft, curtop ];
};

var isIncompleteSelectionControl = function( selElem )
{
    var pattern = new RegExp( "notstrict", "i" );
    return pattern.test( selElem.name );
};

var __BE_changeSelection = function(oSelect, selElem)
{
    if( Logger ) Logger.debug( "changeSelection = '" + selElem.value + "'" );

    var record = null;
    if( oSelect )
    {
        if( !isIncompleteSelectionControl( selElem ) || oSelect.selectedIndex >= 0 )
        {
            selElem.value = oSelect.options[ oSelect.selectedIndex ].__BE_displayName;
            selElem.__BE_storeElement.value = oSelect.value;
            record = oSelect.options[ oSelect.selectedIndex ].__BE_record;
        }
        else if( isIncompleteSelectionControl( selElem ) )
        {
            selElem.__BE_storeElement.value = selElem.value;
        }
    }
    else
    {
       selElem.value = "";
       selElem.__BE_storeElement.value = "";
    }

    if( typeof window.customChangeSelectionHandler == 'function' )
        window.customChangeSelectionHandler( selElem.__BE_storeElement, record );
};

var __BE_hideSelection = function( selElem )
{
    var elem = document.getElementById(selElem.__BE_SEL_LIST);
    if( elem )
    {
        elem.style.display = "none";
    }
};

var __BE_justShowSelection = function( selElem )
{
    var elem = document.getElementById(selElem.__BE_SEL_LIST);
    if( elem )
    {
        elem.style.display = "";
    }
};

var __BE_finalizeSelection = function (selElem, isJustHide )
{
    if( Logger ) Logger.debug( "finalize: selElem.value = '" + selElem.value + "'" );

    if( selElem.value )
    {
        var oSelect = document.getElementById( selElem.__BE_listControlName );
        if( oSelect && oSelect.selectedIndex < 0 && oSelect.options.length > 0 )
        {
            if( !isIncompleteSelectionControl( selElem ) )
            {
                oSelect.value = oSelect.options[ 0 ].value;
            }
            __BE_changeSelection(oSelect, selElem);

        }
        else if( oSelect.options.length < 1 )
        {
            if( isIncompleteSelectionControl( selElem ) )
            {
                __BE_changeSelection(oSelect, selElem);
            }
            else
            {
                __BE_changeSelection(null, selElem);
            }
            __BE_hideSelection( selElem );
        }
        else if( oSelect.selectedIndex > 0 )
        {
            selElem.value = oSelect.options[ oSelect.selectedIndex ].__BE_displayName;
            selElem.__BE_storeElement.value = oSelect.value;
        }
    }

    if( typeof window.customStoreSelectedValueHandler == 'function' )
        window.customStoreSelectedValueHandler( selElem.__BE_storeElement );
    if( isJustHide )
    {
        __BE_hideSelection( selElem);
        return;
    }
    if( selElem.__BE_nextElementToSwitch )
    {
        try
        {
            if(!selElem.__BE_nextElementToSwitch.focus())
            {
                __BE_hideSelection( selElem);
            }
        }
        catch( ex )
        {
            __BE_hideSelection( selElem );
        }
    }
    else
    {
        __BE_hideSelection( selElem );
    }
};

var __BE_showSelectionList = function(keyCode,selElem)
{
    var elem = document.getElementById(selElem.__BE_SEL_LIST);
    if( !elem )
    {
        elem = document.createElement('div');
        elem.id = selElem.__BE_SEL_LIST;

        document.body.appendChild(elem);
    }

    var pos = __BE_findPos( selElem );

    elem.style.display = "inline";
    /*
       elem.style.display = "block";
       elem.style.width = selElem.offsetWidth;
    */

    elem.style.position = 'absolute';

    elem.style.left = "" + pos[ 0 ] + "px";
    elem.style.top = "" + ( pos[ 1 ] + selElem.offsetHeight ) + "px";

    if( keyCode == /*DOWN*/40 )
    {
        var oSelect = document.getElementById( selElem.__BE_listControlName );
        if( oSelect )
        {

            // highlight first item
            if( !oSelect.value && oSelect.options && oSelect.options[ 0 ] )
            {
                oSelect.value = oSelect.options[ 0 ].value;
               __BE_changeSelection( oSelect, selElem );
            }

            selElem.onblur = null;
            oSelect.focus();

            return false;
        }
    }

    if( keyCode == /*ESCAPE*/27 && selElem.value )
    {
        __BE_changeSelection(null, selElem);
    }

    if( keyCode == /*ENTER*/13 && document.getElementById( selElem.__BE_listControlName ) )
    {
        __BE_finalizeSelection(selElem, false);
        return false;
    }

    if( ( keyCode == /*DELETE*/46 || keyCode == /*BACKSPACE*/8) && selElem.value.length<1 )
    {
        __BE_changeSelection(null, selElem);
    }

    if( selElem.prevValue == selElem.value )
    {
        return true;
    }

    selElem.prevValue = selElem.value;

    var param = hiddenFieldsAsParams( document.forms[ "formPropertyInspector" ] );
    param.push( [ "selector", selElem.value ] );

    // If the query has <parameter> inside it, autocompletion feature
    // automatically uses value of the form field with the same name
    // as a replacement for <parameter> placeholder
    // (see http://erp.dote.ru/q?_t_=projectBlogs&_qn_=Project%20Blogs&ID=3266).
    if( selElem.__BE_queryParams instanceof Array )
    {
        var form = document.forms[ "formPropertyInspector" ];
        if(selElem.__BE_queryParams.length == 1 && selElem.__BE_queryParams[0] == "allparams")
        {
            for( var i = 0; i < form.elements.length; i++ )
            {
                var item = form.elements[ i ];
                //all simple input
                if( item.value && item.name.match(/^[^(_)(selector___)]/))
                {
                    param.push( [ item.name, item.value ] );
                }
            }
        }
        else
        {
            for( var i = 0; i < selElem.__BE_queryParams.length; i++ )
            {
                var paramName = selElem.__BE_queryParams[ i ];
                if( form[ paramName ] )
                {
                    param.push( [ paramName, form[ paramName ].value ] );
                }
                else if( form[ paramName.toUpperCase() ] )
                {
                    param.push( [ paramName, form[ paramName.toUpperCase() ].value ] );
                }
            }
        }
    }

    __BE_hideSelection( selElem );

    calcUsingQuery( selElem.__BE_entity, selElem.__BE_query,
    {
        /*limit: 16,*/ search: true,
        params: param,
        listener:
           function( list )
           {
               var isIncomplete = isIncompleteSelectionControl( selElem );

               elem.innerHTML = '<select autocomplete="off" size="8" name="' +
                    selElem.__BE_listControlName + '" id="' + selElem.__BE_listControlName + '"></select>';

               var oSelect = document.getElementById( selElem.__BE_listControlName );

               oSelect.onmouseover = function(e)
               {
                   selElem.onblur = function(e) { this.hasFocus = false; };
               }
               oSelect.onmouseout = function(e)
               {
                   selElem.onblur = function(e)
                   {
                       this.hasFocus = false;
                       __BE_finalizeSelection( selElem, true );
                   };
               }
               oSelect.onchange = function(e)
               {
                   __BE_changeSelection( this, selElem );
               };
               oSelect.onfocus = function(e)
               {
                   oSelect.onblur = function(e)
                   {
                       //__BE_hideSelection( selElem );
                       __BE_finalizeSelection(selElem, true);
                   };
               }
               oSelect.onclick = function(e)
               {
                   oSelect.onblur = null;
                   __BE_finalizeSelection(selElem, true);
               };
               oSelect.onkeyup = function(e)
               {
                   var keyCode = window.event ? window.event.keyCode : e.which;
                   if( keyCode == /*ENTER*/13 )
                   {
                       oSelect.onblur = null;
                       __BE_finalizeSelection(selElem,false);
                   }
                   if( keyCode == /*ESCAPE*/27 )
                   {
                       oSelect.onblur = null;
                       selElem.value = "";
                       selElem.__BE_storeElement.value = "";
                       selElem.focus();
                   }
               };
               if( isIncomplete && !selElem.__onKeyPress )
               {
                   if( isIE() )
                   {
                        var __onKeyPress = selElem.onkeypress;
                        selElem.__onKeyPress = "event added";
                        selElem.onkeypress = __onKeyPress ? function()
                        {
                           __onKeyPress();
                           selElem.__BE_storeElement.value = selElem.value;
                        } : function()
                            {
                                selElem.__BE_storeElement.value = selElem.value;
                            };
                   }
                   else
                   {
                       selElem.__onKeyPress = "event added";
                       selElem.addEventListener( "keypress",
                           function( e )
                           {
                               var last = String.fromCharCode( e.keyCode || e.which );
                               selElem.__BE_storeElement.value = selElem.value + last;
                           }, true );
                   }
               }
               for( var i = 0 ; list && i < list.length ; ++i )
               {
                   var useVal = list[ i ][ 0 ];
                   var showVal = list[ i ][ 1 ];

                   var oOption = document.createElement( "OPTION" );
                   oSelect.options.add( oOption );
                   oOption.value = useVal;
                   oOption.__BE_displayName = showVal;
                   oOption.__BE_record = list[ i ];

                   if( keyCode != /*BACKSPACE*/8 && keyCode != /*DELETE*/46 && list.length == 1 && !isIncomplete
                      || showVal == selElem.value )
                   {
                       oOption.selected = true;
                       __BE_changeSelection( oSelect, selElem );
                   }

                   if( selElem.value )
                   {
                       var re = new RegExp( "(^" + selElem.value + ")", "i" );
                       showVal = showVal.replace( re, '[$1]' );
                   }

                   oOption.text = showVal;

                   /*elem.innerHTML += showVal + "<br>";*/
               }

               if( isIncomplete && !list )
               {
                   __BE_hideSelection( selElem );
               }
               else
               {
                   __BE_justShowSelection( selElem );
               }

               if( isIncomplete && typeof window.customIncompleteSelectionHandler == 'function' )
               {
                   window.customIncompleteSelectionHandler( selElem.__BE_storeElement, /*isListEmpty*/ list ? false : true );
               }
           }
    });
};

var __BE_findNextFocusableInput = function( form, myIndex )
{
    var repeat = false;

    for( var i = myIndex + 1; ; )
    {
        if( repeat && i >= myIndex )
            return null;

        if( i < form.elements.length  )
        {
             var item = form.elements[ i ];
             if( !item.disabled )
             {
                 if( item.type == "text" ||
                     item.type == "textarea" ||
                     item.type == "checkbox" ||
                     item.type == "password" ||
                     item.type == "submit" ||
                     item.type.substring( 0, 6 ) == "select"
                   )
                 {
                     var container = document.getElementById( item.name + "_container" );
                     if( container == null || ( !container.disabled &&
                          container.style.display != "none" &&
                          container.style.visibility != "hidden" )
                        )
                     {
                        return item;
                     }
                 }
             }
             i++;
        }
        else
        {
            repeat = true;
            i = 0;
        }
    }

    return null;
};

function hiddenFieldsAsParams( form )
{
    var params = [];
    for( var i = 0; i < form.elements.length; i++ )
    {
        var item = form.elements[ i ];
        if( item.value && item.type == "hidden" && !item.__BE_selectorElement )
        {
            if( item.name.search( /^_[A-Z]+_$/i ) != -1 )
                continue; // standard
            if( item.name.search( /^_op_/ ) != -1 )
                continue; // standard
            if( item.name.search( /^_rec_/ ) != -1 )
                continue; // standard
            params.push([ "_ajaxhid_" + item.name, item.value ]);
        }
    }
    return params;
}


function BE_setDropDownHandlers()
{
    var form = document.forms[ "formPropertyInspector" ];

    if( !form )
        return;

    var reSelector = new RegExp( "(.+?)_{3}(.+?)_{3}(.+?)_{3}(.+?)_{3}(.+?)_{3}(.*)", "" );
    var bWereDropDowns = false;
    for( var i = 0; i < form.elements.length; i++ )
    {
        var item = form.elements[ i ];
        var vals = reSelector.exec( item.name );
        if( vals && vals[ 1 ] == "selector" ||
            vals && vals[ 1 ] == "select2" && isIE() && !document.addEventListener /* IE < 9 */
          )
        {
            bWereDropDowns = true;
            var name = vals[ 2 ];
            var entity = vals[ 3 ];
            var qname = vals[ 4 ];
            var queryParams = vals[ 6 ];
            item.__BE_listControlName = "list_" + name;
            item.__BE_entity = entity;
            item.__BE_query = qname;
            item.__BE_queryParams = ( queryParams ? queryParams.split( '$' ) : [] );
            item.__BE_SEL_LIST = __BE_SEL_LIST + "__" + name;
            item.__BE_storeElement = form[ name ];
            item.__BE_storeElement.__BE_selectorElement = item;
            if( item.__BE_storeElement.placeholder )
            {
                item.placeholder = item.__BE_storeElement.placeholder;
            }
        }
        else if( vals && vals[ 1 ] == "autocomplete" )
        {
            var name = vals[ 2 ];
            var entity = vals[ 3 ];
            var qname = vals[ 4 ];
            var queryParams = vals[ 6 ];

            item.__BE_queryParams = ( queryParams ? queryParams.split( '$' ) : [] );
            item.__BE_storeElement = form[ name ];
            item.__BE_storeElement.__BE_selectorElement = item;
            if( item.__BE_storeElement.placeholder )
            {
                item.placeholder = item.__BE_storeElement.placeholder;
            }

            jQuery(item).autocomplete(
            {
                serviceUrl: 'calcUsingQuery',
                paramName: "selector",
                params: { "_t_": entity, "_qn_": qname, "_enc_": "UTF-8", "_search_": "true", "_json_": "autocomplete" },
                noCache: true,
                onSelect: function (suggestion)
                {
                    this.__BE_storeElement.value = suggestion.data ? suggestion.data : suggestion.value;
                    if( typeof window.customStoreSelectedValueHandler == 'function' )
                    {
                        window.customStoreSelectedValueHandler( this.__BE_storeElement );
                    }
                    else
                    {
                        jQuery(this.__BE_storeElement).change();
                    }
                }
            });
        }
        else if( vals && vals[ 1 ] == "select2" )
        {
            var name = vals[ 2 ];
            var entity = vals[ 3 ];
            var qname = vals[ 4 ];
            var queryParams = vals[ 6 ];

            var realInput = form[ name ];
            jQuery.data( realInput, "entity", entity );
            jQuery.data( realInput, "qname", qname );

            item.__BE_queryParams = ( queryParams ? queryParams.split( '$' ) : [] );
            item.__BE_storeElement = form[ name ];
            item.__BE_storeElement.__BE_selectorElement = item;
            if( item.__BE_storeElement.placeholder )
            {
                item.placeholder = item.__BE_storeElement.placeholder;
            }

            var displayText = item.value;

            item.style.display = "none";

            jQuery(item.__BE_storeElement).select2(
            {
                width: "300px",
                minimumInputLength: 1,
                ajax:
                {
                    url: 'calcUsingQuery',
                    dataType: "json",
                    data: function( term, page )
                    {
                        return { "selector": term, "_t_": jQuery.data( this[ 0 ], "entity" ), "_qn_": jQuery.data( this[ 0 ], "qname" ), "_enc_": "UTF-8", "_search_": "true", "_json_": "select2" };
                    },
                    results: function( data, page )
                    {
                        return data;
                    }
                },
                initSelection : function (element, callback)
                {
                    var data = { "id": element.val(), "text": realInput.__BE_selectorElement.value };
                    callback(data);
                }
            });
        }
    }

    if( !bWereDropDowns )
        return;

    //initLogger( "DEBUG" );

    for( i = 0; i < form.elements.length; i++ )
    {
        var item = form.elements[ i ];
        if( item.__BE_listControlName )
        {
            // selector
            item.onfocus =
            item.onkeyup = function(e)
            {
                this.onblur = function(e)
                {
                    this.hasFocus = false;
                    __BE_finalizeSelection( this, true );
                };

                __BE_showSelectionList(window.event ? window.event.keyCode : e.which, this );
            };
            item.setAttribute( "autocomplete", "off" );
            item.__BE_nextElementToSwitch = __BE_findNextFocusableInput( form, i );
        }
        else if( item.type != "hidden" )
        {
            item.onfocus = function(e)
            {
                __BE_hideSelection( this );
            };
        }
    }
}

/**
 * @constructor
 */
function AJAXInteraction( url, callback )
{
    var req = init();
    req.onreadystatechange = processRequest;

    function init()
    {
        if ( window.XMLHttpRequest )
            return new XMLHttpRequest();
        else if ( window.ActiveXObject )
            return new ActiveXObject("Microsoft.XMLHTTP");
    }

    function processRequest()
    {
        try
        {
            if ( req.readyState == 4 && req.status == 200 && callback )
                callback(req.responseText);
        }
        catch ( e )
        {
            callback("Error :" + e.description);
        }
    }

    this.doGet = function()
    {
        req.open("GET", url, true);
        req.send(null);
    };
}


/**
*  Update HTML DIV element with new content from URL
*/
function __BE_call()
{
    var _url;
    var _div;
    var _append = false;
    var _callback=null;
    var _arr=null;

    var loadDiv = function ( url, divObj )
    {
        _div = divObj;
        _url = url;
        _append = false;
        _callback=null;
        _arr=null;
        makeRequest();
    };

    var appendDiv = function ( url, divObj )
    {
        _div = divObj;
        _url = url;
        _append = true;
        _callback=null;
        _arr=null;
        makeRequest();
    };

    var loadDivWithCallback = function ( url, divObj, callback )
    {
        _div = divObj;
        _url = url;
        _append = true;
        _callback = callback;
        _arr=null;
        makeRequest();
    };

    var appendDivWithCallback = function ( url, divObj, callback )
    {
        _div = divObj;
        _url = url;
        _append = true;
        _callback = callback;
        _arr=null;
        makeRequest();
    };

    var loadArray = function ( url, arr, callback )
    {
        _url = url;
        _callback = callback;
        _arr = arr;
        _div = null;
        makeRequest();
    };

    var makeRequest = function()
    {
        var ai = new AJAXInteraction( _url + "&_ts_=" + new Date().getTime(), processStatus );
        __BE_showLoading();
        ai.doGet();
    };

    var processStatus = function( status )
    {
        __BE_hideLoading();
        if ( _div != null )
        {
            if ( _append )
                _div.innerHTML += status;
            else
                _div.innerHTML = status;
        }

        if ( _arr && _callback )
        {
            _arr = status;
            _callback(_arr);
        }
        else
        {
            if (_callback)
                _callback();
        }
    };


    return {
        loadDiv: loadDiv,
        appendDiv: appendDiv,
        loadDivWithCallback: loadDivWithCallback,
        appendDivWithCallback: appendDivWithCallback,
        loadArray: loadArray
    };
}


/**
 * TODO make it working with singleton
 */
function getXmlHttpRequestInstance()
{
        if ( window.XMLHttpRequest )
                return new XMLHttpRequest();
        else if ( window.ActiveXObject )
                return new ActiveXObject("Microsoft.XMLHTTP");

        // TODO complain something here, the browser sucks

        return null;
}

function trimAlert( message )
{
    var mess = message.replace(/<br[ \/]*>/ig, '\n'  );
    try
    {
        var json = JSON.parse( mess.substr( mess.indexOf("["), mess.lastIndexOf("]") + 1 ) );
        alert( mess.substr( 0, mess.indexOf("[") ) + " " + mess.substr( mess.lastIndexOf("]") + 1, mess.length ) );
    }
    catch(e)
    {
        alert( mess );
    }
}

function isEmpty( value )
{
    return typeof( value ) == undefined || typeof( value ) == "undefined" ||  value == null || value == "null" || value == "";
}

ServletAPI = {
    doGet : function( inUrl, params ) {
        invokeRemoteMethod( "GET", inUrl, params );
    },
    invokeOperation : function( inUrl, params ) {
        invokeRemoteMethod( 'invokeOperation', inUrl, params );
    },
    invokeRemoteMethod : function( methodName, inUrl, params ) {
        invokeRemoteMethod( methodName, inUrl, params );
    }
};

if( Object.keys === undefined ) 
{
    Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}

if( Function.prototype.bind === undefined ) 
{
    Function.prototype.bind = function( b ) 
    {
        if( typeof this !== "function" )
        {
            throw new TypeError( "Function.prototype.bind - what is trying to be bound is not callable" );
        }
        var a = Array.prototype.slice, f = a.call( arguments, 1 ), e = this, c = function(){}, d = function() {
            return e.apply( this instanceof c ? this : b || window, f.concat( a.call( arguments ) ) ); 
        };
        c.prototype = this.prototype;
        d.prototype = new c();
        return d;
    };
}

if( !Array.prototype.indexOf )
{
    Array.prototype.indexOf = function( elt /*, from*/ )
    {
        var len = this.length >>> 0;
        var from = Number( arguments[ 1 ] ) || 0;
        from = ( from < 0 ) ? Math.ceil( from ) : Math.floor( from );
        if( from < 0 )
        {
            from += len;
        }
        for( ; from < len; from++ )
        {
            if( from in this && this[ from ] === elt )
            {
                return from;
            }
        }
        return -1;
    };
}

/**
 * $Id: DynamicProperty.js,v 1.18 2011/12/08 12:36:02 champ Exp $
 *
 * Dynamic property - analog of DynamicProperty class in Java.
 */

/**
 * @constructor
 */
function DynamicProperty( name, type, value )
{
    this.descriptor = new PropertyDescriptor(name);
    this.type = type;
    this.value = value;
    // listeners for changes
    this.changeListeners = [];
};

//@TODO (champ): continue
DynamicProperty.CAN_BE_NULL = "can-be-null";
DynamicProperty.READ_ONLY = "read-only";

/* property parent */
DynamicProperty.prototype.getParent = function()
{
    return this.parent;
};

DynamicProperty.prototype.setParent = function( parent )
{
    this.parent = parent;
};

/* 'propertyDescriptor' property */
DynamicProperty.prototype.getDescriptor = function()
{
    return this.descriptor;
};

/* 'name' property */
DynamicProperty.prototype.getName = function()
{
    return this.descriptor.getName();
};

DynamicProperty.prototype.setName = function( name )
{
    this.descriptor.setName(name);
};

/* 'displayName' property */
DynamicProperty.prototype.getDisplayName = function()
{
    return this.descriptor.getDisplayName();
};

DynamicProperty.prototype.setDisplayName = function( displayName )
{
    this.descriptor.setDisplayName(displayName);
};

/* 'description' property */
DynamicProperty.prototype.getShortDescription = function()
{
    return this.descriptor.getShortDescription();
};

DynamicProperty.prototype.setShortDescription = function( description )
{
    this.descriptor.setShortDescription(description);
};

/* 'type' property */
DynamicProperty.prototype.getType = function()
{
    return this.type;
};

DynamicProperty.prototype.setType = function( type )
{
    this.type = type;
};

/* 'value' property */
DynamicProperty.prototype.getValue = function()
{
    return this.value;
};

DynamicProperty.prototype.setValue = function( value )
{
    this.value = value;
};

/* get/set attrubites */
DynamicProperty.prototype.getAttribute = function( attributeName )
{
    return this.descriptor.getValue(attributeName);
};

DynamicProperty.prototype.setAttribute = function( attributeName, value )
{
    this.descriptor.setValue(attributeName, value);
};

/* 'canBeNull' property */
DynamicProperty.prototype.getCanBeNull = function()
{
    return this.canBeNull;
};

DynamicProperty.prototype.setCanBeNull = function( canBeNull )
{
    var oldValue = this.canBeNull;
    this.canBeNull = canBeNull;
    this.fireChangeListeners( DynamicProperty.CAN_BE_NULL, oldValue, this.canBeNull );
};

/* 'readOnly' property */
DynamicProperty.prototype.isReadOnly = function()
{
    return this.descriptor.isReadOnly();
};

DynamicProperty.prototype.setReadOnly = function( readOnly )
{
    var oldValue = this.isReadOnly();
    this.descriptor.setReadOnly( readOnly );
    this.fireChangeListeners( DynamicProperty.READ_ONLY, oldValue, readOnly );
};

/* 'defaultValue' property */
DynamicProperty.prototype.getDefaultValue = function()
{
    return this.defaultValue;
};

DynamicProperty.prototype.setDefaultValue = function( defaultValue )
{
    this.defaultValue = defaultValue;
};

DynamicProperty.prototype.assignFrom = function(dynamicProperty){
    this.descriptor.assignFrom(dynamicProperty.getDescriptor());
    this.type = dynamicProperty.getType();
    this.defaultValue = dynamicProperty.getDefaultValue();
    this.canBeNull = dynamicProperty.getCanBeNull();
    this.parent = dynamicProperty.getParent();
}

/**
 * Adds user listener, witch is invoked when this DynamicProperty changed.
 *
 * Listener must have following prototype:
 *
 * function( event )
 *
 * Where event has next properties:
 *  type - what is changed
 *  oldValue - value before change
 *  newValue - new value
 *
 * @param {Function} listener listener to listen value changes
 */
DynamicProperty.prototype.addChangeListener = function ( listener )
{
    this.changeListeners[ this.changeListeners.length++ ] = listener;
}

/**
 * Method to fire value change events.
 *
 *  oldValue - value before change
 *  newValue - new value
 *
 * @param {string} type what was changed
 * @param {Object} oldValue value before change
 * @param {Object} newValue new value
 */
DynamicProperty.prototype.fireChangeListeners = function ( type, oldValue, newValue )
{
    for( var i = 0; i < this.changeListeners.length; i++ )
    {
        var listener = this.changeListeners[ i ];
        var event = { type: type, oldValue: oldValue, newValue: newValue };
        listener( event );
    }
}

// static
DynamicProperty.create = function( name, displayName, type, value )
{
    var dp = new DynamicProperty( name, type ? type : "string", null );
    dp.setDisplayName( window.getMessage( displayName ) );
    if( value )
    {
        dp.setValue( value );
    }
    return dp;
}

DynamicProperty.createFromJSON = function( item )
{
    var type = DynamicProperty.typeFromJava( item.type );
    var property = DynamicProperty.create( item.name, item.displayName, type, item.value );
    // @TODO (champ): !!!!!!! convert ot true/false
    property.setCanBeNull( item.canBeNull ? "yes"  : "no" );
    if( item.rawValue )
    {
        property.setAttribute( "rawValue", item.rawValue );
    }
    if( item.tagList )
    {
        var dictionary = new Dictionary( item.name );
        for( var i = 0; i < item.tagList.length; i++ )
        {
            var tag = item.tagList[ i ];
            if( tag.constructor == Array )
            {
                dictionary.add( tag[ 0 ], tag[ 1 ] );
            }
            else
            {
                var pair = tag.split( "\u0000" );
                if( pair.length == 1 )
                {
                    dictionary.add( "", pair[ 0 ] );
                }
                else
                {
                    dictionary.add( pair[ 1 ], pair[ 0 ] );
                }
            }
        }
        window.attributesInfo.dictionaries.addDictionary( dictionary );
        property.setAttribute("dictionaryName", dictionary.getName() );
        property.setType( "code-string" );
    }
    return property;
}

// @TODO (champ): add other types
DynamicProperty.TYPE_MAPPING =
{
    "java.lang.String" : "string",
    "java.sql.Date" : "date",
    "java.sql.Timestamp" : "date-time",
    "java.lang.Boolean" : "bool",
    "java.lang.Integer" : "number"
}
DynamicProperty.typeFromJava = function( javaType )
{
    var type = DynamicProperty.TYPE_MAPPING[ javaType ];
    return type ? type : "string";
}/**
 * $Id: DynamicPropertySet.js,v 1.17 2011/06/03 14:02:00 champ Exp $
 *
 * Dynamic property set - analog of DynamicPropertySet class in Java.
 */

/**
 * @constructor
 */
function DynamicPropertySet()
{
    this.properties = {};
    this.parentArray = null;
};

/**
 * Returns all properties
 */
DynamicPropertySet.prototype.getAllProperties = function()
{
    return this.properties;
};

/**
 * Returns property referenced via its name
 * @param name Name of the property
 */
DynamicPropertySet.prototype.getProperty = function( name )
{
    var property = this.properties[ name ];
    return property;
};

/** Adds new property to the dynamic bean */
DynamicPropertySet.prototype.add = function( property )
{
    this.properties[ property.getName() ] = property;
    property.setParent(this);
};

/**
 * Removes property from the bean
 * @return true if property was removed sucessfully
 */
DynamicPropertySet.prototype.remove = function( name )
{
    var result = false;
    var property = this.getProperty(name);
    if( property != null )
    {
        property.setParent(null);
        delete this.properties[ name ];
        result = true;
    }
    return result;
};

/**
 * Replaces named property with new one
 * @return true if property was replaced sucessfully
 */
DynamicPropertySet.prototype.replaceWith = function( name, property )
{
    var result = false;
    if( this.remove(name) )
    {
        this.add(property);
        result = true;
    }
    return result;
};

/** Checks if property does exist in this set */
DynamicPropertySet.prototype.contains = function( property )
{
    return this.getProperty(property.getName()) != null;
};

/**
 * @return type for the property with specified name.
 * @param name - name of the property which type is desired
 */
DynamicPropertySet.prototype.getType = function( name )
{
    var property = this.getProperty(name);
    return property != null ? property.getType() : null;
};

/**
 * @return value for the property with specified name.
 * @param name - name of the property which value is desired
 */
DynamicPropertySet.prototype.getValue = function( name )
{
    var property = this.getProperty(name);
    return property != null ? property.getValue() : null;
};

/**
 * @param name Name of the property
 * @param value New value of the property
 */
DynamicPropertySet.prototype.setValue = function( name, value )
{
    var property = this.getProperty(name);
    if( property != null )
    {
        property.setValue(value);
    }
};

/**
 * Returns standard property descriptor for the property referenced via its name
 * @param name Name of the property
 * @return Value of the property descriptor
 */
DynamicPropertySet.prototype.getPropertyDescriptor = function( name )
{
    var property = this.getProperty(name);
    return property != null ? property.getDescriptor() : null;
}

DynamicPropertySet.prototype.setParentArray = function( parentArray )
{
    this.parentArray = parentArray;
}

DynamicPropertySet.prototype.getParentArray = function ()
{
    return this.parentArray;
}

DynamicPropertySet.prototype.assignFrom = function( sourceDPS )
{
    for( var name in sourceDPS.getAllProperties() )
    {
        var property = this.getProperty(name);
        // @TODO (champ): is it correct ro create new DP?
        if( property == null )
        {
            property = new DynamicProperty(name, null, null);
            this.add(property);
        }
        property.setValue(sourceDPS.getValue(name));
    }
}

DynamicPropertySet.prototype.asString = function()
{
    var ret = "DPS {";
    for( var name in this.getAllProperties() )
    {
        var property = this.getProperty(name);
        var value = property.getValue();
        ret += name;
        ret += "=";
        ret += value;
        ret += ","
    }
    ret += "}";
    return ret;
}

/*
 * Returns ID, assuming that this collection's object
 * that resides in DB
 * */
DynamicPropertySet.prototype.getDbId = function()
{
    return this.getValue("ID");
}

/**
 * $Id: PropertyDescriptor.js,v 1.7 2011/06/03 14:02:15 champ Exp $
 *
 * Property descriptor - analog of PropertyDescriptor class in Java.
 */

/**
 * @constructor
 */
function PropertyDescriptor(name)
{
    this.attributes = {};
    this.setName(name);
}


/* 'name' property */
PropertyDescriptor.prototype.getName = function()
{
    return this.name;
};

PropertyDescriptor.prototype.setName = function( name )
{
    this.name = name;
};

/* 'displayName' property */
PropertyDescriptor.prototype.getDisplayName = function()
{
    return this.displayName;
};

PropertyDescriptor.prototype.setDisplayName = function( displayName )
{
    this.displayName = displayName;
};

/* 'description' property */
PropertyDescriptor.prototype.getShortDescription = function()
{
    return this.description;
};

PropertyDescriptor.prototype.setShortDescription = function( description )
{
    this.description = description;
};

/* 'readOnly' property */
PropertyDescriptor.prototype.isReadOnly = function()
{
    return this.readOnly;
};

PropertyDescriptor.prototype.setReadOnly = function( readOnly )
{
    this.readOnly = readOnly;
};

/* 'propertyType' property */
PropertyDescriptor.prototype.getPropertyType = function()
{
    return this.propertyType;
};

PropertyDescriptor.prototype.getPropertyType = function( propertyType )
{
    this.propertyType = propertyType;
};

/* 'propertyEditor' property */
PropertyDescriptor.prototype.getPropertyEditor = function()
{
    return this.propertyEditor;
};

PropertyDescriptor.prototype.setPropertyEditor = function( propertyEditor )
{
    this.propertyEditor = propertyEditor;
};

/* get/set attrubites */
PropertyDescriptor.prototype.getValue = function( attributeName )
{
    return this.attributes[attributeName];
};

PropertyDescriptor.prototype.setValue = function( attributeName, value )
{
    this.attributes[attributeName] = value;
};

PropertyDescriptor.prototype.assignFrom = function (sourcePropDescriptor) {
    this.readOnly = sourcePropDescriptor.isReadOnly();
    this.propertyType = sourcePropDescriptor.getPropertyType();
    this.propertyEditor = sourcePropDescriptor.getPropertyEditor();
    this.attributes = sourcePropDescriptor.attributes;
}/**
 * $Id: Dictionaries.js,v 1.10 2012/11/16 08:57:04 dobrynin Exp $
 *
 * Dictionaries storage.
 */

/**
 * @constructor
 */
function Dictionaries()
{
    this.dictionaries = {};
    this.dispatchers = {};
}

/**
 * Returns all dictionary names
 */
Dictionaries.prototype.getDictionaryNames = function()
{
    return this.dictionaries;
};

/**
 * Returns dictionary referenced via its name
 * @param name Name of the dictionary
 */
Dictionaries.prototype.getDictionary = function( name )
{
    return this.dictionaries[ name ];
};

/** Adds new dictionary */
Dictionaries.prototype.addDictionary = function( dictionary )
{
    this.dictionaries[ dictionary.getName() ] = dictionary;
};

/**
 * Removes dictionary
 * @return true if dictionary was removed sucessfully
 */
Dictionaries.prototype.removeDictionary = function( name )
{
    var result = false;
    var dictionary = this.getDictionary(name);
    if( dictionary != null )
    {
        delete this.dictionaries[ name ];
        result = true;
    }
    return result;
};

/** Async load dictionaries */
Dictionaries.prototype.loadDictionary = function( dictionaryName, dispatcher )
{
    if( this.getDictionary( dictionaryName ) )
    {
        dispatcher( this.getDictionary( dictionaryName ) );
    }
    else
    {
        if( !this.dispatchers[ dictionaryName ] )
        {
            this.dispatchers[ dictionaryName ] = [];
            this.dispatchers[ dictionaryName ][ this.dispatchers[ dictionaryName ].length ] = dispatcher;
            var self = this;
            window.calcUsingQuery( dictionaryName, "All records",
            {
                urlPrefix: window.location.toString().indexOf("file:") >= 0 ? window.context + "/" : null,
                search: true,
                timeout: 60000,
                limit: 5000,
                doNotShowLoading: true,

                listener:
                        function( list )
                        {
                            // create dictionary
                            var dictionary = new Dictionary( dictionaryName );
                            for( var idx in list )
                            {
                                dictionary.add( list[idx][ 0 ], list[idx][ 1 ] );
                            }
                            window.dictionaries.addDictionary( dictionary );
                            self.notifyDispatchers( dictionaryName, dictionary );
                        },
                timeoutListener:
                        function()
                        {
                            self.notifyDispatchers( dictionaryName, null );
                        },
                errorListener:
                        function()
                        {
                            self.notifyDispatchers( dictionaryName, null );
                        }
            } );
        }
        else
        {
            this.dispatchers[ dictionaryName ][ this.dispatchers[ dictionaryName ].length ] = dispatcher;
        }
    }
};

/** Async load dictionaries */
Dictionaries.prototype.notifyDispatchers = function( dictionaryName, dictionary )
{
    var dispatchers =  this.dispatchers[ dictionaryName ];
    for( var idx in dispatchers )
    {
        dispatchers[ idx ]( dictionary );
    }
    this.dispatchers[ dictionaryName ] = undefined;
}

/**
 * Dictionary.
 * @constructor
 */
function Dictionary( name )
{
    this.name = name;
    this.keys = [];
    this.pairs = {};
}

/**
 * Returns dictionary name
 */
Dictionary.prototype.getName = function()
{
    return this.name;
};

/**
 * Returns all keys
 */
Dictionary.prototype.getKeys = function()
{
    return this.keys;
};

/**
 * Returns all names
 */
Dictionary.prototype.getPairs = function()
{
    return this.pairs;
};

/**
 * Returns value pair for name
 * @param key key of the key-value pair
 */
Dictionary.prototype.get = function( key )
{
    return this.pairs[ key ];
};

/** Adds new name-value pair */
Dictionary.prototype.add = function( key, value )
{
    this.keys[ this.keys.length ] = key;
    this.pairs[ key ] = value;
};

/**
 * Returns key
 * @param value
 */
Dictionary.prototype.getKeyByValue = function( value )
{
    for( var key in this.pairs )
    {
        if( this.pairs[ key ] == value )
        {
            return key;
        }
    }
    return "";
};
/**
 * $Id: SemanticRule.js,v 1.4 2011/06/02 08:59:43 champ Exp $
 *
 * Semantic rule - analog of SemanticRule class in Java.
 */

/**
 * @constructor
 */
function SemanticRule( name )
{
    this.setName( name );
}

/* 'id' property */
SemanticRule.prototype.getId = function()
{
    return this.id;
};

SemanticRule.prototype.setId = function( id )
{
    this.id = id;
};

/* 'name' property */
SemanticRule.prototype.getName = function()
{
    return this.name;
};

SemanticRule.prototype.setName = function( name )
{
    this.name = name;
};

/* 'Type' property */
SemanticRule.prototype.getType = function()
{
    return this.type;
};

SemanticRule.prototype.setType = function( type )
{
    this.type = type;
};

/* 'code' property */
SemanticRule.prototype.getCode = function()
{
    return this.code;
};

SemanticRule.prototype.setCode = function( code )
{
    this.code = code;
};

/* 'localizedCode' property */
SemanticRule.prototype.getLocalizedCode = function()
{
    return this.localizedCode;
};

SemanticRule.prototype.setLocalizedCode = function( localizedCode )
{
    this.localizedCode = localizedCode;
};

/* 'level' property */
SemanticRule.prototype.getLevel = function()
{
    return this.level;
};

SemanticRule.prototype.setLevel = function( level )
{
    this.level = level;
};

/* 'script' property */
SemanticRule.prototype.getScript = function()
{
    return this.script;
};

SemanticRule.prototype.setScript = function( script )
{
    this.script = script;
};

/* 'description' property */
SemanticRule.prototype.getDescription = function()
{
    return this.description;
};

SemanticRule.prototype.setDescription = function( description )
{
    this.description = description;
};
// $Id: Logging.js,v 1.20 2011/06/23 05:58:50 champ Exp $

// Intended using lob log4js-mini.js

function debug( msg )
{
    if( Logger )
    {
        Logger.debug( msg );
    }
}

function info( msg )
{
    if( Logger )
    {
        Logger.info( msg );
    }
}

function warn( msg )
{
    if( Logger )
    {
        Logger.warn( msg );
    }
}

function error( msg )
{
    if( Logger )
    {
        Logger.error( msg );
    }
}

function fatal( msg )
{
    if( Logger )
    {
        Logger.fatal( msg );
    }
}

function dir( obj )
{
    if( window.console && window.console.dir )
    {
        window.console.dir( obj );
    }
}


// // use this list to enable or disable logging
var logClasses =
{
    "LOADPASSPORT":false,
    "LISTENERS":false,
    "FOCUS" : false,
    "STATE": false,
    "VALUES": false,
    "ROWS": false,
    "TIMING":false,
    "TIMINGTOTALS":true,
    "AJAX":false,
    "DEBUG":false,
    "ADDRESS":false,
    "XMLPARSE":false,
    "FORMS":false,
    "KEYBOARD":false
};

function logByClass( logClass, msg )
{
    if( logClasses[logClass] == false )
    {
        return;
    }
    debug(logClass + ": " + msg);
}

var timeLog = {};
var timeLogAccumulated = {};

function getCurTimeMillis()
{
    var curDate = new Date();
    return curDate.getMilliseconds() +
           curDate.getSeconds() * 1000 +
           curDate.getMinutes() * 1000 * 60 +
           curDate.getHours() * 1000 * 60 * 60 +
           curDate.getDate() * 1000 * 60 * 60 * 24;
}

function timingLogBegin( subject )
{
    var curTime = getCurTimeMillis();
    logByClass("TIMING", "Started subject: " + subject);
    timeLog[subject] = curTime;
}


function timingLogEnd( subject )
{
    var curTime = getCurTimeMillis();
    var startTime = timeLog[subject];
    var elapsed = curTime - startTime;

    // first call
    if( timeLogAccumulated[subject] === undefined )
    {
        logByClass("TIMING", "Ending subject: " + subject + ", execution took " +
                      (elapsed / 1000. ) + " seconds. "
                );
        timeLogAccumulated[subject] = 0.;
    }
    else
    {
        logByClass("TIMING", "Ending subject: " + subject + ", execution took " +
                      (elapsed / 1000. ) + " seconds. Total accumulated time is "
                + timeLogAccumulated[subject] / 1000. + " seconds."
                );
    }
    timeLogAccumulated[subject] += elapsed;

}

function showTimingTotals()
{
    //var res = "Timing totals is: \n";
    var res = "\n";
    for( var subj in timeLogAccumulated )
    {
        var elapsed = timeLogAccumulated[subj];
        res += "   " + subj + ": " + elapsed / 1000. + " sec\n";
    }
    logByClass("TIMINGTOTALS", res);
}

function resetTimingTotals()
{
    timeLog = {};
    timeLogAccumulated = {};
}

// enable logging for local sites
if( window.location.toString().indexOf( "localhost" ) > -1 && window.console )
{
    //initLogger( "DEBUG", "consoleLogger");
}
/**
 * $Id: ModificationListener.js,v 1.21 2012/08/30 09:19:52 champ Exp $
 *
 * addModificationListener function makes
 * GUI control react on value change and
 * invoke specified function on change
 */

var focusedComponent;
var prevValues = {};
var intervalIDs = {};
var callbacks = {};

function addListener( node, event, listener )
{
    if( node.addEventListener )
    {
        node.addEventListener( event, listener );
    }
    else if( node.attachEvent )
    {
        node.attachEvent( "on" + event, listener );
    }
    else
    {
        node[ "on" + event ] = listener;
    }
}

function addModificationListener( HTMLNode, func )
{
    if( HTMLNode.type === "checkbox" )
    { // check box
        prevValues [HTMLNode.id ] = HTMLNode.checked;
    }
    else if( HTMLNode.type === "select-one" )
    { //select control
        //HTMLNode.onfocus = onFocus;
        addListener( HTMLNode, "focus", onFocus );
    }
    else
    { //other control
        //HTMLNode.onfocus = onFocus;
        //HTMLNode.onblur = onBlur;
        addListener( HTMLNode, "focus", onFocus );
        addListener( HTMLNode, "blur", onBlur );
    }
    //HTMLNode.onchange = onChange;
    addListener( HTMLNode, "change", onChange );
    if( !callbacks[ HTMLNode.id ] )
    {
        callbacks[ HTMLNode.id ] = [];
    }
    var listeners = callbacks[ HTMLNode.id ];
    listeners[ listeners.length++ ] = func;

    logByClass("LISTENERS", "Adding modification listener for " + HTMLNode.id + ", now " + listeners.length + " listeners.")
}

function onChange( e )
{
    focusedComponent = getComponent(e);
    verify( focusedComponent );
}

function FF()
{
    return navigator.userAgent.indexOf("Opera") < 0 && navigator.userAgent.indexOf("MSIE") < 0;
}

function onFocus( e )
{
    focusedComponent = getComponent(e);
    prevValues[ focusedComponent.id ] = focusedComponent.type == "checkbox" ? focusedComponent.checked : focusedComponent.value;
    if( focusedComponent.type !== "select-one" )
    {
        intervalIDs[ focusedComponent.id ] = window.setInterval( verifyTimer, 100 );
    }
}

function onBlur( e )
{
    var component = getComponent(e);
    window.clearInterval(intervalIDs[ component.id ]);
    verify( component );
}

function verifyTimer()
{
    verify();
}

function verify( controlToVerify )
{
    var control = controlToVerify || focusedComponent;
    if( control )
    {
        var value = control.type == "checkbox" ? control.checked : control.value;
        if( ( prevValues[ control.id ] != null && ( prevValues[ control.id ] !== value ) ) ||
            control.type == "checkbox")
        {
            var oldValue = prevValues[ control.id ];
            prevValues[ control.id ] = value;
            var listeners = callbacks[ control.id ];
            for( var i = 0; listeners != null && i < listeners.length; i++ )
            {
                logByClass("LISTENERS", "Launching listener for " + control.id + " " + oldValue + " -> " + value);
                listeners[i](oldValue, value);
            }
        }
    }
}

function getComponent( event )
{
    var component;
    if( !event  )
    {
        event = window.event;
    }
    if( FF() )
    {
        component = event.target;
    }
    else
    {
        component = event.srcElement;
    }
    return component;
}
/**
 * $Id: Utils.js,v 1.3 2011/06/07 09:01:33 champ Exp $
 */

/**
 * @constructor
 */
function Utils()
{
}

/**
 *  Unique id generator.
 *
 *  alert(uid()); //alert 1
 *  alert(uid()); //alert 2
 */
Utils.uid = (
    function(){
    var id=0;
        return function(){
            return id++ ;
        };
    }
)();

Utils.arrayRemove = function(array, idx)
{
    idx = parseInt(idx);
    if( idx >= 0 )
    {
        if( idx == array.length - 1 )
        {
            delete array[idx];
        }
        for( var i = idx; i < array.length -1; i++ )
        {
            array[i] = array[i+1];
            delete array[i+1];
        }
        array.length--;
    }
}

Utils.parseXML = function( txt )
{
    var xmlDoc = null;
    if( window.DOMParser )
    {
        var parser = new DOMParser();
        xmlDoc = parser.parseFromString( txt, "text/xml" );
    }
    else // Internet Explorer
    {
        xmlDoc = new ActiveXObject( "Microsoft.XMLDOM" );
        xmlDoc.async = "false";
        xmlDoc.loadXML( txt );
    }
    return xmlDoc;
}

Utils.xmlToString = function( xml )
{
    var xmlText;
    if( window.ActiveXObject )
    {
        xmlText = xml.xml;
    }
    else
    {
        xmlText = ( new XMLSerializer() ).serializeToString( xml );
    }
    return xmlText;
}


Utils.XMLize = function( string )
{
    string = string.replace(/</g, "&lt;");
    string = string.replace(/>/g, "&gt;");
    return string;
}

Utils.tokenize = function( parseString, delimiter )
{
    var v = [];
    var pos = 0;
    while( parseString.indexOf(delimiter, pos) != -1 )
    {
        var curPos = parseString.indexOf(delimiter, pos);
        v[ v.length ] = parseString.substring(pos, curPos);
        pos = curPos + delimiter.length;
    }
    if( pos < parseString.length ) // ignore last delimeter, if exist
    {
        v[ v.length ] = parseString.substring(pos);
    }
    return v;
}

Utils.trim = function( str )
{
    if (str)
    {
        str = str.replace(/^\s+/, '');
        for( var i = str.length - 1; i >= 0; i-- )
        {
            if( /\S/.test(str.charAt(i)) )
            {
                str = str.substring(0, i + 1);
                break;
            }
        }
    }
    return str;
}

Utils.toUnicode = function( theString )
{
    var unicodeString = '';
    for( var i = 0; i < theString.length; i++ )
    {
        var theUnicode = theString.charCodeAt( i ).toString( 16 ).toUpperCase( );
        while( theUnicode.length < 4 )
        {
            theUnicode = '0' + theUnicode;
        }
        theUnicode = '\\u' + theUnicode;
        unicodeString += theUnicode;
    }
    return unicodeString;
}

String.prototype.getWidth = function( styleObject )
{
    var test = document.createElement("span");
    document.body.appendChild(test);
    test.style.visibility = "hidden";
    for( var i in styleObject )
    {
        test.style.i = styleObject[i];
    }
    test.innerHTML = this;
    var w = test.offsetWidth;
    document.body.removeChild(test);
    return w;
}

Utils.getLocation = function()
{
    return window.location.toString().indexOf("file:") >= 0 ? window.context + "/" : ( window.location.protocol + "//" + window.location.host + "/" + window.location.pathname );
}

Utils.getWindowInnerWidth = function()
{
    return window.innerWidth ? window.innerWidth :
            ( document.documentElement.clientWidth > 0 ? document.documentElement.clientWidth : document.body.clientWidth );
}

Utils.getWindowInnerHeight = function()
{
    return window.innerHeight ? window.innerHeight :
            ( document.documentElement.clientHeight > 0 ? document.documentElement.clientHeight : document.body.clientHeight );
}

Utils.getWindowPageXOffset = function()
{
    return window.pageXOffset ? window.pageXOffset :
            ( document.body && document.body.scrollLeft > 0 ? document.body.scrollLeft : document.documentElement.scrollLeft );
}

Utils.getWindowPageYOffset = function()
{
    return window.pageYOffset ? window.pageYOffset :
            ( document.body && document.body.scrollTop > 0 ? document.body.scrollTop : document.documentElement.scrollTop );
}
// $Id: HotKey.js,v 1.8 2008/12/03 11:36:53 stiv Exp $
// You can find out charCodes using this demo:
// http://unixpapa.com/js/testkey.html

var codeTable = {};

codeTable['0'] = 48;
codeTable['1'] = 49;
codeTable['2'] = 50;
codeTable['3'] = 51;
codeTable['4'] = 52;
codeTable['5'] = 53;
codeTable['6'] = 54;
codeTable['7'] = 55;
codeTable['8'] = 56;
codeTable['9'] = 57;

codeTable['A'] = 65;
codeTable['B'] = 66;
codeTable['C'] = 67;
codeTable['D'] = 68;
codeTable['E'] = 69;
codeTable['F'] = 70;
codeTable['G'] = 71;
codeTable['H'] = 72;
codeTable['I'] = 73;
codeTable['J'] = 74;
codeTable['K'] = 75;
codeTable['L'] = 76;
codeTable['M'] = 77;
codeTable['N'] = 78;
codeTable['O'] = 79;
codeTable['P'] = 80;
codeTable['Q'] = 81;
codeTable['R'] = 82;
codeTable['S'] = 83;
codeTable['T'] = 84;
codeTable['U'] = 85;
codeTable['V'] = 86;
codeTable['W'] = 87;
codeTable['X'] = 88;
codeTable['Y'] = 89;
codeTable['Z'] = 90;

codeTable['�'] = 65;
codeTable['�'] = 66;
codeTable['�'] = 67;
codeTable['�'] = 68;
codeTable['�'] = 69;
codeTable['�'] = 70;
codeTable['�'] = 71;
codeTable['�'] = 72;
codeTable['�'] = 73;
codeTable['�'] = 74;
codeTable['�'] = 75;
codeTable['�'] = 76;
codeTable['�'] = 77;
codeTable['�'] = 78;
codeTable['�'] = 79;
codeTable['�'] = 80;
codeTable['�'] = 81;
codeTable['�'] = 82;
codeTable['�'] = 83;
codeTable['�'] = 84;
codeTable['�'] = 85;
codeTable['�'] = 86;
codeTable['�'] = 87;
codeTable['�'] = 88;
codeTable['�'] = 89;
codeTable['�'] = 90;


function HotKey(ctrlKey, altKey, shiftKey, keyCode)
{
    if (ctrlKey.constructor == String)
    {
        this.assignFromString(ctrlKey);
        this.visibleString = ctrlKey;
    }
    else
    {
        this.ctrlKey = ctrlKey;
        this.altKey = altKey;
        this.shiftKey = shiftKey;
        this.keyCode = keyCode;
        this.visibleString = this.toString();
    }
}

HotKey.prototype.assignFromString = function(str)
{
    str = str.toLocaleUpperCase();
    this.ctrlKey = (str.indexOf("CTRL") != -1);
    this.altKey = (str.indexOf("ALT") != -1);
    this.shiftKey = (str.indexOf("SHIFT") != -1);
    this.keyCode = codeTable[str.substr(str.length - 1, 1)];
};

// generate user-friendly hotkey string
HotKey.prototype.toString = function()
{
    var res;

    //noinspection PointlessBooleanExpressionJS
    if (this.ctrlKey == true)
    {
        res += "Ctrl-";
    }
    
    //noinspection PointlessBooleanExpressionJS
    if (this.altKey == true)
    {
        res += "Alt-";
    }

    //noinspection PointlessBooleanExpressionJS
    if (this.shiftKey == true)
    {
        res += "Shift-";
    }

    var foundCode = false;

    for (var chr in codeTable) {
        if (codeTable[chr] == this.keyCode) { // found key value;
            res += chr;
            foundCode = true;
            break;
        }
    }

    if (!foundCode) {
        res += "?";
    }

    return res;
};

var keyUp = new HotKey(false, false, false, 38);
var keyDown = new HotKey(false, false, false, 40);
var keyLeft = new HotKey(false, false, false, 37);
var keyRight = new HotKey(false, false, false, 39);
var keyEnter = new HotKey(false, false, false, 13);
var keyTab = new HotKey(false, false, false, 9);
var keyShiftTab = new HotKey(false, false, true, 9);


/**
 * $Id: FocusManager.js,v 1.21 2010/02/17 13:40:07 champ Exp $
 *
 * FocusManager controls retrieving and loosing focus of controls,
 * according to their nested hierarchy.
 */

FocusManager.activeControl = null;

function FocusManager()
{
}

FocusManager.prototype.isActive = function( control )
{
    if( FocusManager.activeControl == null )
    {
        return false;
    }
    return control == FocusManager.activeControl;
};

FocusManager.prototype.getActiveControlName = function()
{
    return this.controlToString(FocusManager.activeControl);
};

FocusManager.prototype.controlToString = function ( control )
{
    if( control == null )
    {
        return "null";
    }
    else
    {
        return control.getId();
    }
};

FocusManager.prototype.setActive = function( control )
{
    logByClass("FOCUS", "FocusManager.setActive(" + this.controlToString(control) + ")");
    // first time activation ?
    if( FocusManager.activeControl == null )
    {
        logByClass("FOCUS", "FocusManager.activeControl = " + this.controlToString(FocusManager.activeControl));
        FocusManager.activeControl = control;
        FocusManager.activeControl.focusReceived(); // send notification
    }

    if( FocusManager.activeControl != control && FocusManager.activeControl != null )
    {
        logByClass("FOCUS", "FocusManager.setActive: passing focus from " + this.controlToString(FocusManager.activeControl) + " to " + this.controlToString(control));
        var prevControl = FocusManager.activeControl;
        FocusManager.activeControl = control;
        prevControl.focusLost();

        FocusManager.activeControl.focusReceived();

        if( prevControl.focusLostOneTime )
        {
            prevControl.focusLostOneTime( prevControl, control );
            delete prevControl.focusLostOneTime;    
        }
    }
};

FocusManager.prototype.getControlNumber = function( parent, child )
{
    for( var i = 0; i < parent.getChildCount(); i++ )
    {
        if( parent.getChildAt(i) == child )
            return i;
    }
    trimAlert("return -1");

    return -1;
};

FocusManager.prototype.activateDeepestChild = function ()
{
    this.getDeepestFirstChild(this);
};

/**
 * Returns deepest and leftest child for parent, that can be activated.
 * If parent doesnt have child nodes, it returns itself.
 * If node has no children to activate, returns null.
 */
FocusManager.prototype.getDeepestFirstChild = function ( parent )
{
    var numChildren = parent.getChildCount ? parent.getChildCount() : 0;

    if( numChildren == 0 && parent.canBeFocused() )
    {
        return parent;
    }

    for( var i = 0; i < numChildren; i++ )
    {
        var child = parent.getChildAt(i);
        var deepestChild = this.getDeepestFirstChild(child);
        if( deepestChild != null )
        {
            return deepestChild;
        }
    }

    return null; // no activable children found
};

FocusManager.prototype.getDeepestLastChild = function ( parent )
{
    var numChildren = parent.getChildCount ? parent.getChildCount() : 0;

    if( numChildren == 0 && parent.canBeFocused() )
    {
        return parent;
    }

    for( var i = numChildren - 1; i >= 0; i-- )
    {
        var child = parent.getChildAt(i);
        var deepestChild = this.getDeepestFirstChild(child);
        if( deepestChild != null )
        {
            return deepestChild;
        }
    }

    return null; // no activable children found
};

/**
 * Finds the highest node in control hierarchy, that allows to switch to
 * the next child. If this function meets object, whitch parent has class
 * stopType, it returns such object. This option is created to limit cycling
 * inside certain type of controls.
 **/
FocusManager.prototype.getFirstSwitchableParent = function ( control, stopType )
{
    //alert("FocusManager.prototype.getFirstSwitchableParent (" +  control.id + ")");
    var parent = control.getParent();

    // can we go upper?
    if( parent == null || parent.getObjectClassName() == stopType )
    {
        return control;
    }

    var numCollegues = parent.getChildCount();

    var curControlNumber = this.getControlNumber(parent, control);

    for( var i = curControlNumber + 1; i < numCollegues; i ++ )
    {
        // have someone to switch to ?
        var child = parent.getChildAt(i);
        if( this.getDeepestFirstChild(child) != null )
        {
            return child;
        }
    }

    // try to go upper
    return this.getFirstSwitchableParent(parent, stopType);
};

/*
 * Same as getFirstSwitchableParent, but assumes back rotation
 * */
FocusManager.prototype.getFirstBackSwitchableParent = function ( control, stopType )
{
    //alert("FocusManager.prototype.getFirstSwitchableParent (" +  control.id + ")");
    var parent = control.getParent();

    if( parent == null || parent.getObjectClassName() == stopType )
    {
        return control;
    }

    var curControlNumber = this.getControlNumber(parent, control);

    for( var i = curControlNumber - 1; i >= 0; i-- )
    {
        // have someone to switch to ?
        var child = parent.getChildAt(i);
        if( this.getDeepestLastChild(child) != null )
        {
            return child;
        }
    }

    // try to go upper
    return this.getFirstBackSwitchableParent(parent, stopType);
};


/*
 * Goes to the next control in hierarchy
 * */
FocusManager.prototype.next = function()
{
    var parent = FocusManager.activeControl.getParent();
    var controlNumber = this.getControlNumber(parent, FocusManager.activeControl);
    var numCollegues = parent.getChildCount();

    if( controlNumber == -1 )
    {
        trimAlert("FocusManager.next: trying to .next() from not deepest element.");
    }

    // can we switch to the next control of this parent ?
    for( var i = controlNumber + 1; i < numCollegues; i++ )
    {
        var nextControl = parent.getChildAt(i);
        var nextDeepstChild = this.getDeepestFirstChild(nextControl);
        if( nextDeepstChild == null )
        {
            continue;
        }
        this.setActive(nextDeepstChild);
        return;
    }

    // if we can't, switch to the grandparent's next.
    var praParent = this.getFirstSwitchableParent(FocusManager.activeControl, "JSTabbedPane");

    this.setActive(this.getDeepestFirstChild(praParent));
};

// same as .next, but allows rotation in opposite order
FocusManager.prototype.prev = function()
{
    var parent = FocusManager.activeControl.getParent();
    var controlNumber = this.getControlNumber(parent, FocusManager.activeControl);

    if( controlNumber == -1 )
    {
        trimAlert("FocusManager.prev: trying to .prev() from not deepest element.");
    }

    // can we switch to the prev control of this parent ?
    for( var i = controlNumber - 1; i >= 0; i-- )
    {
        var prevControl = parent.getChildAt(i);
        var prevDeepstChild = this.getDeepestFirstChild(prevControl);
        if( prevDeepstChild == null )
        {
            continue;
        }
        this.setActive(prevDeepstChild);
        return;
    }

    // if we can't, switch to the grandparent's next.
    var praParent = this.getFirstBackSwitchableParent(FocusManager.activeControl, "JSTabbedPane");

    this.setActive(this.getDeepestLastChild(praParent));
};
/**
 * $Id: JSControl.js,v 1.39 2011/07/04 05:55:17 lan Exp $
 *
 * Base abstract class for javascript GUI
 *
 * See inheritance hierarchy here:
 * \modules\attributes\src\doc\JSFormsInheritance.PNG
 *
 * GUI widgets uses 'format' field to form UI. Format is a map with possible keys:
 *
 * - width - will pass to HTMLElement.style.width
 * - height - will pass to HTMLElement.style.height
 * - textAlign - will pass to HTMLElement.style.textAlign
 * - categorized {string} - name of entity categorized by catgories (JSEditBox)
 * - emptyOption {boolean} - if JSComboBox should have empty option (JSComboBox)
 * - noNewButton {boolean} - if JSForm should have "New" button (JSForm)
 * - changeOnlyMode {boolean} - ... (JSForm)
 * - noCommonButtons {boolean} - if JSForm should not have common buttons (JSForm)
 * - leftWidth {String} - will pass to HTMLElement.style.width of left part ob splitter (JSVerSplittedPane)
 * - rightWidth {String} - will pass to HTMLElement.style.width of right part ob splitter (JSVerSplittedPane)
 */

/**
 * Default constructor. This is abstract class, do not create its instances.
 * @constructor.
 */
function JSControl( format )
{
    // unique control ID
    this.id = this.getObjectClassName() + Utils.uid();
    // parent control
    this.parent = null;
    // ID of parent HTML node (in which this control inserted)
    this.parentNodeId = null;
    // editable HTML node
    this.HTMLNode = null;
    // control's model
    this.model = null;
    // managing focus
    this.focusManager = null;
    // UI parameters
    this.format = format || {};
    // listeners for control changes
    this.changeListeners = [];
    // flag indicating that control is in disabled state
    this.disabled = false;
    // flag indicating that control disabled by parent control
    this.disabledByParent = false;
    // flag indicating that control is in data loading state
    this.loading = false;
    // params fo jLayout
    this.layoutParams = null;
}

/**
 * Returns this control's class name.
 *
 * @return {string} control's class name.
 */
JSControl.prototype.getObjectClassName = function ()
{
    if( this && this.constructor && this.constructor.toString )
    {
        var arr = this.constructor.toString().match( /function\s*(\w+)/ );
        if( arr && arr.length == 2 )
        {
            return arr[1];
        }
    }
    return undefined;
};

/**
 * Returns unique control ID
 *
 * @return {string} unique control ID
 */
JSControl.prototype.getId = function ()
{
    return this.id;
};

/**
 * Create unique HTML node ID
 *
 * @param {string} name name to use in ID
 * @return {string} unique HTML node ID
 */
JSControl.prototype.createNodeId = function( name )
{
    return this.id + name + "_node";
};

/**
 * Returns editable DOM node that represents control ( for example <input ... />)
 *
 * @return {HTMLElement} HTML node
 */
JSControl.prototype.getHTMLNode = function ()
{
    return this.HTMLNode;
};

/**
 * Returns ID of parent HTML node
 *
 * @return {string} parent HTML node ID
 */
JSControl.prototype.getParentNodeId = function ()
{
    return this.parentNodeId;
};

/**
 * Set ID of parent HTML node.
 *
 * @param {string} id ID of parent HTML node
 */
JSControl.prototype.setParentNodeId = function ( id )
{
    this.parentNodeId = id;
};

/**
 * Set parent control in UI hierarchy.
 *
 * @param {Object} parent parent control
 */
JSControl.prototype.setParent = function( parent )
{
    this.parent = parent;
};

/**
 * Returns parent control.
 *
 * @return {JSControl} parent control
 */
JSControl.prototype.getParent = function()
{
    return this.parent;
};

/**
 * Returns parent HTML node.
 *
 * @return {string} parent HTML node
 */
JSControl.prototype.getParentNode = function ()
{
    // Return parent if it's already DOM-element
    var parent = this.getParent();
    if(parent != null && typeof parent === "object" && parent.nodeType === 1 && typeof parent.nodeName==="string") return parent;
    return document.getElementById( this.getParentNodeId() != null ?  this.getParentNodeId() : this.getParent().getId() );
};

/**
 * Set control model.
 *
 * @param {Object} model control model
 */
JSControl.prototype.setModel = function ( model )
{
    this.model = model;
    if( this.format.readOnly === undefined && model != null && model.constructor == DynamicProperty )
    {
        this.format.readOnly = model.isReadOnly();
    }
};

/**
 * Return control model.
 *
 * @return {Object} model
 */
JSControl.prototype.getModel = function()
{
    return this.model;
};

/**
 * Return name of property in DynamicPropertySet.
 *
 * abstract virtual
 *
 * @return {String} name of property in DynamicPropertySet
 */
JSControl.prototype.getModelName = function()
{
    return null;
};

/**
 * Update control's view from model.
 *
 * abstract virtual
 */
JSControl.prototype.updateView = function ()
{
    this.updateDisabledStatus();
};

/**
 * Update model from control view.
 *
 * abstract virtual
 */
JSControl.prototype.updateModel = function ()
{
};

/**
 * Return true if control was edited by user.
 *
 * @return {boolean} true if changes done
 */
JSControl.prototype.hasChanges = function ()
{
    return false;
};

/**
 * Return null if control has valid value and error message overwise.
 *
 * @return {string} null if all is OK, error message overwise
 */
JSControl.prototype.validate = function()
{
    return null;
};

/**
 * Repaints control contents.
 *
 * abstract virtual
 */
JSControl.prototype.repaint = function()
{
};

/**
 * Creates and returns HTML node for control.
 *
 * abstract virtual
 *
 * @return {HTMLElement} HTML node representing control
 */
JSControl.prototype.createHTMLNode = function()
{
    return null;
};

/**
 * Generates HTML structure of control.
 */
JSControl.prototype.generate = function()
{
    var htmlNode = this.createHTMLNode();
    if( this.getLayoutParams() != null )
    {
        htmlNode.className += " " + this.getLayoutParams();
    }
/*
    var element = document.getElementById( this.id );
    if( element != null ) // element already in DOM, remove it
    {
        element.parentNode.removeChild( element );
    }
*/
    var parent = this.getParentNode();
    parent.appendChild(htmlNode);
};

/**
 * Set parameters for jLayout algorithm.
 *
 * @param {string} layout layout parameters
 */
JSControl.prototype.setLayoutParams = function ( layout )
{
    this.layoutParams = layout;
};

/**
 * Retruns parameters for jLayout algorithm.
 *
 * @return {string} layout parameters
 */
JSControl.prototype.getLayoutParams = function ()
{
    return this.layoutParams;
};

/**
 * Toggle control's disabled state.
 *
 * @param {boolean} flag if control should be disabled
 */
JSControl.prototype.setDisabled = function ( flag )
{
    this.disabled = flag;
    this.updateDisabledStatus();
};

/**
 * Toggle control's disabled state by parent. It called when parent
 * control disabled, so it notifies children to diable too.
 *
 * @param {boolean} flag if control should be disabled
 */
JSControl.prototype.setDisabledByParent = function ( flag )
{
    this.disabledByParent = flag;
    this.updateDisabledStatus();
};

JSControl.prototype.updateDisabledStatus = function ()
{
    var readOnly = (this.format != null) && (this.format.readOnly == true);
    this.setDisabledHTMLNode( readOnly || this.disabled || this.disabledByParent || this.loading );
};

JSControl.prototype.setDisabledHTMLNode = function ( disabled )
{
    if( this.getHTMLNode() != null )
    {
        this.getHTMLNode().disabled = disabled;
    }
};

/**
 * Return control's type (input or not)
 *
 * @return {boolean} true if control is input field
 */
JSControl.prototype.isInput = function ()
{
    return false;
};

/**
 * Adds user listener, witch is invoked when control value is changed via GUI or via .setValue() call.
 *
 * Listener must have following prototype:
 *
 * function( oldValue, newValue, control, byUser )
 *
 * where:
 *  control - JSControl which HTML element changed
 *  oldValue - value before change
 *  newValue - new value
 *  byUser - flag indicating if change was made by user or system
 *
 * @param {Function} listener listener to listen value changes
 */
JSControl.prototype.addChangeListener = function ( listener )
{
    this.changeListeners[ this.changeListeners.length++ ] = listener;
};

/**
 * Method to fire value change events.
 *
 *  oldValue - value before change
 *  newValue - new value
 *
 * @param {Object} oldValue value before change
 * @param {Object} newValue new value
 * // @TODO (champ): add Event object
 */
JSControl.prototype.fireChangeListeners = function ( oldValue, newValue, control, byUser )
{
    if( byUser == undefined )
    {
        byUser = false;
    }
    for( var i = 0; i < this.changeListeners.length; i++ )
    {
        var listener = this.changeListeners[ i ];
        listener(control ? control : this, oldValue, newValue, byUser);
        logByClass("LISTENERS", "Firing user listener for " + this.id + " (" + oldValue + " -> " + newValue + ")");
    }
};


/**********************************************************************************************************************
 *          Focus stuff                                                                                               *
 **********************************************************************************************************************/

/**
 *  Goes to the grandgrandparent control in herarchy and recieves parent
 *  from that grandcontrol and returns it.
 *
 * @return {FocusManager} true if control is input field
 **/
JSControl.prototype.getFocusManager = function ()
{
    if( this.focusManager == null ) // get from parent
    {
        if( this.parent == null ) // create focus manager for super control
        {
            this.focusManager = new FocusManager();
        }
        else
        {
            this.focusManager = this.parent.getFocusManager();
        }
    }
    return this.focusManager;
};

/**
 * Return true if control  is focused.
 *
 * @return {boolean} true if control has focus
 */
JSControl.prototype.hasFocus = function()
{
    return this.getFocusManager().isActive(this);
};

/**
 * Can this control recieve focus.
 *
 * @return {boolean} true if control can receive focus
 */
JSControl.prototype.canBeFocused = function ()
{
    return true;
};

/**
 * This is a notification that control receives focus, invoked by FocusManager.
 */
JSControl.prototype.focusReceived = function()
{
};

/**
 * This is a notification that control looses focus, invoked by FocusManager.
 */
JSControl.prototype.focusLost = function()
{
};
/**
 * $Id: JSPane.js,v 1.56 2013/08/15 10:42:30 dobrynin Exp $
 *
 * JSPane is a container for other controls.
 */


/**
 * Constructor.
 *
 * @param {Object} format UI parameters
 * @constructor
 * @extends {JSControl}
 */
function JSPane( format )
{
    JSControl.call( this, format );

    // children
    this.controls = [];
    // boolean flag indicating if container has changes in children
    this.dataChanged = null;
    // boolean flag indicating that container is during passing model to children
    this.isUpdatingView = false;
    this.applyLockCount = 0; // user can't save data when this is negative
}

JSPane.prototype = new JSControl();
JSPane.superClass = JSControl.prototype;

/**
 * Returns the number of children of this component.
 *
 * @return {number} The number of children.
 */
JSPane.prototype.getChildCount = function ()
{
    return this.controls.length;
};

/**
 * Returns the child at the given index.
 *
 * @param {number} index 0-based index.
 * @return {JSControl?} The child at the given index.
 */
JSPane.prototype.getChildAt = function ( index )
{
    return this.controls[index];
};

/**
 * Adds the specified component as the last child of this component with
 * optional layout params.
 *
 * @param {JSControl?} control The new child component.
 * @param {string} layoutParams layout params.
 */
JSPane.prototype.add = function ( control, layoutParams )
{
    if( control != null )
    {
        this.controls[this.controls.length] = control;
        if( layoutParams )
        {
            control.setLayoutParams( layoutParams );
        }
        control.setParent(this);
        var self = this;
        control.addChangeListener( function( control, oldValue, newValue, byUser )
        {
            if( !self.isUpdatingView )
            {
                // check for changes
                self.lookForChanges();
            }
            // propagate change event to container listeners
            self.fireChangeListeners( oldValue, newValue, control, byUser );
        });
        // this.generate() already was called, so call generate() for child
        if( this.getHTMLNode() != null )
        {
            control.generate();
            control.updateView();
        }
    }
    else
    {
        error( "JSPane.prototype.add: control is null" );
    }
};

/**
 * Remove child control.
 *
 * @param {JSControl?} control The new child component.
 */
JSPane.prototype.remove = function ( control )
{
    for( var i = 0; i < this.getChildCount(); i++ )
    {
        if( this.getChildAt(i) == control )
        {
            this.controls.splice(i, 1);
            control.setParent( null );
            if( control.getHTMLNode() != null )
            {
                control.getHTMLNode().parentNode.removeChild( control.getHTMLNode() );
            }
            break;
        }
    }
};

/**
 * Find child control by model name.
 *
 * @return {JSControl?} The child at the given index.
 */
JSPane.prototype.findChildByModelName = function( modelName )
{
    var child = null;
    for( var i = 0; i < this.getChildCount(); i++ )
    {
        var control = this.getChildAt(i);
        if( modelName == control.getModelName() )
        {
            child = control;
            break;
        }
        else if( modelName && control.getModelName() && modelName.toUpperCase() == control.getModelName().toUpperCase() )
        {
            child = control;
            break;
        }
        else if( control.findChildByModelName )
        {
            var subChild = control.findChildByModelName( modelName );
            if( subChild != null )
            {
                child = subChild;
                break;
            }
        }
    }
    return child;
};

/**
 * Calls the given function on each of this component's children in order. If
 * {@code thisObject} is provided, it will be used as the 'this' object in the
 * function when called.
 *
 * @param {Function} f The function to call for every child component; should
 *    take 2 arguments (the child and its index).
 * @param {Object} thisObject Used as the 'this' object in f when called.
 */
JSPane.prototype.forEachChild = function( f, thisObject )
{
    for( var i = 0; i < this.getChildCount(); i++ )
    {
        var control = this.getChildAt(i);
        f.call( thisObject, control, i );
    }
};

/**
 * Set layout type for jLayout algorithm.
 *
 * @param {string} layout layout type
 */
JSPane.prototype.setLayout = function ( layout )
{
    this.layoutType = layout;
};

/**
 * Retruns layout type of jLayout algorithm.
 *
 * @return {string} layout layout type
 */
JSPane.prototype.getLayout = function ()
{
    return this.layoutType;
};

/**
 * Set flag indicating that form should fill its parent.
 *
 * @param {boolean} value true if form should fill its parent.
 */
JSPane.prototype.setFillParent = function ( value )
{
    this.fillParent = value;
};

/**
 * Set width of child controls.
 *
 * @param {int} width width of child controls
 */
JSPane.prototype.setFieldWidth = function ( width )
{
    this.fieldWidth = width;
};

/**
 * Layout child controls.
 */
JSPane.prototype.layout = function ()
{
    if( this.getLayout() != null )
    {
        var layoutParams = {};
        if( !this.firstLayout )
        {
            var width = this.fieldWidth ? this.fieldWidth : screen.width * 0.12; // todo remove hardcode
            if( this.fillParent )
            {
                var parentWidth = width;
                try
                {
                    parentWidth = jQuery( "#" + this.getParentNodeId() ).bounds().width - 10;
                }
                catch( e )
                {
                    warn( "Layout error in JSPane.layout(): " + e );
                }
                width = Math.max( width, parentWidth );
                layoutParams = {"resize": true, "width": width };
            }
            else
            {
                jQuery( "#" + this.id ).bounds( {width:width} );
            }
        }
        // call jLayout to introduce order.
        try
        {
            jQuery("#" + this.id).layout(layoutParams);
        }
        catch( e )
        {
            // @TODO (champ): investigate why exception here
            warn( "Layout error: " + e );
        }
        this.firstLayout = true;
    }
    this.forEachChild( function( control )
    {
        if( control.layout )
        {
            control.layout();
        }
    } );
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.createHTMLNode = function()
{
    this.HTMLNode = document.createElement("div");
    this.HTMLNode.id = this.getId();
    //this.HTMLNode.className = "form-props-js";
    if( this.format.style )
    {
        for( var i in this.format.style )
        {
            this.HTMLNode.style[ i ] = this.format.style[ i ];
        }
    }
    // @TODO (champ): extract as applyFormat() function
    if( this.format.width )
    {
        this.HTMLNode.style.width = this.format.width;
    }
    if( this.format.height )
    {
        this.HTMLNode.style.height = this.format.height;
    }
    if( this.format.textAlign )
    {
        this.HTMLNode.style.textAlign = this.format.textAlign;
    }
    return this.HTMLNode;
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.generate = function ()
{
    JSPane.superClass.generate.call( this );
    if( this.getLayout() != null )
    {
        this.getHTMLNode().className += " " + this.getLayout();
    }
    this.forEachChild( function( control )
    {
        control.generate();
    } );

    var horizontal = this.format.horizontal;
    if( horizontal )
    {
        this.getHTMLNode().style.display = "table";
    }
    for( var i = 0; i < this.getChildCount(); i++ )
    {
        var control = this.getChildAt(i);
        if( control.getHTMLNode() != null && horizontal )
        {
            control.getHTMLNode().style.display = "table-cell";
        }
    }

    this.forEachChild( function( control )
    {
        if( control.init )
        {
            control.init();
        }
    } );
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.setModel = function ( model )
{
    this.model = model;
    this.forEachChild( function( control )
    {
        if( control.getModelName() != null )
        {
            if( model != null && model.getProperty )
            {
                control.setModel( model.getProperty( control.getModelName() ) );
            }
            else
            {
                control.setModel( null );
            }
        }
        else
        {
            control.setModel( model );
        }
    } );
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.updateView = function ()
{
    var hasChanges = this.hasChanges();
    this.isUpdatingView = true;
    this.forEachChild( function( control )
    {
        control.updateView();
    } );
    this.isUpdatingView = false;
    this.lookForChanges();
    if( hasChanges != this.hasChanges() )
    {
        this.fireChangeListeners( hasChanges, this.hasChanges(), this );
    }
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.updateModel = function ()
{
    this.forEachChild( function( control )
    {
        control.updateModel();
    } );
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.validate = function ()
{
    var error = null;
    for( var i = 0; i < this.getChildCount() && error == null; i++ )
    {
        var control = this.getChildAt(i);
        error = control.validate();
    }
    return error;
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.repaint = function ()
{
    this.forEachChild( function( control )
    {
        control.repaint();
    } );
};

JSPane.prototype.lookForChanges = function ()
{
    var dataChanged = false;
    for( var i = 0; i < this.getChildCount(); i++ )
    {
        var control = this.getChildAt(i);
        if( control.lookForChanges )
        {
            control.lookForChanges();
        }
        var hasChanges = control.hasChanges();
        if( hasChanges )
        {
            //debug("champ: control.getModelName()=" + control.getModelName());
            if( control.getValue )
            {
                //debug( control.getModelName() + " value="+control.getValue() + " model=" + control.getModelValue());
            }
        }
        dataChanged = dataChanged || hasChanges;
    }
    this.dataChanged = dataChanged;
};

/**
 * @inheritDoc
 * @override
 */
JSPane.prototype.hasChanges = function ()
{
    return this.dataChanged;
};

JSPane.prototype.decApplyLockCounter = function()
{
    this.applyLockCount++;
};

JSPane.prototype.incApplyLockCounter = function()
{
    this.applyLockCount--;
};


/**********************************************************************************************************************
 *          Focus stuff                                                                                               *
 **********************************************************************************************************************/

JSPane.prototype.activateChild = function( child )
{
    this.focusReceived();
    if( child != null && child != this )
    {
        this.getFocusManager().setActive(child);
    }
};

JSPane.prototype.activateDeepestChild = function()
{
    this.activateChild( this.getFocusManager().getDeepestFirstChild(this) );
};
/**
 * $Id: JSLabel.js,v 1.15 2011/10/18 10:23:26 slavan Exp $
 *
 * Label.
 */

function JSLabel( text, format )
{
    JSControl.call( this, format );

    this.text = text;
    this.textSpan = null;
    this.propertyInfo = null;
}

JSLabel.prototype = new JSControl();

// override
JSLabel.prototype.createHTMLNode = function()
{
    this.HTMLNode = document.createElement("div");
    this.HTMLNode.style.verticalAlign = "middle";
    this.HTMLNode.className = this.format.className != null ? this.format.className : null;

    this.textSpan = document.createElement("span");
    this.textSpan.style.display = "table-cell";
    this.textSpan.innerHTML = this.text;
    this.applyFormat( this.format )

    this.HTMLNode.appendChild( this.textSpan )
    if( this.format != null )
    {
        if( this.format.center )
        {
            this.HTMLNode.style.textAlign = "center";
        }
        if( this.format.left )
        {
            this.HTMLNode.style.textAlign = "left";
        }
        if( this.format.right )
        {
            this.HTMLNode.style.textAlign = "right";
        }
    }
    return this.HTMLNode;
};

JSLabel.prototype.canBeFocused = function ()
{
    return false;
};

// override
JSLabel.prototype.updateView = function()
{
    this.repaint();
};

JSLabel.prototype.repaint = function()
{
    if( this.propertyInfo != null && this.getHTMLNode() != null )
    {
        var format = this.format || {};
        format.bold = this.propertyInfo.getCanBeNull() == "no";// && !format.readOnly;
        this.applyFormat( this.format )
    }
};

JSLabel.prototype.bindPropertyInfo = function( propertyInfo )
{
    this.propertyInfo = propertyInfo;
    var self = this;
    this.propertyInfo.addChangeListener( function( e )
    {
        // @TODO (champ): add event type check
        //if( e.type == DynamicProperty.READ_ONLY )
        {
            self.updateView();
        }
    } );
};

JSLabel.prototype.applyFormat = function( format )
{
    if( format != null )
    {
        this.textSpan.style.fontWeight = format.bold ? "bold" : "";
        this.textSpan.style.fontStyle = format.italic ? "italic" : "";
    }
};
/**
 * $Id: JSInput.js,v 1.78 2013/09/11 08:49:22 dobrynin Exp $
 *
 * Input edit box or combobox.
 *
 * See inheritance hierarchy here:
 * \modules\attributes\src\doc\JSFormsInheritance.PNG
 */

function JSInput( propInfo, format )
{
    JSControl.call( this, format );

    if( arguments.length > 0 && !propInfo )
    {
        throw "JSInput.propInfo is null";
    }
    this.propInfo = propInfo;
    this.HTMLNode = null;
    this.defaultValueUsed = false;
    // boolean flag indicating if container has changes in children
    this.dataChanged = false;
    this.hookKeyboard();
}

JSInput.prototype = new JSControl();
JSInput.superClass = JSControl.prototype;

JSInput.prototype.getModelName = function()
{
    return this.propInfo != null ? this.propInfo.getName() : null;
};

JSInput.prototype.getHTMLNode = function()
{
    return this.HTMLNode;
};

JSInput.prototype.setHTMLNode = function( node )
{
    this.HTMLNode = node;
};

JSInput.prototype.canBeFocused = function ()
{
    if( this.format != null && this.format.readOnly )
    {
        return false;
    }

    return this.getHTMLNode() && !this.getHTMLNode().disabled;
};

JSInput.prototype.getChildCount = function ()
{
    return 0;
};

//noinspection JSUnusedLocalSymbols
JSInput.prototype.getChildAt = function ( n )
{
    return null;
};

JSInput.prototype.getModelValue = function()
{
    var result = "";
    if( this.getModel() != null )
    {
        var value = this.getModel().getValue();
        if( value !== null && value !== undefined && value !== "" )
        {
            result = value;
        }
    }
    return result;
};

JSInput.prototype.updateView = function ()
{
    if( this.getModel() != null )
    {
        this.setValue(this.getModelValue());
        this.repaint();
    }
/*
    else
    {
        this.setValue( null );
    }
*/
};

JSInput.prototype.updateModel = function ()
{
    var property = this.getModel();
    if( property != null && !this.format.readOnly )
    {
        property.setValue(this.getValue());
    }
};

/**
 * @inheritDoc
 * @override
 */
JSInput.prototype.hasChanges = function ()
{
    return this.loading ? false : this.dataChanged;
};

JSInput.prototype.lookForChanges = function ()
{
    var dataChanged = false;
    if( this.getModel() && this.getValue() != null && !this.defaultValueUsed && !this.format.readOnly)
    {
        dataChanged = this.getValue() != this.getModelValue();
        if( dataChanged )
        {
            //debug( this.getModelName() + " value="+this.getValue() + " model=" + this.getModelValue());
        }
    }
    this.dataChanged = dataChanged;
};

JSInput.prototype.validate = function ()
{
    var error = null;

    var empty = false;
    var value = this.getValue();
    if (typeof value == 'string')
    {
        empty = Utils.trim(value) == "";
    }
    else
    {
        empty = value == null || value == undefined;
    }

    if( empty )
    {
        if( this.propInfo.getCanBeNull() == "no" && !this.format.readOnly )
        {
            error = getMessage("Validation error") + " " + getMessage("of field") +
                    " '" + this.propInfo.getDisplayName() + "': " + getMessage("Field must be not empty");
        }
    }
    else
    {
        error = this.validateSemanticRules();
    }
    return error;
};

JSInput.prototype.validateSemanticRules = function ()
{
    var error = null;
    var semanticRules = this.propInfo.getAttribute("semanticRule");
    if( semanticRules != null && semanticRules.length > 0 )
    {
        var value = this.getValue();
        for( var idx = 0 ; idx < semanticRules.length ; ++idx )
        {
            var semanticRule = semanticRules[ idx ];
            // @TODO (champ): validate other types
            if( semanticRule.getType() == "mask" && ( this.propInfo.getType() == "string" ||
                this.propInfo.getType() == "date" || this.propInfo.getType() == "number" || this.propInfo.getType() == "currency" ||
                this.propInfo.getType() == "real" ) )
            {
                // @TODO (champ): investigate - why so special for JS?
                var regexp = new RegExp("^" + semanticRule.getCode() + "$");
                if( !regexp.test(value) )
                {
                    error = getMessage("Validation error") + " " + getMessage("of field") +
                            " '" + this.propInfo.getDisplayName() + "': " + semanticRule.getDescription();
                }
            }
            else if( semanticRule.getType() == "javascript" )
            {
                var script = semanticRule.getScript();
                var validateFunc = new Function( "value", script );
                error = validateFunc( value );
            }
            else if( semanticRule.getType() == "interval" )
            {
                var mask = semanticRule.getCode();

                if( mask.length != 2 )
                {
                    error = getMessage( "Semantic rule parse exception. " ) + " " + getMessage( "Name" ) + " : " + getMessage( semanticRule.getName() ) + ". ";
                }
                else
                {
                    var from = parseFloat( mask[0] );
                    var to = parseFloat( mask[1] );

                    if( isNaN( from ) )
                    {
                        error = getMessage( "Semantic rule parse exception." ) + 
                            " " + getMessage( "Name" ) + " : " + 
                            getMessage( semanticRule.getName() ) + ". " +
                            getMessage( "Reason" ) +  ": " + mask[0] + " " +
                            getMessage( "is not a number" );
                    }
                    else if( isNaN( to ) )
                    {

                        error = getMessage( "Semantic rule parse exception." ) + 
                            " " + getMessage( "Name" ) + " : " + 
                            getMessage( semanticRule.getName() ) + ". " +
                            getMessage( "Reason" ) +  ": " + mask[1] + " " +
                            getMessage( "is not a number" );
                    }
                    else
                    {
                        var parsedValue = parseFloat( value );
                        var isNumber = new RegExp( "^[\\d]*[\\.]{0,1}[\\d]{0,2}$" );

                        var getMaxFractPart = function( numStr ) {
                            numStr = String( numStr );
                            return numStr.indexOf( "." ) != -1 ? numStr.substring( numStr.indexOf( "." ) + 1, numStr.length ).length : 0;
                        }

                        var maxFractPartFrom = getMaxFractPart( mask[0] );
                        var maxFractPartTo = getMaxFractPart( mask[1] );
                        var maxFractPart = maxFractPartFrom > maxFractPartTo ? maxFractPartFrom : maxFractPartTo;
                        var endWithDec = Utils.trim( String( value ) )[ Utils.trim( String( value ) ).length - 1 ] === ".";

                        if( endWithDec || !isNumber.test( value ) || !isFinite( parsedValue ) || parsedValue < from || parsedValue > to || maxFractPart < getMaxFractPart( value ) )
                        {
                            error = getMessage( "Validation error" ) + " " + getMessage( "of field" ) +
                                " '" + this.propInfo.getDisplayName() + "': " + semanticRule.getDescription();
                        }
                    }
                }
            }
        }
    }
    return error;
};

JSInput.prototype.getValue = function()
{
    if( this.loading == true )
    {
        return "";
    }
    var ret = this.getHTMLNode() != null ? this.getHTMLNode().value : null;
    return ret;
};

/**
 * Method return old HTML value. Child classes may override this method for special situations.
 */
JSInput.prototype.getOldValue = function()
{
    return this.getValue();
};

JSInput.prototype.setValue = function( newValue )
{
    //logByClass("VALUES", this.id + ".setValue(" + val + ");");
    var oldValue = this.getOldValue();
    if( this.getHTMLNode() != null )
    {
        if( newValue == "" && this.propInfo.getDefaultValue() )
        {
            this.defaultValueUsed = true;
            newValue = this.propInfo.getDefaultValue();
        }
        this.getHTMLNode().value = newValue;

        //(shanshin) bug fix in card while selected address row (don't print street).
        this.selectedValue = newValue;
        if( this.format.defaultTitle )
        {
            this.getHTMLNode().title = newValue;
        }
        this.lookForChanges();
        this.fireChangeListeners(oldValue, this.getHTMLNode( ).value);
    }
    else // @TODO (champ): is it really needed?
    {
        this.fireChangeListeners(oldValue, newValue);
    }
};

// override
JSInput.prototype.generate = function()
{
    var parent = this.getParentNode();
    var htmlNode = this.createHTMLNode();
    if( this.getLayoutParams() != null )
    {
        htmlNode.className += " " + this.getLayoutParams();
    }

    // fire change events on user changes
    var self = this;
    addModificationListener(this.HTMLNode, function( oldValue, newValue )
    {
        if( self.defaultValueUsed && newValue != self.propInfo.getDefaultValue() )
        {
            self.defaultValueUsed = false;
        }
        self.lookForChanges();
        self.fireChangeListeners(oldValue, newValue, self, true);
        self.repaint();
    });
    parent.appendChild(htmlNode);
};

/**
 * @inheritDoc
 * @override
 */
JSInput.prototype.repaint = function()
{
    if( !this.getHTMLNode().disabled )
    {
        if( this.validate() == null )
        {
            if( this.hasChanges() )
            {
                this.getHTMLNode().style.backgroundColor = "#FFFFBB"; // "gold"
            }
            else
            {
                this.getHTMLNode().style.backgroundColor = "";
            }
        }
        else
        {
            this.getHTMLNode().style.backgroundColor = "#FFCCCC"; // "salmon"
        }
    }
    else
    {
        this.getHTMLNode().style.backgroundColor = "";
    }
};

/**
 * Use default control height.
 */
JSInput.prototype.layout = function ()
{
    if( this.getHTMLNode() != null )
    {
        this.getHTMLNode().style.height = null;
    }
};

JSInput.prototype.onMouseDown = function ()
{
    this.getFocusManager().setActive(this);
};

// this method will be called after inserting valueElem into
// document tree to do additional custom initialisation
JSInput.prototype.init = function ()
{
};

JSInput.prototype.focusReceived = function ()
{
    this.getHTMLNode().focus();
    if( isIE() ) // hack for IE to put cursor at the end of input
    {
        this.getHTMLNode().value = this.getHTMLNode().value;
    }
};

JSInput.prototype.focusLost = function ()
{
    this.getHTMLNode().blur();
};

JSInput.prototype.hookKeyboard = function ()
{
    var me = this;

    keyHooker.addListener(keyUp, function()
    {
        return me.onKeyUpPress();
    });

    keyHooker.addListener(keyDown, function()
    {
        return me.onKeyDownPress();
    });

    keyHooker.addListener(keyEnter, function()
    {
        return me.onKeyEnterPress();
    });

    keyHooker.addListener(keyTab, function()
    {
        return me.onKeyTab();
    });

    keyHooker.addListener(keyShiftTab, function()
    {
        return me.onKeyShiftTab();
    });
};

JSInput.prototype.onKeyTab = function()
{
    if( !this.hasFocus() )
    {
        return false;
    }
    this.getFocusManager().next();
    return true;
};

JSInput.prototype.onKeyShiftTab = function()
{
    if( !this.hasFocus() )
    {
        return false;
    }
    this.getFocusManager().prev();
    return true;
};

JSInput.prototype.isActive = function()
{
    var id = (this.HTMLNode == null) ? null : this.HTMLNode.id;
    return ( this.hasFocus() && !this.disabled && jQuery('#' + id).is(":visible") );
};

JSInput.prototype.onKeyUpPress = function()
{
    if( !this.isActive() )
    {
        return false;
    }
    // delay focus change, to avoid strange FF behaviour
    var me = this;
    setTimeout(function()
    {
        me.getFocusManager().prev();
    }, 1);
    return true;
};

JSInput.prototype.onKeyDownPress = function()
{
    if( !this.isActive() )
    {
        return false;
    }

    // delay focus change, to avoid strange FF behaviour
    var me = this;
    setTimeout(function()
    {
        me.getFocusManager().next();
    }, 1);

    return true;
};

JSInput.prototype.onKeyEnterPress = function()
{
    if( !this.isActive() )
    {
        return false;
    }
    this.getFocusManager().next();
    return true;
};

JSInput.prototype.isInput = function()
{
    return true;
};

JSInput.prototype.load = function( entity, query, selector, noReplaceIfNull, additionalUrlParams, notUseCache )
{
    if( Cache.getItem( entity + query + selector ) === undefined || notUseCache)
    {
        // start loading
        var params = [];
        if( additionalUrlParams != null )
        {
            params = additionalUrlParams;
        }
        if( selector != null )
        {
            params[ params.length ]  = [ "selector", selector ];
        }
        this.HTMLNode.loading = true;
        var me = this;
        calcUsingQuery(entity, query,
        {
            urlPrefix: location.toString().indexOf("file:") >= 0 ? context + "/" : null,
            search: true,
            timeout: 60000,
            limit: 5000,
            doNotShowLoading: true,
            params: params,
            listener:
                    function( list )
                    {
                        var value = "";
                        if( list != null )
                        {
                            Cache.setItem( entity + query + selector, list );
                            if( me.HTMLNode.loading != null )
                            {
                                me.HTMLNode.loading = null;
                                if( list.length == 1 )
                                {
                                    value = ( !isEmpty( list[0] ) ) ? list[0] : ( noReplaceIfNull ? me.getModelValue() : "" );
                                }
                                else
                                {
                                    for( var i = 0; i<list.length; i++ )
                                    {
                                        if( value != "" )
                                        {
                                            value += "\n";
                                        }
                                        var items = list[i];
                                        for( var j = 0; j<items.length; j++ )
                                        {
                                            var item = items[j];
                                            value += ( j > 0 ? ": " : "" ) + item;
                                        }
                                    }
                                }
                            }
                        }
                        me.HTMLNode.value = getMessage( value );
                    },
            timeoutListener:
                    function()
                    {
                        me.HTMLNode.loading = null;
                    }
        } );
    }
    else
    {
        var list = Cache.getItem( entity + query + selector );
        this.HTMLNode.value = ( !isEmpty( list[0] ) ) ? list[0] : ( noReplaceIfNull ? this.getModelValue() : "" );
    }
};
/**
 * $Id: JSButton.js,v 1.21 2012/03/30 10:43:00 champ Exp $
 *
 * Label.
 */

function JSButton( text, format )
{
    JSControl.call( this, format );

    this.hookKeyBoard();
    this.text = text;
    this.clickEvent = null;
    this.ctrlClickEvent = null;
}

JSButton.prototype = new JSControl();
JSButton.superClass = JSControl.prototype;

// global JSTable format options
JSButton.FORMAT = {};
JSButton.FORMAT.nativeButton = false;

JSButton.prototype.getChildCount = function ()
{
    return 0;
};

//noinspection JSUnusedLocalSymbols
JSButton.prototype.getChildAt = function ( n )
{
    return null;
};

JSButton.prototype.createHTMLNode = function()
{
    return JSButton.FORMAT.nativeButton ? this.createHTMLNodeOld() : this.createHTMLNodeNew();
};

JSButton.prototype.getButtonID = function()
{
    return "_btn_text_" + this.id;
};

// override
JSButton.prototype.createHTMLNodeNew = function()
{
    var container = document.createElement("div");
    container.className = "buttonContainer";
    container.tabIndex = "0";

    var button = document.createElement("div");
    button.id = "_r_" + this.getButtonID();
    button.tabIndex = "0";
    button.className = "customButton unfocusedButton " + ( isFF() ? "mozButtonGradient" : "webkitButtonGradient" );

    var text = document.createElement("div");
    text.id = this.getButtonID();
    text.innerHTML = this.text;
    button.appendChild( text );

    var me = this;
    button.onmousedown = function( event )
    {
        if( !me.disabled )
        {
            $( button ).addClass( isFF() ? "mozButtonGradientReversed" : "webkitButtonGradientReversed" );
            $( button ).removeClass( isFF() ? "mozButtonGradient" : "webkitButtonGradient" );
            me.onMouseDown();
        }
        return false;
    };
    button.onmouseout = function( event )
    {
        if( !me.disabled )
        {
            $( button ).addClass( isFF() ? "mozButtonGradient" : "webkitButtonGradient" );
            $( button ).removeClass( isFF() ? "mozButtonGradientReversed" : "webkitButtonGradientReversed" );
        }
    };
    button.onmouseup = function( event )
    {
        if( !me.disabled )
        {
            $( button ).addClass( isFF() ? "mozButtonGradient" : "webkitButtonGradient" );
            $( button ).removeClass( isFF() ? "mozButtonGradientReversed" : "webkitButtonGradientReversed" );
            me.onClick(event);
        }
    };
    button.onkeydown = function ()
    {
        if( !me.disabled )
        {
            me.onKeyDown();
        }
    };

    container.appendChild(button);

    this.HTMLNode = container;
    this.HTMLNode.id = this.id;

    this.HTMLNode.style.opacity = this.disabled ? "0.4" : "1";

    return this.HTMLNode;
};

JSButton.prototype.createHTMLNodeOld = function()
{
    this.HTMLNode = document.createElement("input");
    this.HTMLNode.id = this.id;
    this.HTMLNode.className = "button-js";
    this.HTMLNode.type = "button";
    this.HTMLNode.value = this.text;

    var me = this;

    this.HTMLNode.onkeydown = function ()
    {
        me.onKeyDown();
    };

    this.HTMLNode.onclick = function ( event )
    {
        me.onClick(event);
    };

    this.HTMLNode.onmousedown = function()
    {
        me.onMouseDown();
    };

    return this.HTMLNode;
};


JSButton.prototype.setText = function ( text )
{
    var button = document.getElementById( this.getButtonID() );
    if( button )
    {
        button.innerHTML = text;
    }
    else
    {
        this.text = text;
    }
};

JSButton.prototype.setDisabledHTMLNode = function ( disabled )
{
    if( !JSButton.FORMAT.nativeButton )
    {
        var html = this.getHTMLNode();
        if( html != null )
        {
            html.style.opacity = disabled ? "0.4" : "1";
        }
    }
    else
    {
        JSButton.superClass.setDisabledHTMLNode.call( this, disabled );
    }
};

JSButton.prototype.onClick = function( event )
{
    logByClass("KEYBOARD", this.getId() + ".onClick()");
    if ((window.event && window.event.ctrlKey) || (!window.event && event.ctrlKey))
    {
        this.ctrlClickEvent( this );
    }
    else if( this.clickEvent != null )
    {
        this.clickEvent( this );
    }
};

JSButton.prototype.onKeyDown = function ()
{
    logByClass("KEYBOARD", this.getId() + ".onKeyDown()");
    this.getFocusManager().setActive(this);
};

JSButton.prototype.onMouseDown = function ()
{
    this.getFocusManager().setActive(this);
};

JSButton.prototype.canBeFocused = function ()
{
    return !this.disabled;
};

JSButton.prototype.setClickEvent = function ( fn )
{
    this.clickEvent = fn;
};

JSButton.prototype.setCtrlClickEvent = function ( fn )
{
    this.ctrlClickEvent = fn;
};

JSButton.prototype.getClickEvent = function ()
{
    return this.clickEvent;
};

JSButton.prototype.getCtrlClickEvent = function ()
{
    return this.ctrlClickEvent;
};

JSButton.prototype.focusReceived = function()
{
    if( this.HTMLNode != null )
    {
        if( !JSButton.FORMAT.nativeButton )
        {
            var id = "_r_" + this.getButtonID();
            jQuery( "#" + id ).addClass("focusedButton").removeClass("unfocusedButton");
        }
        this.HTMLNode.focus();
    }
};

JSButton.prototype.focusLost = function()
{
    if( this.HTMLNode != null )
    {
        if( !JSButton.FORMAT.nativeButton )
        {
            var id = "_r_" + this.getButtonID();
            jQuery( "#" + id ).addClass("unfocusedButton").removeClass("focusedButton");
        }
        this.HTMLNode.blur();
    }
};

JSButton.prototype.onKeyTab = function()
{
    if( !this.hasFocus() )
    {
        return false;
    }
    this.getFocusManager().next();
    return true;
};

JSButton.prototype.onKeyShiftTab = function()
{
    if( !this.hasFocus() )
    {
        return false;
    }
    this.getFocusManager().prev();
    return true;
};

JSButton.prototype.onKeyEnter = function()
{
    if( !this.hasFocus() )
    {
        return false;
    }
    if( this.clickEvent != null )
    {
        this.clickEvent();
    }
    return true;
};

JSButton.prototype.hookKeyBoard = function()
{
    var me = this;

    keyHooker.addListener(keyTab, function()
    {
        return me.onKeyTab();
    });

    keyHooker.addListener(keyShiftTab, function()
    {
        return me.onKeyShiftTab();
    });

    keyHooker.addListener(keyEnter, function()
    {
        return me.onKeyEnter();
    });

};
/**
 * $Id: JSEditBox.js,v 1.24 2012/05/22 12:57:43 champ Exp $
 *
 * Input edit box or combobox.
 */

function JSEditBox( propInfo, format )
{
    JSInput.apply( this, arguments );
}

JSEditBox.prototype = new JSInput();

// override
JSEditBox.prototype.createHTMLNode = function()
{
    var propName = this.propInfo.getName();

    if( this.format != null && this.format.textArea )
    {
        this.HTMLNode = document.createElement("textarea");
        if( this.format.textRows != null )
        {
            this.HTMLNode.rows = this.format.textRows;
        }
    }
    else
    {
        this.HTMLNode = document.createElement("input");
        this.HTMLNode.type = "text";
    }

/*
    if( this.propInfo.getCanBeNull() === "no" )
    {
        this.HTMLNode.required = true;
    }
*/
    if( this.format.readOnly )
    {
        this.HTMLNode.readOnly = true;
    }
    if( this.format.visibility )
    {
        this.HTMLNode.style.visibility = this.format.visibility;
    }
    this.HTMLNode.id = this.createNodeId(propName);
    if( this.propInfo.getType() == "currency" )
    {
        //$.mask.masks.decimal_alt = {mask: '99.99999999', type : 'reverse', defaultValue : '000'};
        //this.HTMLNode.alt = "decimal_alt";
    }

    if( this.changeListener != null )
    {
        addModificationListener(this.HTMLNode, this.changeListener);
    }

    var me = this;

    this.HTMLNode.onmousedown = function()
    {
        me.onMouseDown(propName);
    };

    if( this.format.categorized != null )
    {
        var div = document.createElement("div");
        this.HTMLNode.style.cssFloat = "left";
        this.HTMLNode.style.styleFloat = "left"; // forIE
        this.HTMLNode.style.marginLeft = "0px"; // fix fo default Chrome user agent style
        div.appendChild( this.HTMLNode );
        var calButton = document.createElement("input");
        calButton.id = this.createNodeId(this.propInfo.getName()) + "button";
        calButton.type = "image";
        calButton.src = "images/writing.gif";
        calButton.value = "...";
        calButton.onclick = function()
        {
            ( new CategorySelector() ).show( me.format.categorized, me.getHTMLNode() );
        };

        var iconDiv = document.createElement("div");
        iconDiv.id = "iconDiv" + this.id;
        iconDiv.style.cssFloat = "left";
        iconDiv.style.styleFloat = "left"; // forIE
        iconDiv.style.paddingTop = "3px";
        iconDiv.style.paddingLeft = "6px";
        iconDiv.appendChild(calButton);

        iconDiv.style.visibility = this.format.readOnly ? "hidden" : "visible";

        div.appendChild(iconDiv);
        return div;
    }
    else
    {
        return this.HTMLNode;
    }
};
/**
 * $Id: JSCheckBox.js,v 1.16 2011/11/09 04:38:46 champ Exp $
 *
 * Input chechbox.
 */
function JSCheckBox(propInfo, format)
{
    JSInput.call( this, propInfo, format );
}

JSCheckBox.prototype = new JSInput();

// override
JSCheckBox.prototype.createHTMLNode = function()
{
    var propName = this.propInfo.getName();
    this.HTMLNode = document.createElement("input");
    this.HTMLNode.type = "checkbox";

    if (this.format.readOnly)
    {
        this.HTMLNode.disabled = true;
    }
    this.HTMLNode.id = this.createNodeId(propName);

    if (this.changeListener != null)
    {
        addModificationListener(this.HTMLNode, this.changeListener);
    }

/* removed duplicated listeners call
    var curValue = me.HTMLNode.checked;
    this.HTMLNode.onclick = function(event)
    {
        if (curValue != me.HTMLNode.checked)
        {
            me.fireChangeListeners(curValue, me.HTMLNode.checked, me, true);
            curValue = me.HTMLNode.checked;
        }
    }
*/
    var me = this;

    this.HTMLNode.onmousedown = function()
    {
        me.onMouseDown(propName);
    };

    return this.HTMLNode;
};

JSCheckBox.prototype.getValue = function()
{
    if (this.loading == true)
    {
        return false;
    }
    // cast it to string to avoid a lot of problems
    // mapped to _DBMS_BOOLEAN() in M4
    return this.getHTMLNode() != null && this.getHTMLNode().checked ? "yes" : "no";
};

JSCheckBox.prototype.setValue = function(val)
{
    logByClass("VALUES", this.id + ".setValue(" + val + ");");
    if( this.getHTMLNode() != null )
    {
        var oldValue = this.getHTMLNode().checked;
        if( val == "" && this.propInfo.getDefaultValue() )
        {
            this.defaultValueUsed = true;
            val = this.propInfo.getDefaultValue();
        }
        this.getHTMLNode().checked = (val == true || val == "true" || val == "yes" || val == "on  ");
        this.fireChangeListeners(oldValue, this.getHTMLNode().checked);
    }
};


/**
 * $Id: JSComboBox.js,v 1.93 2013/10/01 08:23:42 dobrynin Exp $
 *
 * Combobox.
 */

function JSComboBox( propInfo, format, tokens )
{
    JSInput.apply( this, arguments );

    this.tokens = tokens;
    this.loading = false;
    this.selectedValue = null;
    this.dynamicOldValue = null;
    this.FILTER_DIV = "FILTER_DIV";
}

JSComboBox.prototype = new JSInput();
JSComboBox.superClass = JSInput.prototype;

JSComboBox.prototype.setLoading = function ( loading )
{
    this.loading = loading;
    this.updateDisabledStatus();
};

JSInput.prototype.layout = function ()
{
    if( this.getHTMLNode() != null )
    {
        this.getHTMLNode().style.height = null;
    }

    if( this.format.chosen && this.HTMLNode != null )
    {
        var format_chosen = this.format.chosen;
        format_chosen.id = this.HTMLNode.id;
        if( jQuery( "#" + format_chosen.id + "_chosen" ).length == 0 )
        {
            var me = this;
            var style = jQuery( "#" + format_chosen.id ).prop( "style" );
            jQuery( "#" + format_chosen.id ).chosen( {
                placeholder_text_single: ( format_chosen.message ) ? format_chosen.message : getMessage("Change value") + "",
                no_results_text: getMessage( "No results text" ),
                allow_single_deselect: true,
                search_contains: true
            }
            ).change( function( event )
            {
                me.fireChangeListeners( jQuery.data( jQuery( this ), "oldVal" ), jQuery( this ).val(), me, true );
                jQuery.data( jQuery( this ), "oldVal", jQuery( this ).val() );
            } );
            jQuery.data( jQuery( "#" + format_chosen.id ), "oldVal", this.getOldValue() );
            jQuery( "#" + format_chosen.id )
            var chosen = jQuery( "#" + format_chosen.id + "_chosen" );
            if( format_chosen.classes )
            {
                chosen.addClass( format_chosen.classes );
            }
            chosen.prop( "style", style ).on( "click", function( event )
            {
                me.getFocusManager().setActive( me );
            }
            ).on( "keypress", function( event )
            {
                var keyCode = event.keyCode || event.which;

                if ( keyCode == 9 )
                {
                    if( event.shiftKey )
                    {
                        me.onKeyShiftTab();
                    }
                    else
                    {
                        me.onKeyTab();
                    }
                }
            } );
        }
    }
};

// override
JSComboBox.prototype.createHTMLNode = function()
{
    this.HTMLNode = document.createElement("select");
    this.HTMLNode.className = "form-value-control-el-js";
    this.HTMLNode.id = this.createNodeId(this.propInfo.getName());
    this.enclosingDivNode=document.createElement("div");
    this.enclosingDivNode.id="encldiv_"+this.HTMLNode.id;
    var dictionary = null;
    if( ( !this.tokens || this.tokens == null ) && this.propInfo.getAttribute("dictionaryName") != null )
    {
        var dictionaryName = this.propInfo.getAttribute("dictionaryName");
        dictionary = dictionaries.getDictionary(dictionaryName);
        if( dictionary != null )
        {
            this.tokens = dictionary.getPairs();
        }
        else
        {
            var parent = this.getParent();
            if( parent != null )
            {
                parent.incApplyLockCounter();
            }
            this.tokens = { EMPTY: getMessage("Loading...") };
            this.setLoading( true );
            var self = this;
            dictionaries.loadDictionary( dictionaryName, function( dictionary )
            {
                var addEmpty = self.format.emptyOption || self.propInfo.getCanBeNull() != "no";
                var tokens = [];
                if( dictionary != null )
                {
                    for( var idx = 0 ; idx < dictionary.getKeys().length ; ++idx )
                    {
                        var key = dictionary.getKeys()[ idx ];
                        var value = dictionary.get( key );
                        tokens[ tokens.length ] = [ key, value ];
                    }
                }
                self.setLoading( false );
                self.setup( tokens, self.getModelValue(), addEmpty);
                if( parent != null )
                {
                    parent.decApplyLockCounter();
                }
            } );
        }
    }
    if( ( this.format.emptyOption || this.propInfo.getCanBeNull() != "no" ) && !this.loading )
    {
        var option = document.createElement("option");
        option.value = this.format.emptyValue ? this.format.emptyValue : EMPTY;
        option.innerHTML = "";
        this.HTMLNode.appendChild(option);
    }
    if( dictionary != null )
    {
        for( var idx = 0 ; idx < dictionary.getKeys().length ; ++idx )
        {
            var key = dictionary.getKeys()[ idx ];
            option = document.createElement("option");
            option.value = key;
            option.innerHTML =  ( this.format.showDictionaryCode ? option.value + " - " : "" ) + getMessage( dictionary.get( key ) );
            this.HTMLNode.appendChild(option);
        }
    }
    else
    {
        for( var value in this.tokens )
        {
            var displayName = this.tokens[ value ];
            option = document.createElement("option");
            option.value = value;
            option.innerHTML = ( this.format.showDictionaryCode ? option.value + " - " : "" ) + getMessage(displayName);
            this.HTMLNode.appendChild(option);
        }
    }

/*
    if( this.propInfo.getCanBeNull() === "no" )
    {
        this.HTMLNode.required = true;
    }
*/

    if( this.format.readOnly )
    {
        this.HTMLNode.disabled = true;
    }

    if( this.format.sortedByHTML )
    {
        this.sortByHTML();
    }

    var me = this;
    if( isIE() )
    {
        this.dontWiden = false;
        var shrink = function(e)
        {
            if( me.originalWidth )
            {
                me.HTMLNode.style.width = me.originalWidth;
                me.HTMLNode.style.zIndex = me.originalzIndex;
            }
        };
        var widen = function( e )
        {
            if( !me.originalWidth )
            {
                me.originalWidth = me.HTMLNode.style.width;
                me.originalzIndex = me.HTMLNode.style.zIndex;
            }
            if( me.dontWiden )
            {
                return;
            }
            var styledWidth = me.HTMLNode.offsetWidth;
            me.HTMLNode.style.width = 'auto';
            me.HTMLNode.style.zIndex = 1;
            var desiredWidth = me.HTMLNode.offsetWidth;
            // If this control needs less than it was styled for, then we don't need to bother with widening it.
//            if( desiredWidth < styledWidth )
//            {
//                me.dontWiden = true;
//                me.HTMLNode.style.width = me.originalWidth;
                //me.HTMLNode.click(); // Simulate another click, since setting styles has already caused the box to close at this point.
//            }
        };

        if( this.HTMLNode.attachEvent )
        {
            this.HTMLNode.attachEvent("onmousedown", widen);
            this.HTMLNode.attachEvent("onblur", shrink);
        }
        this.addChangeListener( shrink );
    }

    var selectDiv = document.createElement("div");
    selectDiv.style.display="inline";
//    selectDiv.style.width="90%";
    selectDiv.appendChild( this.HTMLNode );
    this.enclosingDivNode.appendChild( selectDiv );


    //generate filter UI
    //todo add IE support
    if( this.format.useFilter )
    {
        this.HTMLNode.style.cssFloat = "left";
        this.HTMLNode.style.styleFloat = "left"; // forIE
        this.HTMLNode.style.width="90%";

        var image = document.createElement( "input" );
        image.type = "image";
        image.src = "images/filter.png";
        image.value = "...";
        image.style.float = "right";
        image.style.paddingTop = "3px";
        image.style.width = '16px';

        var iconDiv = document.createElement( "div" );
        iconDiv.id = "iconDiv" + this.id;
        iconDiv.style.float = "right";
        iconDiv.style.cssFloat = "right";
        iconDiv.style.styleFloat = "right"; // forIE
        iconDiv.style.paddingTop = "3px";
        iconDiv.style.paddingLeft = "6px";
        iconDiv.style.visibility = ( this.format.readOnly ? "hidden" : "" );
        iconDiv.style.width = '16px';
        iconDiv.style.position = 'absolute';
        iconDiv.style.display = "inline";

        iconDiv.appendChild( image );
        var filterPopupDiv = this.generatePopupDiv( this.id + this.FILTER_DIV, image );
        this.attachFilterDiv( image, filterPopupDiv );


        this.enclosingDivNode.appendChild( selectDiv );
        this.enclosingDivNode.appendChild( iconDiv );
    }

    this.addChangeListener( function()
                            {
                                if( me.HTMLNode )
                                {
                                    if( me.HTMLNode.selectedIndex < 0 )
                                    {
                                        me.HTMLNode.title = null;
                                    }
                                    else
                                    {
                                        var option = me.HTMLNode.options[ me.HTMLNode.selectedIndex ];
                                        if( option )
                                        {
                                            me.HTMLNode.title = option.innerHTML;
                                        }
                                        else
                                        {
                                            me.HTMLNode.title = null;
                                        }
                                    }
                                }
                            });

    if( this.format.useFilter )
    {
        return this.enclosingDivNode;
    }
    else
    {
        return this.HTMLNode;
    }
};

JSComboBox.prototype.generatePopupDiv = function( id, initiator )
{
    var div = document.createElement("div");
    div.id = id;
    div.style.zIndex = 1;
    div.style.position = "absolute";
    div.style.backgroundColor = "white";
    div.style.padding = "1px";
    div.style.color = "black";
    div.style.borderColor = "black";
    div.style.borderWidth = "1px";
    div.style.borderStyle = "solid";
    div.style.display = "none";
    div.hideTimeoutID = -1;
    div.onmouseout = function( e )
    {
        if(!e)
        {
            e = window.event;
        }

        // check that we not above childs of filterDiv
        var parent = e.relatedTarget;
        while( parent != null )
        {
            if( parent.id == e.currentTarget.id )
            {
                return;
            }
            parent = parent.parentNode;
        }
//        var popupDiv = document.getElementById(e.currentTarget.id);
        var popupDiv = this;
        if( popupDiv != null )
        {
            popupDiv.hideTimeoutID = setTimeout(function()
            {
                if( popupDiv.hideTimeoutID >= 0 )
                {
                    popupDiv.style.display = "none";
                }
            }, 1000);
        }
    };
    div.onmouseover = function( e )
    {
        if(!e)
        {
            e = window.event;
        }

//        var popupDiv = document.getElementById(e.target.id);
        var popupDiv = this;
        if( popupDiv != null )
        {
            clearTimeout(popupDiv.hideTimeoutID);
            popupDiv.hideTimeoutID = -1;
        }
    };

    var someInput = document.createElement("input");
    var cBoxControl = this;
    someInput.onkeyup=function(){cBoxControl.narrowOptions(this.value);};
    div.appendChild(someInput);
    div.inputElement=someInput;

    var parent = document.getElementById("root");
    parent.appendChild(div);
    return div;
};

JSComboBox.prototype.attachFilterDiv = function( initiator, div )
{
    initiator.popupDivId = div.id;
    initiator.onclick = function( e )
    {
        if(!e)
        {
            e = window.event;
        }
        var popupDiv = document.getElementById(this.popupDivId);
        if( popupDiv != null )
        {
            popupDiv.style.left = e.clientX + 3 + document.body.scrollLeft + "px";
            popupDiv.style.top = e.clientY + 3 + document.body.scrollTop + "px";
            popupDiv.style.display = ( popupDiv.style.display == "none" ? "inline" : "none" );
            if( popupDiv.style.display!="none" )
            {
                popupDiv.inputElement.focus();
            }
        }
    };
    initiator.onmouseout = function( e )
    {
        if(!e)
        {
            e = window.event;
        }

        // check that we not above childs of filterDiv
        var parent = e.relatedTarget;
        while( parent != null )
        {
//            if( parent.id == e.currentTarget.popupDivId )
            if( parent.id == this.popupDivId )
            {
                return;
            }
            parent = parent.parentNode;
        }
//        var popupDiv = document.getElementById(e.currentTarget.popupDivId);
        var popupDiv = document.getElementById(this.popupDivId);
        if( popupDiv != null )
        {
            popupDiv.hideTimeoutID = setTimeout(function()
            {
                if( popupDiv.hideTimeoutID >= 0 )
                {
                    popupDiv.style.display = "none";
                }
            }, 1000);
        }
    };
};

JSComboBox.prototype.updateView = function ()
{
    if( !this.loading )
    {
        JSComboBox.superClass.updateView.call( this );
    }
    else
    {
        var value = this.getModel() != null ? this.getModel().getValue() : null;
        if( value != null )
        {
            this.selectedValue = value;
        }
    }
};

// override
JSComboBox.prototype.getOldValue = function()
{
    return this.dynamicOldValue ? this.dynamicOldValue : JSComboBox.superClass.getOldValue.call( this );
};

JSComboBox.prototype.setValue = function ( val )
{
    if( isEmpty( val ) && this.propInfo.getCanBeNull() == "no" &&
        this.getHTMLNode() != null && this.getHTMLNode().options.length > 0 && this.propInfo.getDefaultValue() )
    {
        val = this.propInfo.getDefaultValue();
    }
    JSComboBox.superClass.setValue.call( this, val );
};

JSComboBox.prototype.clear = function()
{
    if( this.getHTMLNode() != null )
    {
        this.getHTMLNode().options.length = 0;
    }
};

// @TODO (champ): remove this method
JSComboBox.prototype.setup = function( tokens, selectedValue, addEmpty, query )
{
    this.clear();
    this.tokens = {};
    for(var i = 0; tokens && i < tokens.length; i++)
    {
        this.tokens[tokens[i][0]] = tokens[i][1];
    }
    this.fill(tokens, addEmpty);
    if( this.format.sortedByHTML )
    {
        this.sortByHTML();
    }
    if( selectedValue != null )
    {
        this.setValue( selectedValue );
    }
    this.repaint();
    this.updateDisabledStatus();
};

JSComboBox.prototype.updateDisabledStatus = function ()
{
    var readOnly = (this.format != null) && (this.format.readOnly == true);
    this.setDisabledHTMLNode( readOnly || this.disabled || this.disabledByParent || this.loading );

    if( this.format )
    {
        var id = (this.HTMLNode == null) ? null : this.HTMLNode.id;
        if( this.format.chosen && jQuery( "#" + id + "_chosen" ).length > 0 )
        {
            jQuery( "#" + id ).trigger("chosen:updated");
        }
    }
};


// shows first part of array for debug purposes
JSComboBox.prototype.arrayStartToString = function( tokens )
{
    if( tokens == null )
    {
        return null;
    }

    var MAX_TOKENS_TO_SHOW = 4;
    var len = tokens.length;

    if( len < MAX_TOKENS_TO_SHOW )
        return tokens.toString();

    return tokens.slice(0, MAX_TOKENS_TO_SHOW).toString() + "...";
};

// @TODO (champ): remove 'addEmpty' parameter
JSComboBox.prototype.fill = function( tokens, addEmpty )
{
    //log("AJAX", this.id + ".fill(" + this.arrayStartToString(tokens) + "," + addEmpty + ")");
    if( this.getHTMLNode() != null )
    {
        if( addEmpty || this.format.emptyOption )
        {
            var option = document.createElement("option");
            option.value = this.format.emptyValue ? this.format.emptyValue : EMPTY;
            option.innerHTML = "";
            this.HTMLNode.appendChild(option);
        }
        for( var idx = 0 ; tokens && idx < tokens.length ; ++idx )
        {
            option = document.createElement("option");
            option.value = tokens[idx][ 0 ];
            option.innerHTML = ( this.format.showDictionaryCode ? option.value + " - " : "" ) + tokens[idx][ 1 ];
            this.HTMLNode.appendChild(option);
        }
        this.HTMLNode.selectedIndex = 0;
    }
};


// @TODO (champ): remove 'addEmpty' parameter
/*
 * cachePolicy = Cache.IGNORE: do not use cache
 * cachePolicy = Cache.RENEW or undefined or false: check cache and update it in background
 * cachePolicy = Cache.WRITE or true: do not read cache, but write back new value
 * cachePolicy = Cache.DEFAULT: don't update if found, just return cached value
 * cachePolicy = Cache.SESSION_RENEW: use session cache; update in background
 * cachePolicy = Cache.SESSION_WRITE: do not read cache, but write new value to the session cache
 * cachePolicy = Cache.SESSION: use session cache; don't update if found
 * true/false/undefined values are kept for backward compatibility
 */
JSComboBox.prototype.load = function( entity, query, selector, selectedValue, addEmpty, additionalUrlParams, cachePolicy )
{
    var doLoad = function( setList )
    {
        var loadStartTime = getCurTimeMillis();
        this.loadStartTime = loadStartTime;
        var key = entity + query + ( selector != null ? selector : additionalUrlParams );

        this.dynamicOldValue = this.getOldValue();
        if( !setList )
        {
            this.HTMLNode.disabled = true;
            this.clear();
            // add "loading" message
            var option = document.createElement("option");
            option.value = EMPTY;
            option.text = getMessage("Loading...");
            this.HTMLNode.appendChild(option);
            this.selectedValue = selectedValue;
            var parent = this.getParent();
            if( parent != null )
            {
                parent.incApplyLockCounter();
            }
        }
        // start loading
        this.loading = true;
        var params = [];
        if( additionalUrlParams != null )
        {
            params = additionalUrlParams;
        }
        if( selector != null )
        {
            params[ params.length ]  = [ "selector", selector ];
        }
        var me = this;
        //console.debug( "JSComboBox.load: entity=" + entity + ", query = " + query );
        calcUsingQuery(entity, query,
           {
               urlPrefix: location.toString().indexOf("file:") >= 0 ? context + "/" : null,
               search: true,
               timeout: 60000,
               limit: 5000,
               doNotShowLoading: true,
               params: params,
               listener:
                   function( list )
                   {
                       me.loading = false;
                       // update cache
                       Cache.set( key, list, cachePolicy );
                       // check that no overlapings with load() call
                       if( loadStartTime == me.loadStartTime  )
                       {
                           if( !setList )
                           {
                               me.setup( list, me.selectedValue, addEmpty, query );
                           }
                           else // checking cached data
                           {
                               if( JSON.stringify( setList ) !== JSON.stringify( list ) )
                               {
                                   me.setup( list, me.selectedValue, addEmpty, query);
                               }
                           }
                       }
                       if( !setList && parent != null )
                       {
                           parent.decApplyLockCounter();
                       }
                       me.dynamicOldValue = null;
                       me.repaint();
                       me.updateDisabledStatus();
                   },
               timeoutListener:
                   function()
                   {
                       if( !setList && parent != null )
                       {
                           parent.decApplyLockCounter();
                       }
                       me.loading = false;
                       me.dynamicOldValue = null;
                       me.repaint();
                       me.updateDisabledStatus();
                   },
               errorListener:
                   function()
                   {
                       if( !setList && parent != null )
                       {
                           parent.decApplyLockCounter();
                       }
                       me.loading = false;
                       me.dynamicOldValue = null;
                       me.repaint();
                       me.updateDisabledStatus();
                   }
           } );
    };

    
    if(cachePolicy === false || cachePolicy === undefined)
        cachePolicy = Cache.RENEW;
    if(cachePolicy === true)
        cachePolicy = Cache.WRITE;
    if( this.HTMLNode != null /*&& !this.loading*/ )
    {
        var key = entity + query + ( selector != null ? selector : additionalUrlParams );
        var list = Cache.get(key, cachePolicy);
        if( list === undefined )
        {
            doLoad.call( this );
        }
        else
        {
            this.setup( list, selectedValue, addEmpty, query);
            if(cachePolicy === Cache.SESSION_RENEW || cachePolicy === Cache.RENEW)
            {
                // do background load to check if cached data actually changed
                doLoad.call( this, list );
            }
        }
    }
};

/*
 * this function sorts items by innerHTML
 */
JSComboBox.prototype.sortByHTML = function()
{
    var list = this.getHTMLNode().options;
    var array = [];
    for( var i = 0; i < list.length; i++ )
    {
        array[ i ] = [ list[ i ].value, list[ i ].text ];
    }
    var sortOptions = function( a, b )
    {
        return a[ 1 ].localeCompare(b[ 1 ]);
    };
    array.sort(sortOptions);
    this.clear();
    this.fill(array);
};


/**
 * ��� ����� � ��������� control ����� options � ������� �������� ����� �������������
 * (���� ��� �������� ������ � ������� �����������)
 */
JSComboBox.prototype.narrowByTypingIn = function(control)
{
    var cBoxControl = this;
    control.addChangeListener( function(control, oldvalue, newvalue){
        cBoxControl.narrowOptions(newvalue);
    });
};

JSComboBox.prototype.narrowOptions = function(search)
{
    var list = this.tokens;
    var filtered = [];
    var i = 0;
    var regex = new RegExp(search,'gi');
    for( var value in this.tokens )
    {
        var displayName = this.tokens[ value ];
        if(displayName.match(regex) !== null)
        {
            filtered[ i ] = [ value, displayName];
        }
        i++;
    }
    this.clear();
    this.fill(filtered);
    this.setValue(filtered[0]);

};

JSComboBox.prototype.isActive = function()
{
    var id = (this.HTMLNode == null) ? null : this.HTMLNode.id;
    return ( this.hasFocus() && !this.disabled && jQuery('#' + id).is(":visible") );
};

JSComboBox.prototype.onKeyDownPress = function()
{
    return this.isActive();
};


JSComboBox.prototype.onKeyUpPress = function()
{
    return this.isActive();
};
/**
 * $Id: JSGenericPopupControl.js,v 1.18 2013/09/11 08:49:22 dobrynin Exp $
 *
 * GenericPopupControl (used in BioUML)
 * Common methods to represent control with popup
 * Abstract (Should not be instantiated directly)
 */

$(function() {$(document).bind("mousedown", function(e) {
    if(!$(e.target).closest(".genericComboData").length)
        $(".genericComboData").trigger("remove").remove();
})});

function JSGenericPopupControl( propInfo, format, tokens )
{
    if(propInfo == undefined)
        JSInput.call(this);
    else
        JSInput.call(this, propInfo, format );
    this.tokens = tokens;
    this.loading = false;
    this.width = 250;
    this.maxHeight = 300;    // if popup height exceeds this, vertical scrollbar appears
    this.selectedValue = "";
}

JSGenericPopupControl.prototype = new JSInput();
JSGenericPopupControl.superClass = JSInput.prototype;

JSGenericPopupControl.prototype.setLoading = function ( loading )
{
    this.loading = loading;
    this.updateDisabledStatus();
};

JSGenericPopupControl.prototype.updateTokens = function()
{
    if( ( !this.tokens || this.tokens == null ) && this.propInfo.getAttribute("dictionaryName") != null )
    {
        var dictionaryName = this.propInfo.getAttribute("dictionaryName");
        var dictionary = dictionaries.getDictionary(dictionaryName);
        if( dictionary != null )
        {
            if(!dictionary._tokens)
            {
                var pairs = dictionary.getPairs();
                var tokens = [];
                for(i in pairs) tokens.push([i, pairs[i]]);
                if(this.format.sortedByHTML)
                    tokens.sort(function(a,b) {return a[0].localeCompare(b[0])});
                dictionary._tokens = tokens;
            }
            this.tokens = dictionary._tokens;
        }
        else
        {
            var parent = this.getParent();
            if( parent != null && parent.incApplyLockCounter )
            {
                parent.incApplyLockCounter();
            }
            this.tokens = { EMPTY: getMessage("Loading...") };
            this.setLoading( true );
            var self = this;
            dictionaries.loadDictionary( dictionaryName, function( dictionary )
            {
                var addEmpty = self.format.emptyOption || self.propInfo.getCanBeNull() != "no";
                var tokens = [];
                if( dictionary != null )
                {
                    for( var key in dictionary.getPairs() )
                    {
                        var value = dictionary.get( key );
                        tokens[ tokens.length ] = [ key, value ];
                    }
                }
                self.setLoading( false );
                self.setup( tokens, self.getModelValue(), addEmpty);
                if( parent != null )
                {
                    parent.decApplyLockCounter();
                }
            } );
        }
    }
};

// override
JSGenericPopupControl.prototype.generate = function()
{
    this.updateTokens();
    var parent = this.getParentNode();
    var _this = this;
    this.container = $("<div/>").addClass("genericComboContainer").width(this.width);
    this.text = this.createInput();
    this.img = $("<div/>").addClass("genericComboButton");
    this.container.append(this.img).append(this.text);
    this.text.addClass("form-value-control-el-js");
    this.HTMLNode = this.text.get(0);
    this.HTMLNode.id = this.createNodeId(this.propInfo.getName());
    if( this.getLayoutParams() != null )
    {
        this.HTMLNode.className += " " + this.getLayoutParams();
    }
    $(parent).append(this.container);
    //$(parent).height(this.container.outerHeight());
    this.data = $("<div/>").addClass("genericComboData").addClass("ui-widget").css("position", "absolute").css("overflow", "auto");
    //this.container.append(this.data);
    this.container.click(function(e)
    {
        _this.toggleDropDown(e)
    });

    this.fill(this.tokens, this.propInfo.getCanBeNull() != "no");
    if( this.format.readOnly )
    {
        this.text.disabled = true;
        this.text.unbind("click");
        this.img.unbind("click");
    }

    if( this.format.sortedByHTML )
    {
        this.sortByHTML();
    }

    var me = this;

    this.HTMLNode.onmousedown = function()
    {
        me.onMouseDown();
    };

    this.HTMLNode.onfocus = function()
    {
        me.getFocusManager().setActive(me);
    };

    return this.HTMLNode;
};

JSGenericPopupControl.prototype.createInput = function()
{
    var _this = this;
    var input = $("<input type='text' readonly autocomplete='off'/>").addClass("genericComboText").val(this.selectedValue).width(this.width - 20);
    return input;
};

JSGenericPopupControl.prototype.JSInput_updateView = JSInput.prototype.updateView;

JSGenericPopupControl.prototype.updateView = function ()
{
    logByClass("VALUES", this.id + ".updateView()");

    if( !this.loading )
    {
        this.JSInput_updateView();
        return;
    }

    var value = this.getModel() != null ? this.getModel().getValue() : null;
    if( value != null )
    {
        this.selectedValue = value;
    }
    logByClass("VALUES", this.id + ".selectedValue = " + this.selectedValue);
};

JSGenericPopupControl.prototype.clear = function()
{
    if(this.data)
        this.data.children().remove();
};

// @TODO (champ): remove this method
JSGenericPopupControl.prototype.setup = function( tokens, selectedValue, addEmpty, query )
{
    this.clear();
    this.fill(tokens, addEmpty);
    if( this.format.sortedByHTML )
    {
        this.sortByHTML();
    }

    this.setValue( selectedValue );
    this.updateDisabledStatus();
};

// shows first part of array for debug purposes
JSGenericPopupControl.prototype.arrayStartToString = function( tokens )
{
    if( tokens == null )
    {
        return null;
    }

    var MAX_TOKENS_TO_SHOW = 4;
    var len = tokens.length;

    if( len < MAX_TOKENS_TO_SHOW )
        return tokens.toString();

    return tokens.slice(0, MAX_TOKENS_TO_SHOW).toString() + "...";
};

// @TODO (champ): remove 'addEmpty' parameter
JSGenericPopupControl.prototype.fill = function( tokens, addEmpty )
{
    if(addEmpty)
        tokens.unshift([this.format.emptyValue||EMPTY, ""]);
    var _this = this;
    for(var i in tokens)
    {
        var option = $("<div/>").addClass(tokens[i][0] == this.value?"genericComboItemSelected":"genericComboItem").text(tokens[i][1]).prop("value", tokens[i][0]);
        this.data.append(option);
    }
};

JSGenericPopupControl.prototype.isActive = function()
{
    var id = (this.HTMLNode == null) ? null : this.HTMLNode.id;
    return ( this.hasFocus() && !this.disabled && jQuery('#' + id).is(":visible") );
};

JSGenericPopupControl.prototype.onKeyDownPress = function()
{
    return this.isActive();
};

JSGenericPopupControl.prototype.onKeyUpPress = function()
{
    return this.isActive();
};

JSGenericPopupControl.prototype.getValue = function()
{
    return this.value;
};

JSGenericPopupControl.prototype.setValue = function(value)
{
    this.value = value;
};

JSGenericPopupControl.prototype.setControlHandlers = function()
{
};

JSGenericPopupControl.prototype.toggleDropDown = function(e)
{
    if(this.data.filter(":visible").length) this.data.remove();
    else
    {
        $(".genericComboData").remove();
        $(".genericComboContainer").css("z-index", 1000);
        this.container.css("z-index", 2000);

        this.data.css("top", this.container.offset().top+this.container.outerHeight())
            .css("left", this.container.offset().left)
            .width(this.container.outerWidth() - 2).css("z-index", 2000);
        var h = $(document).height();
        $('body').append(this.data);
        // vertical scrolling
        if(this.data.height() > this.maxHeight)
            this.data.height(this.maxHeight);
        if($(document).height() != h)
        {
            this.data.css("top", this.container.offset().top-this.data.outerHeight());
        }
        this.setControlHandlers();
    }
    e.stopPropagation();
};
/**
 * $Id: JSGenericComboBox.js,v 1.4 2011/05/31 08:15:39 champ Exp $
 *
 * GenericComboBox control (used in BioUML)
 */

function JSGenericComboBox( propInfo, format, tokens )
{
    JSGenericPopupControl.call( this, propInfo, format, tokens );
}

JSGenericComboBox.prototype = new JSGenericPopupControl();
JSGenericComboBox.superClass = JSGenericPopupControl.prototype;

JSGenericComboBox.prototype.JSInput_updateView = JSInput.prototype.updateView;

// @TODO (champ): remove 'addEmpty' parameter
JSGenericComboBox.prototype.fill = function( tokens, addEmpty )
{
    if(addEmpty)
        tokens.unshift([this.format.emptyValue||EMPTY, ""]);
    var _this = this;
    for(var i in tokens)
    {
        var selected = tokens[i][0] == this.value;
        var option = $("<div/>").addClass(selected?"genericComboItemSelected":"genericComboItem").text(tokens[i][1]).prop("value", tokens[i][0]);
        this.data.append(option);
    }
}

JSGenericComboBox.prototype.validate = function ()
{
    return null;
}

/*
 * this function sorts items by innerHTML
 */
JSGenericComboBox.prototype.sortByHTML = function()
{
    var list = this.data.children();
    var array = [];
    for( var i = 0; i < list.length; i++ )
    {
        array[ i ] = [ list.eq(i).prop("value"), list.eq(i).text() ];
    }
    var sortOptions = function( a, b )
    {
        return a[ 1 ].localeCompare(b[ 1 ]);
    };
    array.sort(sortOptions);
    this.clear();
    this.fill(array);
}

JSGenericComboBox.prototype.setValue = function(value)
{
    this.value = value;
    var _this = this;
    _this.data.children().each(function() {
        if ($(this).prop("value") == value)
        {
            $(this).prop("class", "genericComboItemSelected");
            _this.text.val($(this).text());
        }
        else
            $(this).prop("class", "genericComboItem");
    });
}

JSGenericComboBox.prototype.setControlHandlers = function()
{
    var _this = this;
    this.data.children().hover(function() {
        _this.data.children(".genericComboItemSelected").prop("class", "genericComboItem");
        $(this).prop("class", "genericComboItemSelected");
    }).click(function() {
        _this.data.remove();
        var oldvalue = _this.value;
        _this.value = $(this).prop("value");
        _this.text.val($(this).text());
        if(_this.value != oldvalue)
            _this.fireChangeListeners(oldvalue, _this.value, _this);
    });
}
/**
 * $Id: JSGenericMultiSelect.js,v 1.7 2011/11/28 08:10:38 lan Exp $
 *
 * GenericMultiSelect control (used in BioUML)
 */

function JSGenericMultiSelect( propInfo, format, tokens )
{
    JSGenericPopupControl.call( this, propInfo, format, tokens );
    this.changed = false;
    this.selectedValue = [];
    this.value = [];
}

JSGenericMultiSelect.prototype = new JSGenericPopupControl();
JSGenericMultiSelect.superClass = JSGenericPopupControl.prototype;

JSGenericMultiSelect.prototype.JSInput_updateView = JSInput.prototype.updateView;

// @TODO (champ): remove 'addEmpty' parameter
JSGenericMultiSelect.prototype.fill = function( tokens, addEmpty )
{
    if(addEmpty)
        tokens.unshift([this.format.emptyValue||EMPTY, ""]);
    for(var i in tokens)
    {
        var option = $("<div/>").addClass($.grep(this.value, function(el) {return el == tokens[i][0]}).length > 0?
            "genericComboItemSelected":"genericComboItem").text(tokens[i][1]).prop("value", tokens[i][0]);
        this.data.append(option);
    }
}

/*
 * this function sorts items by innerHTML
 */
JSGenericMultiSelect.prototype.sortByHTML = function()
{
    var list = this.data.children();
    var array = [];
    for( var i = 0; i < list.length; i++ )
    {
        array[ i ] = [ list.eq(i).prop("value"), list.eq(i).text() ];
    }
    var sortOptions = function( a, b )
    {
        return a[ 1 ].localeCompare(b[ 1 ]);
    };
    array.sort(sortOptions);
    this.clear();
    this.fill(array);
}

JSGenericMultiSelect.prototype.setValue = function(value)
{
    if(value == "") value = [];
    if(!(Array.isArray(value))) value = [value];
    this.value = value;
    var _this = this;
    var text = "";
    _this.data.children().each(function() {
        var val = $(this).prop("value");
        if ($.grep(value, function(el) {return el == val}).length > 0)
        {
            $(this).prop("class", "genericComboItemSelected");
            if (text.length < 100)
            {
                if (text != "") text += ", ";
                text += $(this).text();
            }
        }
        else
            $(this).prop("class", "genericComboItem");
    });
    if(_this.value.length == 0) text = "(no selection)";
    else if(_this.value.length > 1) text = "["+_this.value.length+"] "+text;
    _this.text.val(text);
}

function arraysEqual(arr1, arr2)
{
    if(arr1.length != arr2.length) return false;
    for(var i=0; i<arr1.length; i++)
        if(arr1[i] != arr2[i]) return false;
    return true;
}

JSGenericMultiSelect.prototype.setControlHandlers = function()
{
    var _this = this;
    _this.lastSelected = 0;
    var oldvalue = _this.value;
    _this.data.bind("remove", function() {
        if(!arraysEqual(oldvalue,_this.value))
            _this.fireChangeListeners(oldvalue, _this.value, _this);
        _this.data.unbind("remove");
    });
    var children = _this.data.children();
    _this.data.mousedown(function (e) {e.preventDefault();});
    children.click(function(e) {
        var $this = $(this);
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey)
        {
            if ($this.hasClass("genericComboItemSelected"))
                $this.prop("class", "genericComboItem");
            else
                $this.prop("class", "genericComboItemSelected");
            _this.lastSelected = children.index($this);
        }
        if (!e.ctrlKey && !e.metaKey && !e.shiftKey)
        {
            if($this.hasClass("genericComboItemSelected") && children.filter(".genericComboItemSelected").length == 1)
            {
                children.prop("class", "genericComboItem");
            } else
            {
                children.prop("class", "genericComboItem");
                $this.prop("class", "genericComboItemSelected");
            }
            _this.lastSelected = children.index($this);
        }
        if (!e.ctrlKey && !e.metaKey && e.shiftKey)
        {
            var curSelected = children.index($this);
            children.prop("class", "genericComboItem");
            children.slice(Math.min(curSelected, _this.lastSelected), Math.max(curSelected, _this.lastSelected)+1).prop("class", "genericComboItemSelected");
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey)
        {
            var curSelected = children.index($this);
            children.slice(Math.min(curSelected, _this.lastSelected), Math.max(curSelected, _this.lastSelected)+1).prop("class",
                children.eq(_this.lastSelected).hasClass("genericComboItemSelected")?"genericComboItemSelected":"genericComboItem");
        }
        var oldvalue = _this.value;
        _this.value = [];
        var text = "";
        _this.data.children(".genericComboItemSelected").each(function() {
            _this.value.push($(this).prop("value"));
            if (text.length < 100)
            {
                if (text != "") text += ", ";
                text += $(this).text();
            }
        });
        if(_this.value.length == 0) text = "(no selection)";
        else if(_this.value.length > 1) text = "["+_this.value.length+"] "+text;
        _this.text.val(text);
        _this.changed = true;
        //_this.fireChangeListeners(oldvalue, _this.value, _this);
    });
}

JSGenericMultiSelect.prototype.hasChanges = function ()
{
    return this.changed;
}
/**
 * $Id: JSPropertyInspector.js,v 1.21 2011/09/16 07:49:24 lan Exp $
 *
 * JSPropertyInspector.
 */
$(function() {$(document).bind("mousedown", function(e) {
    if(!$(e.target).closest(".dpiTooltip").length && !$(e.target).closest(".dpiTooltipButton").length)
        $(".dpiTooltip").trigger("remove").remove();
})});

function JSPropertyInspector()
{
    JSPane.call( this );
}

JSPropertyInspector.prototype = new JSPane(); // derivation

// builds DOM structure from JS object's structure
JSPropertyInspector.prototype.generate = function()
{
    timingLogBegin(this.id + ".generate");

    this.generateBody();
    this.updateView();

    timingLogEnd(this.id + ".generate");
};

JSPropertyInspector.prototype.generateBody = function()
{
    var parent = this.getParentNode();
    var mainDivElem = document.createElement("div");
    mainDivElem.className = "form-js";
    parent.appendChild(mainDivElem);

    this.mainTable = $('<table class="pi_table" cellspacing=0></table>');
    this.treeJoints = [];
    this.processProperties(this.model, 1, this.id, false);
    $(mainDivElem).append(this.mainTable);
};

JSPropertyInspector.prototype.processProperties = function(dps, level, parentId, isHidden)
{
    function getToolTip(contentElement)
    {
        var content = $("<div/>").css({minWidth: "300px", position: "absolute", padding: "2px", top: "15px", background: "rgb(250,250,160)", border: "1px solid rgb(0,0,0)"}).append($(contentElement));
        var container = $("<div/>").css({position: "absolute"}).addClass("dpiTooltip");
        if(browserApp.msie)
        {
            container.append(content.css({top: "2px"}));
        }
        else
        {
            var trg1 = $("<div/>").width(0).height(0).css({position: "absolute", left: "10px", top: "1px", borderWidth: "0px 15px 15px 15px", borderColor: "rgb(250,250,160) rgba(0,0,0,0)", borderStyle: "solid"});
            var trg2 = $("<div/>").width(0).height(0).css({position: "absolute", left: "8px", borderWidth: "0px 17px 17px 17px", borderColor: "rgb(0,0,0) rgba(0,0,0,0)", borderStyle: "solid"});
            container.append(trg2).append(content).append(trg1);
        }
        return container;
    }

    var properties = dps.getAllProperties();
    var propNum = 0;
    var propArray = [];
    for(var propName in properties)
    {
        propArray.push(properties[propName]);
    }
    for (propNum = 0; propNum < propArray.length; propNum++)
    {
        var property = propArray[propNum];
        var propType = property.getType();
        if(property.getAttribute("implicit"))
            continue;
        if(propNum == propArray.length -1 )
            this.treeJoints[level-1] = "_last";
        else
            this.treeJoints[level-1] = "";
        var control;
        var isFolder;
        var trId = parentId + "_" + propNum;
        if (propType == "composite" || propType == "collection")
        {
            control = $('<div>&nbsp;</div>');
            isFolder = true;
        }
        else if(propType=="color-selector")
        {
            var divId = trId + "_control";
            control = $('<div id="' + divId + '"></div>');
            var listDPS = property.getValue();
            if(listDPS.length > 1)
                isFolder = true;
            else
                isFolder = false;
        }
        else
        {
            var divId = trId + "_control";//we need global unique divID because generate() method uses document.getElementByID
            control = $('<div id="' + divId + '"></div>');
            isFolder = false;
        }
        var displayName = property.getDisplayName();
        if (!displayName)
        {
            displayName = property.getName();
        }
        var tr = this.createTr(level, displayName, isFolder, control, trId, property.getShortDescription());
        if (isHidden)
        {
            tr.css('display', 'none');
        }
        var descriptionHTML = property.getDescriptor().getValue("descriptionHTML");
        if(descriptionHTML)
        {
            (function(leftTd, descriptionHTML)
            {
                leftTd.children("div").prepend($("<div/>").css({float: "right", margin: "2px", cursor: "pointer"}).width(20).html("[?]").addClass("dpiTooltipButton").click(function()
                {
                    $(".dpiTooltip").remove();
                    $(document.body).append(getToolTip(descriptionHTML).css({zIndex: 2000, top: leftTd.height()+leftTd.offset().top+"px", left: leftTd.offset().left+"px"}));
                }));
            })(tr.children("td").first(), descriptionHTML);
        }
        if (!isFolder)
        {
            //generate control for property
            var format = null;
            if (property.getDescriptor().isReadOnly() && property.getDescriptor().isReadOnly() == true)
            {
                format =
                {
                    readOnly: true
                };
            }
            var inputControl = ControlFactory.createControl(property, format);
            inputControl.setParent(control.get(0));
            inputControl.setModel(property);
            inputControl.generate();
            this.add(inputControl);
        }
        if (propType == "composite")
        {
            this.processProperties(property.getValue(), level + 1, trId, false);
        }
        else
            if (propType == "collection")
            {
                var arrayControl = ControlFactory.createControl(property, format);
                if(!(arrayControl instanceof JSEditBox))//add if not default editor
                {
                    arrayControl.setParent(control.get(0));
                    arrayControl.setModel(property);
                    arrayControl.generate();
                    this.add(arrayControl);
                }
                
                var listDPS = property.getValue();
                for (var i = 0; i < listDPS.length; i++)
                {
                    var trId_l = trId + "_" + i;
                    this.treeJoints[level] = i==listDPS.length-1?"_last":"";
                    var titleProperty = listDPS[i].getProperty("title");
                    var index = i+1;
                    var rowTitle = '['+index+']';
                    if(titleProperty != null)
                    {
                        if(titleProperty.getValue())
                            rowTitle += ' ' + titleProperty.getValue();
                        if(titleProperty.isReadOnly())
                            listDPS[i].remove("title");
                    }
                    this.createTr(level+1, rowTitle, true, $('<div>&nbsp;</div>'), trId_l);
                    if (listDPS[i].getAllProperties().length > 1)
                    {
                        //var tr_L = this.createTr(level + 1, '['+i+']', true, $('<div>&nbsp;</div>'), trId_l);
                        //tr_L.css('display', 'none');
                        this.processProperties(listDPS[i], level + 2, trId_l, false);
                    }
                    else
                        this.processProperties(listDPS[i], level + 2, trId_l, false);
                }
            }
            else
            {
                if(propType == "color-selector" && isFolder)
                {
                    //generate control for property
                    var format = null;
                    if (property.getDescriptor().isReadOnly() && property.getDescriptor().isReadOnly() == true)
                    {
                        format =
                        {
                            readOnly: true
                        };
                    }
                    var inputControl = ControlFactory.createControl(property, format);
                    inputControl.setParent(control.get(0));
                    inputControl.setModel(property);
                    inputControl.generate();
                    this.add(inputControl);

                    var listDPS = property.getValue();
                    for (var i = 1; i < listDPS.length; i++)
                    {
                        var trId_l = trId + "_" + i;
                        this.treeJoints[level] = i==listDPS.length-1?"_last":"";
                        this.processProperties(listDPS[i], level + 1, trId_l, false);
                    }
                }
            }
    }
};

JSPropertyInspector.prototype.createTr = function(level, name, isFolder, control, trId, shortDescription)
{
    var tr = $('<tr id="' + trId + '"></tr>');
    var div_left = $('<div/>').addClass('pi-prompt').css("overflow", "hidden").css("white-space", "nowrap");
    var td_left = $('<td></td>').css("position", "relative").append(div_left);
    if(shortDescription != undefined)
        tr.prop("title", shortDescription);
    var leftLines = this.getTreeLines(level, isFolder, trId);
    for (var leftLine in leftLines)
    {
        div_left.append(leftLines[leftLine]);
    }
    div_left.append(this.getNodeImage(isFolder)).append(document.createTextNode(name));
    var td_right = $('<td></td>').append(control);
    tr.append(td_left).append(td_right);
    this.mainTable.append(tr);
    return tr;
};

JSPropertyInspector.prototype.getNodeImage = function(isFolder)
{
    if (isFolder)
    {
        return $('<div class="folder_img"></div>');
    }
    else
    {
        return $('<div class="leaf_img"></div>');
    }
};

JSPropertyInspector.prototype.getTreeLines = function(level, isFolder, trId)
{
    var lines = [];
    if (level > 0)
    {
        for (var i = 0; i < level - 1; i++)
        {
            lines[i] = $('<div class="line line_vert'+this.treeJoints[i]+'"></div>');
        }
        if (isFolder)
        {
            var activeDiv = $('<div id="' + trId + '" class="line line_folderopen'+this.treeJoints[level - 1]+'"></div>');
            activeDiv.click(this.openFunction);
            lines[level - 1] = activeDiv;
        }
        else
        {
            lines[level - 1] = $('<div class="line line_node'+this.treeJoints[level - 1]+'"></div>');
        }
    }

    return lines;
};

JSPropertyInspector.prototype.openFunction = function()
{
    var id = $(this).prop('id');
    var table = $(this).closest('tr').parent();
    var targetTr = table.children('tr[id^=' + id + '_]');
    var isOpen = $(this).hasClass('line_folderopen') || $(this).hasClass('line_folderopen_last');
    var last = ($(this).hasClass('line_folderclose_last') || $(this).hasClass('line_folderopen_last'))?"_last":"";

    if (isOpen)
    {
        $(this).prop('class', 'line line_folderclose'+last);
    }
    else
    {
        $(this).prop('class', 'line line_folderopen'+last);
    }
    /*
     * Some collections might have no 1-st level children, open 2-nd level then
     */
    var directChildren = [];
    var indirectChildren = [];
    targetTr.each(function()
    {
        var cname = $(this).prop('id').substring(id.length + 1);
        if (isOpen)
        {
            $(this).css('display', 'none');
            //close all inner folders
            $(this).find('.line_folderopen').prop('class', 'line line_folderclose');
            $(this).find('.line_folderopen_last').prop('class', 'line line_folderclose_last');
        }
        else
        {
            if (cname.indexOf('_') == -1)
            {
                directChildren.push($(this));
            }
            else if ( cname.indexOf('_', cname.indexOf('_')+1) == -1)
            {
                indirectChildren.push($(this));
            }
        }
    });
    if(! isOpen)
    {
        var finalChildren;
        if(directChildren.length > 0)
        {
            finalChildren = directChildren;
        }
        else
        {
            finalChildren = indirectChildren;
        }
        $.each(finalChildren, function()
        {
            if (browserApp.msie)
            {
                $(this).css('display', 'block');
            }
            else
            {
                $(this).css('display', 'table-row');
            }
        });
    }
};

JSPropertyInspector.prototype.getModel = function()
{
    this.updateModel();
    return this.model;
};



/**
 * $Id: ControlFactory.js,v 1.33 2012/06/18 11:50:16 lan Exp $
 *
 * ControlFactory.
 */

function ControlFactory()
{
}

ControlFactory.createLabel = function( property, format )
{
    if( property != null )
    {
        var text = property.getDisplayName() + ":";
        format = format ? format : {};
        if( !format.bold )
        {
            format.bold = property.getCanBeNull() == "no" ? !format.readOnly : false;
        }
        var label = new JSLabel(text, format);
        label.bindPropertyInfo( property );
    }
    return label;
}

ControlFactory.createControl = function( property, format, changeListener )
{
    if( property == null )
    {
        error( "ControlFactory.createControl: property is null" );
        return null;
    }
    var control;
    if( format && format.categorized )
    {
        control = new JSEditBox(property, format);
    }
    else if( property.getAttribute("rawValue") )
    {
        control = new JSPlainHtml( property.getValue(), format );
    }
    else if( ( property.getType() == "code-string" || property.getType() == "string" ) && property.getAttribute("dictionaryName") != null )
    {
        control = new JSComboBox(property, format);
    }
    else if( property.getType() == "generic-combo" && property.getAttribute("dictionaryName") != null )
    {
        control = property.isReadOnly()?new JSEditBox(property, format):new JSGenericComboBox(property, format);
    }
    else if( property.getType() == "multi-select" && property.getAttribute("dictionaryName") != null )
    {
        control = property.isReadOnly()?new JSEditBox(property, format):new JSGenericMultiSelect(property, format);
    }
    else if( property.getType() == "color-selector" )
    {
        control = new JSColorSelector(property, format);
    }
    else if( property.getType() == "string" || property.getType() == "code-string" || property.getType() == "number" ||
             property.getType() == "currency" || property.getType() == "real" )
    {
        control = new JSEditBox(property, format);
    }
    else if( property.getType() == "date" || property.getType() == "date-time")
    {
        control = new JSDateBox(property, format);
    }
    else if( property.getType() == "bool" )
    {
        control = new JSCheckBox(property, format);
    }
    else
    {
        if( format == null )
        {
            format = {};
        }
        format.readOnly = true;
        control = new JSEditBox(property, format);
    }
    if( changeListener != null )
    {
        control.addChangeListener(changeListener);
    }
    return control;
}
/**
 * $Id: DPSUtils.js,v 1.5 2011/06/03 14:04:35 champ Exp $
 */

//returns DPS copy without DynamicPropery's attributes information(descriptor)
function copyDPS( originalDps )
{
    var dpsCopy = new DynamicPropertySet();
    for( var dpName in originalDps.getAllProperties() )
    {
        var dp = originalDps.getProperty(dpName);
        if( dp.constructor != DynamicProperty )
        {
            continue;
        }
        var value = dp.getValue();
        var dpCopy = null;

        if( value != null && value.constructor == Array ) //isCollection
        {
            var collectionCopy = [];
            //            alert(dpName + ": COLLECTION of " + value.length +  " elems");
            for( var i = 0; i < value.length; i++ )
            {
                var collectionElement = value[ i ];
                collectionCopy[ i ] = copyDPS(collectionElement);
            }
            dpCopy = new DynamicProperty(dp.getName(), dp.getType(), collectionCopy);
        }
        else
        {
            dpCopy = new DynamicProperty(dp.getName(), dp.getType(), dp.getValue());
        }
        dpCopy.assignFrom( dp );
        dpsCopy.add(dpCopy);
    }
    return dpsCopy;
}

//returns DPS copy without DynamicPropery's attributes information(descriptor)
function copyEmptyDPS( originalDps )
{
    var dpsCopy = new DynamicPropertySet();
    for( var dpName in originalDps.getAllProperties() )
    {
        var dp = originalDps.getProperty(dpName);
        if( dp.constructor != DynamicProperty )
        {
            continue;
        }
        var dpCopy = new DynamicProperty(dp.getName(), dp.getType(), "");
        dpsCopy.add(dpCopy);
    }
    return dpsCopy;
}

function differencesToDom( xmlDom, xmlRoot, parent, originalDPS, modifiedDPS )
{
    //comparing properties pair
    for( var dpName in modifiedDPS.getAllProperties() )
    {
        var dp1 = originalDPS.getProperty(dpName);
        var dp2 = modifiedDPS.getProperty(dpName);
        if( dp1 == null || dp2 == null )
        {
            if( dp2 != null )
            {
                putChangedElement(xmlDom, xmlRoot, dpName, dp2.getValue(), parent);
            }
            continue;
        }

        var dp1Val = dp1.getValue();
        var dp2Val = dp2.getValue();

        if( dp1Val.constructor == Array && dp2Val.constructor == Array )
        {
            var removeExpected = dp1Val.length > dp2Val.length; //only one collection element can be removed at one time
            var collectionSize = dp1Val.length > dp2Val.length ? dp1Val.length : dp2Val.length; //!
            for( var i = 0, j = 0; i < collectionSize; i++,j++ )
            {
                var collectionElement1 = dp1Val[ i ];
                var collectionElement2 = dp2Val[ j ];
                var collectionName1 = null;
                var collectionName2 = null;
                if( collectionElement1 != null && collectionElement1.getProperty("JS_NAME") != null )
                {
                    collectionName1 = parseInt(collectionElement1.getProperty("JS_NAME").getValue());
                }
                if( collectionElement2 != null && collectionElement2.getProperty("JS_NAME") != null )
                {
                    collectionName2 = parseInt(collectionElement2.getProperty("JS_NAME").getValue());
                }

                if( removeExpected )
                {
                    var removedElementName = (parent == "" ? "" : parent + "." ) + dpName + "." + collectionName1;
                    if( collectionElement2 == null || collectionName1 < collectionName2 )
                    {
                        //1.last element was removed or 2. element was removed
                        //log("xmlDiff", dpName + ": element was removed : " + removedElementName);
                        putRemovedElement(xmlDom, xmlRoot, dpName, removedElementName);
                        removeExpected = false;
                        j--;
                    }
                }
                else if( collectionElement1 == null || collectionElement2 == null )
                {
                    var newParent = (parent == "" ? "" : parent + "." ) + dpName + "." + ( parseInt(collectionSize) - 1 );
                    //element added
                    putAddedElement(xmlDom, xmlRoot, collectionElement2, newParent);
                }
                else if( collectionName1 == collectionName2 )
                    {
                        //continue with collection elements
                        var newParent = (parent == "" ? "" : parent + "." ) + dpName + "." + collectionName1;
                        differencesToDom(xmlDom, xmlRoot, newParent, collectionElement1, collectionElement2);
                    }
            }
        }
        else if( dp1Val != dp2Val )
        {
            //value changed
            //log("xmlDiff", dpName + ": " + " value changed : old[" + dp1Val + "] new[" + dp2Val + "] parent [" + parent + "]");
            putChangedElement(xmlDom, xmlRoot, dpName, dp2Val, parent);
        }
    }
    return true;
}

function putChangedElement( xmlDom, xmlRoot, name, value, parent )
{
    logByClass("xmlDiff", "add changed property: " + "[" + name + " = " + value + "]");
    var valueElement = xmlDom.createElement("value");
    valueElement.setAttribute("name", Utils.XMLize(name));
    valueElement.setAttribute("value", Utils.XMLize(value ? value : ""));
    valueElement.setAttribute("parent", Utils.XMLize(parent));
    valueElement.setAttribute("mod", "changed");
    xmlRoot.appendChild(valueElement);
}

function putRemovedElement( xmlDom, xmlRoot, name, parent )
{
    logByClass("xmlDiff", "element was removed : " + name);
    var valueElement = xmlDom.createElement("value");
    valueElement.setAttribute("name", Utils.XMLize(name));
    valueElement.setAttribute("value", "");
    valueElement.setAttribute("parent", Utils.XMLize(parent));
    valueElement.setAttribute("mod", "removed");
    xmlRoot.appendChild(valueElement);
}

function putAddedElement( xmlDom, xmlRoot, dps, parent )
{
    for( var name in dps.getAllProperties() )
    {
        var dynamicProperty = dps.getProperty(name);
        var value = dynamicProperty.getValue();
        if( value != null && value.constructor == Array )
        {
            for( var i = 0; i < value.length; i++ )
            {
                var collectionDPS = value[ i ];
                putAddedElement(xmlDom, xmlRoot, collectionDPS, ( parent != "" ? parent + "." : parent ) + dynamicProperty.getName() + "." + i);
            }
        }
        else if( dynamicProperty.getType() != undefined || dynamicProperty.getName() == "ID" )
        {
            logByClass("xmlDiff", " collection element added : " + name + " =  " + value + " parent = " + parent);
            var valueElement = xmlDom.createElement("value");
            valueElement.setAttribute("name", Utils.XMLize(name));
            valueElement.setAttribute("value", Utils.XMLize(value ? value : ""));
            valueElement.setAttribute("parent", Utils.XMLize(parent));
            valueElement.setAttribute("mod", "added");
            xmlRoot.appendChild(valueElement);
        }
    }
}

// Rewrite addModificationListener from ModificationListener.js 
addModificationListener = function( HTMLNode, func )
{
    if( HTMLNode.type === "checkbox" )
    { // check box
        prevValues [HTMLNode.id ] = HTMLNode.checked;
    }
    else if( HTMLNode.type === "select-one" )
    { //select control
        HTMLNode.onfocus = onFocus;
    }
    else
    { //other control
        HTMLNode.onfocus = onFocus;
        HTMLNode.onblur = onBlur;
    }
    HTMLNode.onchange = onChange;
    if(HTMLNode.type == "text")
    {
    	HTMLNode.onblur = onChange;
    	HTMLNode.onchange = null;
    	HTMLNode.onfocus = function(e)
    	{
    	    focusedComponent = getComponent(e);
    	    prevValues [focusedComponent.id ] = focusedComponent.value;
    	};
    }
    if( callbacks[ HTMLNode.id ] == null )
    {
        callbacks[ HTMLNode.id ] = [];
    }
    var listeners = callbacks[ HTMLNode.id ];
    listeners[ listeners.length++ ] = func;

    logByClass("LISTENERS", "Adding modification listener for " + HTMLNode.id + ", now " + listeners.length + " listeners.")
};

//Rewrite createControl for some BioUML-specific controls
var createCommonControl = ControlFactory.createControl;

ControlFactory.createControl = function( property, format, changeListener )
{
	if( property == null )
    {
        error( "ControlFactory.createControl: property is null" );
        return null;
    }
    var control = null;
    if( property.getType() == "data-element" )	// BioUML only
    {
        control = new JSDataElementSelector(property, format);
    }
    else if( property.getType() == "data-element-path" )	// BioUML only
    {
        control = property.isReadOnly()?new JSEditBox(property, format):new JSDataElementPathEditor(property, format);
    }
    else if( property.getType() == "uploaded-file" )	// BioUML only
    {
        control = new JSFileUploader(property, format);
    }
    else if( property.getType() == "workflow-expression" )	// BioUML only
    {
        control = new JSWorkflowExpressionEditBox(property, format);
    }
    else if( property.getType() == "text-script" )  //BioUML only
    {
        control = new JSTextScriptEditBox(property, format);
    }
    else if( property.getType() == "url" )  //BioUML only
    {
        control = new JSUrlBuilder(property, format);
    }
    else if( property.getType() == "collection" )  //BioUML only
    {
        control = new JSArrayControl(property, format);
    }
    
    if(control != null)
    {
        if( changeListener != null )
        {
            control.addChangeListener(changeListener);
        }
        return control;
    }
    else
    {
        return createCommonControl(property, format, changeListener);
    }
};

// Additional method for listeners removal
JSControl.prototype.removeChangeListener = function( listener )
{
    for( var i = this.changeListeners.length -1; i >= 0 ; i-- )
        if(this.changeListeners[i] == listener)
          this.changeListeners.splice(i,1);
};

JSPropertyInspector.prototype.createEmptyTr = function()
{
    var tr = $('<tr></tr>');
    var div = $('<div>&nbsp;</div>');
    var td = $('<td colspan=2></td>').append(div);
    tr.append(td);
    this.mainTable.append(tr);
    return tr;
};
